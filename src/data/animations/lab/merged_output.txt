
=== File: index.ts ===
Path: index.ts
---- File Content Start ----

// ===========================================
// SECTION K: src/data/animations/lab/index.ts
// ===========================================

/*
export { LabAnimationProvider, useLabAnimation } from './LabAnimationProvider';
export { LabHeatingExperiment } from './components/LabExperiment';
export { InteractiveEquipment } from './components/InteractiveEquipment';
export { LabCanvas } from './components/LabCanvas';
export { LabPhysicsEngine } from './core/LabPhysicsEngine';
export * from './core/labTypes';
export * from './assets';
*/

// ===========================================
// SECTION L: src/screens/LabExperimentScreen.tsx
// ===========================================

/*
import React from 'react';
import { View, Text, ScrollView, SafeAreaView } from 'react-native';
import { LabAnimationProvider, LabHeatingExperiment } from '@/data/animations/lab';
import { useThemedStyles, useTheme } from '@/lib/ThemeContext';
import { Theme } from '@/lib/designSystem';

export const LabExperimentScreen: React.FC = () => {
  const { theme } = useTheme();
  const styles = useThemedStyles(createStyles);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        <View style={styles.header}>
          <Text style={styles.title}>ðŸ§ª Chemistry Lab</Text>
          <Text style={styles.subtitle}>Interactive Molecular Heating Experiment</Text>
        </View>

        <LabAnimationProvider width={350} height={300}>
          <View style={styles.labContainer}>
            <LabHeatingExperiment
              width={350}
              height={300}
              showControls={true}
            />
          </View>
        </LabAnimationProvider>

        <View style={styles.learningSection}>
          <Text style={styles.sectionTitle}>What You'll Learn</Text>
          <View style={styles.learningPoints}>
            <Text style={styles.learningPoint}>â€¢ How molecular motion changes with temperature</Text>
            <Text style={styles.learningPoint}>â€¢ The relationship between heat and particle energy</Text>
            <Text style={styles.learningPoint}>â€¢ Real lab equipment and their functions</Text>
            <Text style={styles.learningPoint}>â€¢ Observable signs of heating (color changes, bubbling)</Text>
          </View>
        </View>

        <View style={styles.instructionsSection}>
          <Text style={styles.sectionTitle}>How to Use</Text>
          <View style={styles.instructions}>
            <Text style={styles.instruction}>1. Touch and hold the Bunsen burner to activate heating</Text>
            <Text style={styles.instruction}>2. Watch the thermometer show rising temperature</Text>
            <Text style={styles.instruction}>3. Observe particles changing color and moving faster</Text>
            <Text style={styles.instruction}>4. Look for bubbles when water gets very hot (80Â°C+)</Text>
            <Text style={styles.instruction}>5. Release the burner to see gradual cooling</Text>
          </View>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const createStyles = (theme: Theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  scrollView: {
    flex: 1,
  },
  header: {
    padding: theme.spacing.lg,
    alignItems: 'center',
    backgroundColor: theme.colors.surface,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.outline,
  },
  title: {
    fontSize: theme.typography.fontSize.xl,
    fontWeight: 'bold',
    color: theme.colors.onSurface,
    marginBottom: theme.spacing.xs,
  },
  subtitle: {
    fontSize: theme.typography.fontSize.md,
    color: theme.colors.onSurfaceVariant,
    textAlign: 'center',
  },
  labContainer: {
    margin: theme.spacing.md,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.borderRadius.lg,
    padding: theme.spacing.sm,
    ...theme.shadows.sm,
  },
  learningSection: {
    margin: theme.spacing.md,
    padding: theme.spacing.md,
    backgroundColor: theme.colors.surfaceVariant,
    borderRadius: theme.borderRadius.md,
  },
  instructionsSection: {
    margin: theme.spacing.md,
    padding: theme.spacing.md,
    backgroundColor: theme.colors.surface,
    borderRadius: theme.borderRadius.md,
    ...theme.shadows.xs,
  },
  sectionTitle: {
    fontSize: theme.typography.fontSize.lg,
    fontWeight: 'bold',
    color: theme.colors.onSurface,
    marginBottom: theme.spacing.sm,
  },
  learningPoints: {
    gap: theme.spacing.xs,
  },
  learningPoint: {
    fontSize: theme.typography.fontSize.sm,
    color: theme.colors.onSurfaceVariant,
    lineHeight: 20,
  },
  instructions: {
    gap: theme.spacing.xs,
  },
  instruction: {
    fontSize: theme.typography.fontSize.sm,
    color: theme.colors.onSurface,
    lineHeight: 20,
  },
});

---- File Content End ----


=== File: LabAnimationProvider.tsx ===
Path: LabAnimationProvider.tsx
---- File Content Start ----
// ===========================================
// SECTION J: src/data/animations/lab/LabAnimationProvider.tsx
// ===========================================

interface LabAnimationContextType {
  physics: LabPhysicsEngine;
  particles: Particle[];
  boundaries: LabBoundary[];
  heatSources: HeatSource[];
  addParticle: (data: Omit<Particle, 'id'>) => string;
  addHeatSource: (data: Omit<HeatSource, 'id'>) => string;
  updateHeatSource: (id: string, updates: Partial<HeatSource>) => void;
  addBoundary: (data: Omit<LabBoundary, 'id'>) => string;
  getTemperatureAt: (x: number, y: number) => number;
  reset: () => void;
}

const LabAnimationContext = createContext<LabAnimationContextType | null>(null);

const LabAnimationProvider: React.FC<{
  children: React.ReactNode;
  width: number;
  height: number
}> = ({ children, width, height }) => {
  const physicsRef = useRef(new LabPhysicsEngine(width, height));
  const [tick, setTick] = useState(0);
  const animationRef = useRef<number>();

  // Animation loop
  useEffect(() => {
    let lastTime = performance.now();

    const animate = (currentTime: number) => {
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.016); // Cap at 60fps
      physicsRef.current.update(deltaTime);
      lastTime = currentTime;
      setTick(t => t + 1);
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);

  const addParticle = useCallback((data: Omit<Particle, 'id'>) => {
    return physicsRef.current.addParticle(data);
  }, []);

  const addHeatSource = useCallback((data: Omit<HeatSource, 'id'>) => {
    return physicsRef.current.addHeatSource(data);
  }, []);

  const updateHeatSource = useCallback((id: string, updates: Partial<HeatSource>) => {
    physicsRef.current.updateHeatSource(id, updates);
  }, []);

  const addBoundary = useCallback((data: Omit<LabBoundary, 'id'>) => {
    return physicsRef.current.addBoundary(data);
  }, []);

  const getTemperatureAt = useCallback((x: number, y: number) => {
    return physicsRef.current.getTemperatureAt(x, y);
  }, []);

  const reset = useCallback(() => {
    physicsRef.current.reset();
  }, []);

  const contextValue: LabAnimationContextType = {
    physics: physicsRef.current,
    particles: physicsRef.current.getParticles(),
    boundaries: physicsRef.current.getBoundaries(),
    heatSources: physicsRef.current.getHeatSources(),
    addParticle,
    addHeatSource,
    updateHeatSource,
    addBoundary,
    getTemperatureAt,
    reset
  };

  return (
    <LabAnimationContext.Provider value={contextValue}>
      {children}
    </LabAnimationContext.Provider>
  );
};

const useLabAnimation = () => {
  const context = useContext(LabAnimationContext);
  if (!context) {
    throw new Error('useLabAnimation must be used within LabAnimationProvider');
  import React, { useState, useEffect, useRef, createContext, useContext, useCallback } from 'react';

// ===========================================
// CORE TYPES & INTERFACES
// ===========================================

interface Particle {
  id: string;
  x: number;
  y: number;
  vx: number;
  vy: number;
  radius: number;
  mass: number;
  color: string;
  maxSpeed: number;
  vibrationIntensity: number;
  temperature: number;
  elementType?: string;
}

interface LabBoundary {
  id: string;
  type: 'container' | 'heater' | 'solid';
  shape: 'rectangle' | 'circle';
  x: number;
  y: number;
  width?: number;
  height?: number;
  radius?: number;
  restitution: number;
  friction: number;
}

interface HeatSource {
  id: string;
  x: number;
  y: number;
  radius: number;
  intensity: number;
  temperature: number;
  isActive: boolean;
}

// ===========================================
// LAB COLORS & CONFIGURATION
// ===========================================

const LabColors = {
  metal: {
    primary: '#8B9DC3',
    secondary: '#6B7FA3',
    highlight: '#B5C4E8',
    shadow: '#4A5568'
  },
  glass: {
    clear: '#E8F4F8',
    tint: '#D1E9F0',
    reflection: '#FFFFFF',
    shadow: '#B8D4DC'
  },
  flame: {
    blue: '#4299E1',
    orange: '#F6AD55',
    yellow: '#FFD700',
    red: '#F56565',
    white: '#FFFFFF'
  },
  liquids: {
    water: '#4A90E2',
    acid: '#FFE135',
    base: '#4ECDC4',
    indicator: '#FF69B4'
  },
  temperature: {
    cold: '#4A90E2',
    warm: '#F6AD55',
    hot: '#F56565'
  }
};

// ===========================================
// PHYSICS ENGINE WITH LAB INTEGRATION
// ===========================================

class LabPhysicsEngine {
  private particles: Map<string, Particle> = new Map();
  private boundaries: Map<string, LabBoundary> = new Map();
  private heatSources: Map<string, HeatSource> = new Map();
  private width: number;
  private height: number;
  private globalTemperature: number = 25;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  // Particle Management
  addParticle(data: Omit<Particle, 'id'> & { id?: string }): string {
    const id = data.id || `particle_${Date.now()}_${Math.random()}`;
    const particle: Particle = {
      ...data,
      id,
      temperature: data.temperature || this.globalTemperature
    };
    this.particles.set(id, particle);
    return id;
  }

  removeParticle(id: string): void {
    this.particles.delete(id);
  }

  // Lab Equipment Management
  addBoundary(boundary: Omit<LabBoundary, 'id'>): string {
    const id = `boundary_${Date.now()}_${Math.random()}`;
    this.boundaries.set(id, { ...boundary, id });
    return id;
  }

  addHeatSource(heatSource: Omit<HeatSource, 'id'>): string {
    const id = `heat_${Date.now()}_${Math.random()}`;
    this.heatSources.set(id, { ...heatSource, id });
    return id;
  }

  updateHeatSource(id: string, updates: Partial<HeatSource>): void {
    const heatSource = this.heatSources.get(id);
    if (heatSource) {
      Object.assign(heatSource, updates);
    }
  }

  // Physics Update
  update(deltaTime: number): void {
    this.applyHeatEffects();
    this.updateParticles(deltaTime);
    this.applyBoundaryConstraints();
  }

  private applyHeatEffects(): void {
    this.particles.forEach(particle => {
      let maxTemp = this.globalTemperature;

      // Check heat sources
      this.heatSources.forEach(heatSource => {
        if (!heatSource.isActive) return;

        const dx = particle.x - heatSource.x;
        const dy = particle.y - heatSource.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < heatSource.radius) {
          const heatFactor = Math.max(0, 1 - distance / heatSource.radius);
          const heatContribution = heatSource.temperature * heatSource.intensity * heatFactor;
          maxTemp = Math.max(maxTemp, this.globalTemperature + heatContribution);
        }
      });

      // Gradually adjust particle temperature
      const tempDiff = maxTemp - particle.temperature;
      particle.temperature += tempDiff * 0.02; // Gradual heating/cooling

      // Update particle properties based on temperature
      this.updateParticleFromTemperature(particle);
    });
  }

  private updateParticleFromTemperature(particle: Particle): void {
    const tempFactor = (particle.temperature - 25) / 75; // 0-1 scale

    // Color changes with temperature
    if (particle.temperature < 40) {
      particle.color = LabColors.temperature.cold;
    } else if (particle.temperature < 70) {
      particle.color = LabColors.temperature.warm;
    } else {
      particle.color = LabColors.temperature.hot;
    }

    // Speed increases with temperature
    particle.maxSpeed = 0.5 + tempFactor * 2.0;

    // Add thermal motion
    const thermalForce = Math.max(0, tempFactor) * 0.3;
    particle.vx += (Math.random() - 0.5) * thermalForce;
    particle.vy += (Math.random() - 0.5) * thermalForce;
  }

  private updateParticles(deltaTime: number): void {
    this.particles.forEach(particle => {
      // Apply friction
      particle.vx *= 0.99;
      particle.vy *= 0.99;

      // Limit speed
      const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
      if (speed > particle.maxSpeed) {
        particle.vx = (particle.vx / speed) * particle.maxSpeed;
        particle.vy = (particle.vy / speed) * particle.maxSpeed;
      }

      // Update position
      particle.x += particle.vx * deltaTime * 20;
      particle.y += particle.vy * deltaTime * 20;

      // Boundary walls
      if (particle.x - particle.radius < 0) {
        particle.x = particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.x + particle.radius > this.width) {
        particle.x = this.width - particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.y - particle.radius < 0) {
        particle.y = particle.radius;
        particle.vy *= -0.8;
      }
      if (particle.y + particle.radius > this.height) {
        particle.y = this.height - particle.radius;
        particle.vy *= -0.8;
      }
    });
  }

  private applyBoundaryConstraints(): void {
    this.particles.forEach(particle => {
      this.boundaries.forEach(boundary => {
        const collision = this.checkCollision(particle, boundary);
        if (collision.hasCollision && collision.normal) {
          // Move particle out
          particle.x -= collision.normal.x * collision.penetration;
          particle.y -= collision.normal.y * collision.penetration;

          // Reflect velocity
          const dot = particle.vx * collision.normal.x + particle.vy * collision.normal.y;
          particle.vx -= 2 * dot * collision.normal.x * boundary.restitution;
          particle.vy -= 2 * dot * collision.normal.y * boundary.restitution;

          // Apply friction
          particle.vx *= (1 - boundary.friction);
          particle.vy *= (1 - boundary.friction);
        }
      });
    });
  }

  private checkCollision(particle: Particle, boundary: LabBoundary): {
    hasCollision: boolean;
    normal?: { x: number; y: number };
    penetration: number;
  } {
    if (boundary.shape === 'rectangle' && boundary.width && boundary.height) {
      const left = boundary.x;
      const right = boundary.x + boundary.width;
      const top = boundary.y;
      const bottom = boundary.y + boundary.height;

      // Check if inside container
      if (particle.x + particle.radius > left &&
          particle.x - particle.radius < right &&
          particle.y + particle.radius > top &&
          particle.y - particle.radius < bottom) {

        // Find closest wall
        const distLeft = particle.x - left;
        const distRight = right - particle.x;
        const distTop = particle.y - top;
        const distBottom = bottom - particle.y;

        const minDist = Math.min(distLeft, distRight, distTop, distBottom);
        let normal: { x: number; y: number };

        if (minDist === distLeft) normal = { x: -1, y: 0 };
        else if (minDist === distRight) normal = { x: 1, y: 0 };
        else if (minDist === distTop) normal = { x: 0, y: -1 };
        else normal = { x: 0, y: 1 };

        return {
          hasCollision: true,
          normal,
          penetration: particle.radius - minDist
        };
      }
    }

    return { hasCollision: false, penetration: 0 };
  }

  // Getters
  getParticles(): Particle[] {
    return Array.from(this.particles.values());
  }

  getBoundaries(): LabBoundary[] {
    return Array.from(this.boundaries.values());
  }

  getHeatSources(): HeatSource[] {
    return Array.from(this.heatSources.values());
  }

  getTemperatureAt(x: number, y: number): number {
    let maxTemp = this.globalTemperature;

    this.heatSources.forEach(heatSource => {
      if (!heatSource.isActive) return;
      const distance = Math.sqrt((x - heatSource.x) ** 2 + (y - heatSource.y) ** 2);
      if (distance < heatSource.radius) {
        const factor = 1 - distance / heatSource.radius;
        maxTemp = Math.max(maxTemp, this.globalTemperature + heatSource.temperature * factor);
      }
    });

    return maxTemp;
  }

  reset(): void {
    this.particles.clear();
    this.boundaries.clear();
    this.heatSources.clear();
  }
}

// ===========================================
// SVG LAB EQUIPMENT COMPONENTS
// ===========================================

const BunsenBurnerSVG: React.FC<{ width: number; height: number; isActive: boolean }> = ({ width, height, isActive }) => (
  <svg width={width} height={height} viewBox="0 0 60 80">
    {/* Base */}
    <rect x="20" y="70" width="20" height="8" rx="2" fill={LabColors.metal.primary} />

    {/* Main tube */}
    <rect x="26" y="20" width="8" height="50" rx="4" fill={LabColors.metal.primary} stroke={LabColors.metal.secondary} strokeWidth="1" />

    {/* Gas control */}
    <rect x="24" y="45" width="12" height="6" rx="3" fill={LabColors.metal.secondary} />

    {/* Air holes */}
    <circle cx="27" cy="48" r="0.8" fill={LabColors.metal.shadow} />
    <circle cx="33" cy="48" r="0.8" fill={LabColors.metal.shadow} />

    {/* Burner head */}
    <rect x="24" y="18" width="12" height="8" rx="2" fill={LabColors.metal.secondary} />

    {/* Gas outlet */}
    <circle cx="30" cy="20" r="2" fill={LabColors.metal.shadow} />

    {/* Flame */}
    {isActive && (
      <path
        d="M 30 20 Q 25 15 27 8 Q 29 5 30 3 Q 31 5 33 8 Q 35 15 30 20 Z"
        fill="url(#flameGradient)"
        opacity="0.9"
      >
        <animateTransform
          attributeName="transform"
          type="scale"
          values="1,1;1.1,1.2;1,1"
          dur="0.5s"
          repeatCount="indefinite"
        />
      </path>
    )}

    <defs>
      <radialGradient id="flameGradient" cx="50%" cy="80%" r="60%">
        <stop offset="0%" stopColor={LabColors.flame.blue} />
        <stop offset="50%" stopColor={LabColors.flame.orange} />
        <stop offset="100%" stopColor={LabColors.flame.red} />
      </radialGradient>
    </defs>
  </svg>
);

const BeakerSVG: React.FC<{ width: number; height: number; liquidLevel: number; bubbles?: boolean }> = ({
  width, height, liquidLevel, bubbles = false
}) => (
  <svg width={width} height={height} viewBox="0 0 80 100">
    {/* Beaker body */}
    <path
      d="M 15 85 L 15 25 L 65 25 L 65 85 Q 65 90 40 90 Q 15 90 15 85 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="2"
      opacity="0.8"
    />

    {/* Spout */}
    <path
      d="M 65 25 L 75 20 L 75 30 L 65 35 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="1.5"
      opacity="0.8"
    />

    {/* Liquid */}
    {liquidLevel > 0 && (
      <path
        d={`M 17 ${85 - liquidLevel * 60} L 17 83 Q 17 88 40 88 Q 63 88 63 83 L 63 ${85 - liquidLevel * 60} Q 40 ${87 - liquidLevel * 60} 17 ${85 - liquidLevel * 60} Z`}
        fill={LabColors.liquids.water}
        opacity="0.7"
      />
    )}

    {/* Bubbles */}
    {bubbles && liquidLevel > 0 && (
      <g>
        <circle cx="25" cy="70" r="2" fill="rgba(255,255,255,0.6)">
          <animateTransform attributeName="transform" type="translate" values="0,0; 2,-40" dur="2s" repeatCount="indefinite" />
          <animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" />
        </circle>
        <circle cx="40" cy="75" r="1.5" fill="rgba(255,255,255,0.6)">
          <animateTransform attributeName="transform" type="translate" values="0,0; -1,-35" dur="1.8s" repeatCount="indefinite" />
          <animate attributeName="opacity" values="0;1;0" dur="1.8s" repeatCount="indefinite" />
        </circle>
        <circle cx="55" cy="72" r="2.5" fill="rgba(255,255,255,0.6)">
          <animateTransform attributeName="transform" type="translate" values="0,0; 1,-38" dur="2.2s" repeatCount="indefinite" />
          <animate attributeName="opacity" values="0;1;0" dur="2.2s" repeatCount="indefinite" />
        </circle>
      </g>
    )}

    {/* Volume markings */}
    <g stroke={LabColors.glass.shadow} strokeWidth="0.5" opacity="0.6">
      <line x1="12" y1="45" x2="20" y2="45" />
      <line x1="12" y1="60" x2="20" y2="60" />
      <line x1="12" y1="75" x2="20" y2="75" />
    </g>

    {/* Glass highlight */}
    <rect x="18" y="27" width="2" height="55" rx="1" fill={LabColors.glass.reflection} opacity="0.4" />
  </svg>
);

const ThermometerSVG: React.FC<{ width: number; height: number; temperature: number }> = ({ width, height, temperature }) => {
  const mercuryLevel = Math.max(0, Math.min(1, (temperature - 0) / 100));

  return (
    <svg width={width} height={height} viewBox="0 0 20 120">
      {/* Thermometer body */}
      <rect x="6" y="15" width="8" height="85" rx="4" fill={LabColors.glass.clear} stroke={LabColors.glass.shadow} strokeWidth="1" />

      {/* Bulb */}
      <circle cx="10" cy="105" r="7" fill={LabColors.glass.clear} stroke={LabColors.glass.shadow} strokeWidth="1" />

      {/* Mercury */}
      <rect
        x="7"
        y={100 - mercuryLevel * 80}
        width="6"
        height={mercuryLevel * 80}
        rx="3"
        fill={temperature > 50 ? '#FF4444' : '#FF6666'}
      />

      {/* Mercury bulb */}
      <circle cx="10" cy="105" r="5" fill={temperature > 50 ? '#FF4444' : '#FF6666'} />

      {/* Scale markings */}
      <g stroke={LabColors.glass.shadow} strokeWidth="0.3" fontSize="4" textAnchor="start">
        <line x1="15" y1="30" x2="18" y2="30" />
        <text x="19" y="32" fill={LabColors.glass.shadow}>100</text>
        <line x1="15" y1="60" x2="18" y2="60" />
        <text x="19" y="62" fill={LabColors.glass.shadow}>50</text>
        <line x1="15" y1="90" x2="18" y2="90" />
        <text x="19" y="92" fill={LabColors.glass.shadow}>0</text>
      </g>

      {/* Current temperature */}
      <text x="10" y="8" fontSize="6" textAnchor="middle" fill={LabColors.glass.shadow} fontWeight="bold">
        {Math.round(temperature)}Â°C
      </text>
    </svg>
  );
};

// ===========================================
// ANIMATION CONTEXT & PROVIDER
// ===========================================

interface LabAnimationContextType {
  physics: LabPhysicsEngine;
  particles: Particle[];
  boundaries: LabBoundary[];
  heatSources: HeatSource[];
  addParticle: (data: Omit<Particle, 'id'>) => string;
  addHeatSource: (data: Omit<HeatSource, 'id'>) => string;
  updateHeatSource: (id: string, updates: Partial<HeatSource>) => void;
  addBoundary: (data: Omit<LabBoundary, 'id'>) => string;
  getTemperatureAt: (x: number, y: number) => number;
  reset: () => void;
}

const LabAnimationContext = createContext<LabAnimationContextType | null>(null);

const LabAnimationProvider: React.FC<{
  children: React.ReactNode;
  width: number;
  height: number
}> = ({ children, width, height }) => {
  const physicsRef = useRef(new LabPhysicsEngine(width, height));
  const [tick, setTick] = useState(0);
  const animationRef = useRef<number>();

  // Animation loop
  useEffect(() => {
    let lastTime = performance.now();

    const animate = (currentTime: number) => {
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.016); // Cap at 60fps
      physicsRef.current.update(deltaTime);
      lastTime = currentTime;
      setTick(t => t + 1);
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);

  const addParticle = useCallback((data: Omit<Particle, 'id'>) => {
    return physicsRef.current.addParticle(data);
  }, []);

  const addHeatSource = useCallback((data: Omit<HeatSource, 'id'>) => {
    return physicsRef.current.addHeatSource(data);
  }, []);

  const updateHeatSource = useCallback((id: string, updates: Partial<HeatSource>) => {
    physicsRef.current.updateHeatSource(id, updates);
  }, []);

  const addBoundary = useCallback((data: Omit<LabBoundary, 'id'>) => {
    return physicsRef.current.addBoundary(data);
  }, []);

  const getTemperatureAt = useCallback((x: number, y: number) => {
    return physicsRef.current.getTemperatureAt(x, y);
  }, []);

  const reset = useCallback(() => {
    physicsRef.current.reset();
  }, []);

  const contextValue: LabAnimationContextType = {
    physics: physicsRef.current,
    particles: physicsRef.current.getParticles(),
    boundaries: physicsRef.current.getBoundaries(),
    heatSources: physicsRef.current.getHeatSources(),
    addParticle,
    addHeatSource,
    updateHeatSource,
    addBoundary,
    getTemperatureAt,
    reset
  };

  return (
    <LabAnimationContext.Provider value={contextValue}>
      {children}
    </LabAnimationContext.Provider>
  );
};

const useLabAnimation = () => {
  const context = useContext(LabAnimationContext);
  if (!context) {
    throw new Error('useLabAnimation must be used within LabAnimationProvider');
  }
  return context;
};

---- File Content End ----


=== File: Beaker.tsx ===
Path: assets\Beaker.tsx
---- File Content Start ----

// ===========================================
// SECTION D: src/data/animations/lab/assets/Beaker.tsx
// ===========================================

/*
COPY TO Beaker.tsx - React Native SVG version:
*/

const BeakerSVG: React.FC<{ width: number; height: number; liquidLevel: number; bubbles?: boolean }> = ({
  width, height, liquidLevel, bubbles = false
}) => (
  <Svg width={width} height={height} viewBox="0 0 80 100">
    {/* Beaker body */}
    <Path
      d="M 15 85 L 15 25 L 65 25 L 65 85 Q 65 90 40 90 Q 15 90 15 85 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="2"
      opacity="0.8"
    />

    {/* Spout */}
    <Path
      d="M 65 25 L 75 20 L 75 30 L 65 35 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="1.5"
      opacity="0.8"
    />

    {/* Liquid */}
    {liquidLevel > 0 && (
      <Path
        d={`M 17 ${85 - liquidLevel * 60} L 17 83 Q 17 88 40 88 Q 63 88 63 83 L 63 ${85 - liquidLevel * 60} Q 40 ${87 - liquidLevel * 60} 17 ${85 - liquidLevel * 60} Z`}
        fill={LabColors.liquids.water}
        opacity="0.7"
      />
    )}

    {/* Bubbles */}
    {bubbles && liquidLevel > 0 && (
      <G>
        <Circle cx="25" cy="70" r="2" fill="rgba(255,255,255,0.6)">
          <AnimateTransform attributeName="transform" type="translate" values="0,0; 2,-40" dur="2s" repeatCount="indefinite" />
          <Animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" />
        </Circle>
        <Circle cx="40" cy="75" r="1.5" fill="rgba(255,255,255,0.6)">
          <AnimateTransform attributeName="transform" type="translate" values="0,0; -1,-35" dur="1.8s" repeatCount="indefinite" />
          <Animate attributeName="opacity" values="0;1;0" dur="1.8s" repeatCount="indefinite" />
        </Circle>
        <Circle cx="55" cy="72" r="2.5" fill="rgba(255,255,255,0.6)">
          <AnimateTransform attributeName="transform" type="translate" values="0,0; 1,-38" dur="2.2s" repeatCount="indefinite" />
          <Animate attributeName="opacity" values="0;1;0" dur="2.2s" repeatCount="indefinite" />
        </Circle>
      </G>
    )}

    {/* Volume markings */}
    <G stroke={LabColors.glass.shadow} strokeWidth="0.5" opacity="0.6">
      <Line x1="12" y1="45" x2="20" y2="45" />
      <Line x1="12" y1="60" x2="20" y2="60" />
      <Line x1="12" y1="75" x2="20" y2="75" />
    </G>

    {/* Glass highlight */}
    <Rect x="18" y="27" width="2" height="55" rx="1" fill={LabColors.glass.reflection} opacity="0.4" />
  </Svg>
);

---- File Content End ----


=== File: BunsenBurner.tsx ===
Path: assets\BunsenBurner.tsx
---- File Content Start ----
// ===========================================
// SECTION C: src/data/animations/lab/assets/BunsenBurner.tsx
// ===========================================

/*
import React from 'react';
import Svg, { Rect, Circle, Path, Defs, RadialGradient, Stop, AnimateTransform } from 'react-native-svg';

interface BunsenBurnerProps {
  width: number;
  height: number;
  isActive: boolean;
}

export const BunsenBurnerSVG: React.FC<BunsenBurnerProps> = ({ width, height, isActive }) => (
  // COPY THE SVG CODE BELOW, CONVERTING TO react-native-svg format
*/

const LabColors = {
  metal: {
    primary: '#8B9DC3',
    secondary: '#6B7FA3',
    highlight: '#B5C4E8',
    shadow: '#4A5568'
  },
  glass: {
    clear: '#E8F4F8',
    tint: '#D1E9F0',
    reflection: '#FFFFFF',
    shadow: '#B8D4DC'
  },
  flame: {
    blue: '#4299E1',
    orange: '#F6AD55',
    yellow: '#FFD700',
    red: '#F56565',
    white: '#FFFFFF'
  },
  liquids: {
    water: '#4A90E2',
    acid: '#FFE135',
    base: '#4ECDC4',
    indicator: '#FF69B4'
  },
  temperature: {
    cold: '#4A90E2',
    warm: '#F6AD55',
    hot: '#F56565'
  }
};
// React Native SVG Version - COPY THIS TO BunsenBurner.tsx
const BunsenBurnerSVG: React.FC<{ width: number; height: number; isActive: boolean }> = ({ width, height, isActive }) => (
  <Svg width={width} height={height} viewBox="0 0 60 80">
    {/* Base */}
    <Rect x="20" y="70" width="20" height="8" rx="2" fill={LabColors.metal.primary} />

    {/* Main tube */}
    <Rect x="26" y="20" width="8" height="50" rx="4" fill={LabColors.metal.primary} stroke={LabColors.metal.secondary} strokeWidth="1" />

    {/* Gas control */}
    <Rect x="24" y="45" width="12" height="6" rx="3" fill={LabColors.metal.secondary} />

    {/* Air holes */}
    <Circle cx="27" cy="48" r="0.8" fill={LabColors.metal.shadow} />
    <Circle cx="33" cy="48" r="0.8" fill={LabColors.metal.shadow} />

    {/* Burner head */}
    <Rect x="24" y="18" width="12" height="8" rx="2" fill={LabColors.metal.secondary} />

    {/* Gas outlet */}
    <Circle cx="30" cy="20" r="2" fill={LabColors.metal.shadow} />

    {/* Flame */}
    {isActive && (
      <G>
        <Defs>
          <RadialGradient id="flameGradient" cx="50%" cy="80%" r="60%">
            <Stop offset="0%" stopColor={LabColors.flame.blue} />
            <Stop offset="50%" stopColor={LabColors.flame.orange} />
            <Stop offset="100%" stopColor={LabColors.flame.red} />
          </RadialGradient>
        </Defs>
        <Path
          d="M 30 20 Q 25 15 27 8 Q 29 5 30 3 Q 31 5 33 8 Q 35 15 30 20 Z"
          fill="url(#flameGradient)"
          opacity="0.9"
        >
          <AnimateTransform
            attributeName="transform"
            type="scale"
            values="1,1;1.1,1.2;1,1"
            dur="0.5s"
            repeatCount="indefinite"
          />
        </Path>
      </G>
    )}
  </Svg>
);

---- File Content End ----


=== File: index.ts ===
Path: assets\index.ts
---- File Content Start ----
// ===========================================
// SECTION F: src/data/animations/lab/assets/index.ts
// ===========================================

/*
export { BunsenBurnerSVG } from './BunsenBurner';
export { BeakerSVG } from './Beaker';
export { ThermometerSVG } from './Thermometer';
export { LabColors } from './colors';
*/

---- File Content End ----


=== File: Thermometer.tsx ===
Path: assets\Thermometer.tsx
---- File Content Start ----
// ===========================================
// SECTION E: src/data/animations/lab/assets/Thermometer.tsx
// ===========================================

const ThermometerSVG: React.FC<{ width: number; height: number; temperature: number }> = ({ width, height, temperature }) => {
  const mercuryLevel = Math.max(0, Math.min(1, (temperature - 0) / 100));

  return (
    <Svg width={width} height={height} viewBox="0 0 20 120">
      {/* Thermometer body */}
      <Rect x="6" y="15" width="8" height="85" rx="4" fill={LabColors.glass.clear} stroke={LabColors.glass.shadow} strokeWidth="1" />

      {/* Bulb */}
      <Circle cx="10" cy="105" r="7" fill={LabColors.glass.clear} stroke={LabColors.glass.shadow} strokeWidth="1" />

      {/* Mercury */}
      <Rect
        x="7"
        y={100 - mercuryLevel * 80}
        width="6"
        height={mercuryLevel * 80}
        rx="3"
        fill={temperature > 50 ? '#FF4444' : '#FF6666'}
      />

      {/* Mercury bulb */}
      <Circle cx="10" cy="105" r="5" fill={temperature > 50 ? '#FF4444' : '#FF6666'} />

      {/* Scale markings */}
      <G stroke={LabColors.glass.shadow} strokeWidth="0.3">
        <Line x1="15" y1="30" x2="18" y2="30" />
        <Line x1="15" y1="60" x2="18" y2="60" />
        <Line x1="15" y1="90" x2="18" y2="90" />
      </G>
    </Svg>
  );
};

---- File Content End ----


=== File: LabCanvas.tsx ===
Path: components\LabCanvas.tsx
---- File Content Start ----

// ===========================================
// SECTION H: src/data/animations/lab/components/LabCanvas.tsx
// ===========================================

/*
import React from 'react';
import { View } from 'react-native';
import Svg, { Circle, Line, Rect } from 'react-native-svg';
import { useLabAnimation } from '../LabAnimationProvider';

export const LabCanvas: React.FC<{
  width: number;
  height: number;
  showTemperatureField?: boolean;
  children?: React.ReactNode;
}> = ({ width, height, showTemperatureField = false, children }) => {
  const { particles, heatSources } = useLabAnimation();

  return (
    <View style={{ width, height, position: 'relative' }}>
      // COPY THE SVG RENDERING LOGIC FROM BELOW
      {children}
    </View>
  );
};
*/

---- File Content End ----


=== File: LabEquipment.tsx ===
Path: components\LabEquipment.tsx
---- File Content Start ----

// ===========================================
// SECTION G: src/data/animations/lab/components/InteractiveEquipment.tsx
// ===========================================

/*
import React, { useState, useEffect } from 'react';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { BunsenBurnerSVG, BeakerSVG, ThermometerSVG } from '../assets';
import { useLabAnimation } from '../LabAnimationProvider';
import { useThemedStyles } from '@/lib/ThemeContext';

interface InteractiveEquipmentProps {
  type: 'bunsenBurner' | 'beaker' | 'thermometer';
  x: number;
  y: number;
  width: number;
  height: number;
  onInteraction?: (action: string, value?: any) => void;
}

export const InteractiveEquipment: React.FC<InteractiveEquipmentProps> = ({
  type, x, y, width, height, onInteraction
}) => {
  // COPY THE INTERACTIVE LOGIC FROM BELOW
  // Replace mouse events with Pressable onPressIn/onPressOut
*/

class LabPhysicsEngine {
  private particles: Map<string, Particle> = new Map();
  private boundaries: Map<string, LabBoundary> = new Map();
  private heatSources: Map<string, HeatSource> = new Map();
  private width: number;
  private height: number;
  private globalTemperature: number = 25;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  // Particle Management
  addParticle(data: Omit<Particle, 'id'> & { id?: string }): string {
    const id = data.id || `particle_${Date.now()}_${Math.random()}`;
    const particle: Particle = {
      ...data,
      id,
      temperature: data.temperature || this.globalTemperature
    };
    this.particles.set(id, particle);
    return id;
  }

  removeParticle(id: string): void {
    this.particles.delete(id);
  }

  // Lab Equipment Management
  addBoundary(boundary: Omit<LabBoundary, 'id'>): string {
    const id = `boundary_${Date.now()}_${Math.random()}`;
    this.boundaries.set(id, { ...boundary, id });
    return id;
  }

  addHeatSource(heatSource: Omit<HeatSource, 'id'>): string {
    const id = `heat_${Date.now()}_${Math.random()}`;
    this.heatSources.set(id, { ...heatSource, id });
    return id;
  }

  updateHeatSource(id: string, updates: Partial<HeatSource>): void {
    const heatSource = this.heatSources.get(id);
    if (heatSource) {
      Object.assign(heatSource, updates);
    }
  }

  // Physics Update
  update(deltaTime: number): void {
    this.applyHeatEffects();
    this.updateParticles(deltaTime);
    this.applyBoundaryConstraints();
  }

  private applyHeatEffects(): void {
    this.particles.forEach(particle => {
      let maxTemp = this.globalTemperature;

      // Check heat sources
      this.heatSources.forEach(heatSource => {
        if (!heatSource.isActive) return;

        const dx = particle.x - heatSource.x;
        const dy = particle.y - heatSource.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < heatSource.radius) {
          const heatFactor = Math.max(0, 1 - distance / heatSource.radius);
          const heatContribution = heatSource.temperature * heatSource.intensity * heatFactor;
          maxTemp = Math.max(maxTemp, this.globalTemperature + heatContribution);
        }
      });

      // Gradually adjust particle temperature
      const tempDiff = maxTemp - particle.temperature;
      particle.temperature += tempDiff * 0.02; // Gradual heating/cooling

      // Update particle properties based on temperature
      this.updateParticleFromTemperature(particle);
    });
  }

  private updateParticleFromTemperature(particle: Particle): void {
    const tempFactor = (particle.temperature - 25) / 75; // 0-1 scale

    // Color changes with temperature
    if (particle.temperature < 40) {
      particle.color = LabColors.temperature.cold;
    } else if (particle.temperature < 70) {
      particle.color = LabColors.temperature.warm;
    } else {
      particle.color = LabColors.temperature.hot;
    }

    // Speed increases with temperature
    particle.maxSpeed = 0.5 + tempFactor * 2.0;

    // Add thermal motion
    const thermalForce = Math.max(0, tempFactor) * 0.3;
    particle.vx += (Math.random() - 0.5) * thermalForce;
    particle.vy += (Math.random() - 0.5) * thermalForce;
  }

  private updateParticles(deltaTime: number): void {
    this.particles.forEach(particle => {
      // Apply friction
      particle.vx *= 0.99;
      particle.vy *= 0.99;

      // Limit speed
      const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
      if (speed > particle.maxSpeed) {
        particle.vx = (particle.vx / speed) * particle.maxSpeed;
        particle.vy = (particle.vy / speed) * particle.maxSpeed;
      }

      // Update position
      particle.x += particle.vx * deltaTime * 20;
      particle.y += particle.vy * deltaTime * 20;

      // Boundary walls
      if (particle.x - particle.radius < 0) {
        particle.x = particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.x + particle.radius > this.width) {
        particle.x = this.width - particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.y - particle.radius < 0) {
        particle.y = particle.radius;
        particle.vy *= -0.8;
      }
      if (particle.y + particle.radius > this.height) {
        particle.y = this.height - particle.radius;
        particle.vy *= -0.8;
      }
    });
  }

  private applyBoundaryConstraints(): void {
    this.particles.forEach(particle => {
      this.boundaries.forEach(boundary => {
        const collision = this.checkCollision(particle, boundary);
        if (collision.hasCollision && collision.normal) {
          // Move particle out
          particle.x -= collision.normal.x * collision.penetration;
          particle.y -= collision.normal.y * collision.penetration;

          // Reflect velocity
          const dot = particle.vx * collision.normal.x + particle.vy * collision.normal.y;
          particle.vx -= 2 * dot * collision.normal.x * boundary.restitution;
          particle.vy -= 2 * dot * collision.normal.y * boundary.restitution;

          // Apply friction
          particle.vx *= (1 - boundary.friction);
          particle.vy *= (1 - boundary.friction);
        }
      });
    });
  }

  private checkCollision(particle: Particle, boundary: LabBoundary): {
    hasCollision: boolean;
    normal?: { x: number; y: number };
    penetration: number;
  } {
    if (boundary.shape === 'rectangle' && boundary.width && boundary.height) {
      const left = boundary.x;
      const right = boundary.x + boundary.width;
      const top = boundary.y;
      const bottom = boundary.y + boundary.height;

      // Check if inside container
      if (particle.x + particle.radius > left &&
          particle.x - particle.radius < right &&
          particle.y + particle.radius > top &&
          particle.y - particle.radius < bottom) {

        // Find closest wall
        const distLeft = particle.x - left;
        const distRight = right - particle.x;
        const distTop = particle.y - top;
        const distBottom = bottom - particle.y;

        const minDist = Math.min(distLeft, distRight, distTop, distBottom);
        let normal: { x: number; y: number };

        if (minDist === distLeft) normal = { x: -1, y: 0 };
        else if (minDist === distRight) normal = { x: 1, y: 0 };
        else if (minDist === distTop) normal = { x: 0, y: -1 };
        else normal = { x: 0, y: 1 };

        return {
          hasCollision: true,
          normal,
          penetration: particle.radius - minDist
        };
      }
    }

    return { hasCollision: false, penetration: 0 };
  }

  // Getters
  getParticles(): Particle[] {
    return Array.from(this.particles.values());
  }

  getBoundaries(): LabBoundary[] {
    return Array.from(this.boundaries.values());
  }

  getHeatSources(): HeatSource[] {
    return Array.from(this.heatSources.values());
  }

  getTemperatureAt(x: number, y: number): number {
    let maxTemp = this.globalTemperature;

    this.heatSources.forEach(heatSource => {
      if (!heatSource.isActive) return;
      const distance = Math.sqrt((x - heatSource.x) ** 2 + (y - heatSource.y) ** 2);
      if (distance < heatSource.radius) {
        const factor = 1 - distance / heatSource.radius;
        maxTemp = Math.max(maxTemp, this.globalTemperature + heatSource.temperature * factor);
      }
    });

    return maxTemp;
  }

  reset(): void {
    this.particles.clear();
    this.boundaries.clear();
    this.heatSources.clear();
  }
}

---- File Content End ----


=== File: LabExperiments.tsx ===
Path: components\LabExperiments.tsx
---- File Content Start ----
// ===========================================
// SECTION I: src/data/animations/lab/components/LabExperiment.tsx
// ===========================================

/*
import React, { useState } from 'react';
import { View, Text, Pressable } from 'react-native';
import { LabCanvas } from './LabCanvas';
import { InteractiveEquipment } from './InteractiveEquipment';
import { useThemedStyles } from '@/lib/ThemeContext';

export const LabHeatingExperiment: React.FC<{
  width?: number;
  height?: number;
  showControls?: boolean;
}> = ({ width = 350, height = 300, showControls = true }) => {
  const styles = useThemedStyles(createStyles);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Chemistry Lab Experiment</Text>

      <LabCanvas width={width} height={height}>
        <InteractiveEquipment
          type="bunsenBurner"
          x={80}
          y={250}
          width={60}
          height={80}
        />

        <InteractiveEquipment
          type="beaker"
          x={60}
          y={120}
          width={100}
          height={140}
        />

        <InteractiveEquipment
          type="thermometer"
          x={180}
          y={140}
          width={25}
          height={120}
        />
      </LabCanvas>

      {showControls && (
        <Text style={styles.instructions}>
          Touch and hold the Bunsen burner to heat the water!
        </Text>
      )}
    </View>
  );
};

const createStyles = (theme: any) => StyleSheet.create({
  container: {
    padding: theme.spacing.md,
    backgroundColor: theme.colors.surface,
  },
  title: {
    fontSize: theme.typography.fontSize.lg,
    fontWeight: 'bold',
    color: theme.colors.onSurface,
    marginBottom: theme.spacing.md,
    textAlign: 'center',
  },
  instructions: {
    fontSize: theme.typography.fontSize.sm,
    color: theme.colors.onSurfaceVariant,
    textAlign: 'center',
    marginTop: theme.spacing.sm,
  },
});
*/

---- File Content End ----


=== File: LabPhysicsEngine.ts ===
Path: core\LabPhysicsEngine.ts
---- File Content Start ----
// ===========================================
// SECTION A: src/data/animations/lab/core/LabPhysicsEngine.ts
// ===========================================

/*
import type { Particle, LabBoundary, HeatSource } from './labTypes';

export class LabPhysicsEngine {
  // COPY ALL THE LabPhysicsEngine CODE FROM BELOW
  // Replace 'React' imports with React Native equivalents where needed
*/

import React, { useState, useEffect, useRef, createContext, useContext, useCallback } from 'react';

// React Native specific imports - ADD THESE TO YOUR FILES
/*
import { View, Text, Pressable, Dimensions, StyleSheet } from 'react-native';
import Svg, {
  Circle,
  Rect,
  Path,
  Line,
  G,
  Defs,
  RadialGradient,
  LinearGradient,
  Stop,
  AnimateTransform,
  Animate
} from 'react-native-svg';
import { useThemedStyles, useTheme } from '@/lib/ThemeContext';

---- File Content End ----


=== File: LabSceneBuilder.ts ===
Path: core\LabSceneBuilder.ts
---- File Content Start ----

---- File Content End ----


=== File: labTypes.ts ===
Path: core\labTypes.ts
---- File Content Start ----
// ===========================================
// SECTION B: src/data/animations/lab/core/labTypes.ts
// ===========================================

interface Particle {
  id: string;
  x: number;
  y: number;
  vx: number;
  vy: number;
  radius: number;
  mass: number;
  color: string;
  maxSpeed: number;
  vibrationIntensity: number;
  temperature: number;
  elementType?: string;
}

interface LabBoundary {
  id: string;
  type: 'container' | 'heater' | 'solid';
  shape: 'rectangle' | 'circle';
  x: number;
  y: number;
  width?: number;
  height?: number;
  radius?: number;
  restitution: number;
  friction: number;
}

interface HeatSource {
  id: string;
  x: number;
  y: number;
  radius: number;
  intensity: number;
  temperature: number;
  isActive: boolean;
}

---- File Content End ----

