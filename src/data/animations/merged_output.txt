
=== File: UnifiedAnimationProvider.tsx ===
Path: UnifiedAnimationProvider.tsx
---- File Content Start ----
// src/data/animations/UnifiedAnimationProvider.tsx

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
  ReactNode
} from 'react';
import { UnifiedPhysicsEngine } from './core/UnifiedPhysicsEngine';
import { PerformanceManager } from './core/Performance';
import { SceneBuilder } from './core/SceneBuilder';
import type {
  AnimationContextAPI,
  AnimationConfig,
  PhysicsState,
  Particle,
  Bond,
  LabBoundary,
  HeatSource
} from './core/types';
import { UniqueID } from '@/utils/UniqueID';

// ===== CONTEXT =====
const UnifiedAnimationContext = createContext<AnimationContextAPI | undefined>(undefined);

// ===== PROVIDER PROPS =====
interface UnifiedAnimationProviderProps {
  children: ReactNode;
  initialConfig?: AnimationConfig;
  autoStart?: boolean;
}

// ===== MAIN PROVIDER =====
export const UnifiedAnimationProvider: React.FC<UnifiedAnimationProviderProps> = ({
  children,
  initialConfig,
  autoStart = true
}) => {
  // Core engine instances
  const performanceManagerRef = useRef(
    new PerformanceManager(initialConfig?.performanceMode || 'low')
  );

  const physicsEngineRef = useRef(
    new UnifiedPhysicsEngine(
      initialConfig?.width || 300,
      initialConfig?.height || 300,
      performanceManagerRef.current.getPerformanceSettings().level
    )
  );

  const sceneBuilderRef = useRef(
    new SceneBuilder(physicsEngineRef.current)
  );

  // State
  const [tick, setTick] = useState(0);
  const [isRunning, setIsRunning] = useState(autoStart);

  // Animation control
  const animationFrameIdRef = useRef<number | null>(null);
  const lastTimestampRef = useRef<number>(performance.now());

  // ===== INITIALIZATION =====
  useEffect(() => {
    if (initialConfig) {
      try {
        sceneBuilderRef.current.buildFromConfig(initialConfig);
        if (initialConfig.initialTemperature !== undefined) {
          physicsEngineRef.current.setTemperature(initialConfig.initialTemperature);
        }
        setTick(t => t + 1);
      } catch (error) {
        console.error('Failed to initialize animation with config:', error);
      }
    }
  }, [initialConfig]);

  // ===== ANIMATION LOOP =====
  useEffect(() => {
    if (!isRunning) return;

    const engine = physicsEngineRef.current;
    const perfManager = performanceManagerRef.current;

    const animate = (currentTime: number) => {
      if (!isRunning) return;

      try {
        const deltaTime = currentTime - lastTimestampRef.current;
        const targetInterval = 1000 / perfManager.getPerformanceSettings().frameRate;

        if (deltaTime >= targetInterval * 0.9 || deltaTime > 250) {
          engine.update(Math.min(deltaTime, 250), currentTime);
          lastTimestampRef.current = currentTime;
          setTick(t => t + 1);
        }

        animationFrameIdRef.current = requestAnimationFrame(animate);
      } catch (error) {
        console.error('Animation loop error:', error);
        // Continue animation despite errors
        animationFrameIdRef.current = requestAnimationFrame(animate);
      }
    };

    animationFrameIdRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
    };
  }, [isRunning]);

  // ===== API METHODS =====
  const getPhysicsState = useCallback((): PhysicsState => {
    return physicsEngineRef.current.getState(lastTimestampRef.current);
  }, []);

  const setTemperature = useCallback((temp: number) => {
    physicsEngineRef.current.setTemperature(temp);
    setTick(t => t + 1);
  }, []);

  const getTemperatureAt = useCallback((x: number, y: number) => {
    return physicsEngineRef.current.getTemperatureAt(x, y);
  }, []);

  const addParticle = useCallback((particleData: Omit<Particle, 'id'> & { id?: string }): string => {
    const id = physicsEngineRef.current.addParticle(particleData);
    setTick(t => t + 1);
    return id;
  }, []);

  const removeParticle = useCallback((particleId: string) => {
    physicsEngineRef.current.removeParticle(particleId);
    setTick(t => t + 1);
  }, []);

  const addBond = useCallback((bondData: {
    p1Id: string;
    p2Id: string;
    restLength?: number;
    type?: Bond['type'];
    id?: string;
  }): string | null => {
    const id = physicsEngineRef.current.addBond(bondData);
    if (id) setTick(t => t + 1);
    return id;
  }, []);

  const removeBond = useCallback((bondId: string) => {
    physicsEngineRef.current.removeBond(bondId);
    setTick(t => t + 1);
  }, []);

  const addBoundary = useCallback((boundary: Omit<LabBoundary, 'id'>): string => {
    const id = physicsEngineRef.current.addBoundary(boundary);
    setTick(t => t + 1);
    return id;
  }, []);

  const addHeatSource = useCallback((heatSource: Omit<HeatSource, 'id'>): string => {
    const id = physicsEngineRef.current.addHeatSource(heatSource);
    setTick(t => t + 1);
    return id;
  }, []);

  const updateHeatSource = useCallback((id: string, updates: Partial<HeatSource>) => {
    physicsEngineRef.current.updateHeatSource(id, updates);
    setTick(t => t + 1);
  }, []);

  const resetSimulation = useCallback((config?: AnimationConfig) => {
    setIsRunning(false);

    if (animationFrameIdRef.current) {
      cancelAnimationFrame(animationFrameIdRef.current);
    }

    // Reset physics engine
    physicsEngineRef.current.reset(config?.width, config?.height);

    if (config?.performanceMode) {
      performanceManagerRef.current.setPerformanceLevel(config.performanceMode);
      physicsEngineRef.current.setPerformanceMode(config.performanceMode);
    }

    if (config) {
      sceneBuilderRef.current.buildFromConfig(config);
    }

    lastTimestampRef.current = performance.now();
    setTick(t => t + 1);

    // Restart animation
    setIsRunning(true);
  }, []);

  // ===== ANIMATION CONTROL =====
  const pauseAnimation = useCallback(() => {
    setIsRunning(false);
  }, []);

  const resumeAnimation = useCallback(() => {
    lastTimestampRef.current = performance.now();
    setIsRunning(true);
  }, []);

  const toggleAnimation = useCallback(() => {
    if (isRunning) {
      pauseAnimation();
    } else {
      resumeAnimation();
    }
  }, [isRunning, pauseAnimation, resumeAnimation]);

  // ===== CONTEXT VALUE =====
  const contextValue = useMemo(() => ({
    physicsEngine: physicsEngineRef.current,
    performanceManager: performanceManagerRef.current,
    sceneBuilder: sceneBuilderRef.current,

    // State
    getPhysicsState,

    // Temperature
    setTemperature,
    getTemperatureAt,

    // Particles
    addParticle,
    removeParticle,

    // Bonds
    addBond,
    removeBond,

    // Lab equipment
    addBoundary,
    addHeatSource,
    updateHeatSource,

    // Simulation control
    resetSimulation,

    // Animation control (additional utilities)
    pauseAnimation,
    resumeAnimation,
    toggleAnimation,
    isRunning,
  }), [
    getPhysicsState,
    setTemperature,
    getTemperatureAt,
    addParticle,
    removeParticle,
    addBond,
    removeBond,
    addBoundary,
    addHeatSource,
    updateHeatSource,
    resetSimulation,
    pauseAnimation,
    resumeAnimation,
    toggleAnimation,
    isRunning
  ]);

  return (
    <UnifiedAnimationContext.Provider value={contextValue}>
      {children}
    </UnifiedAnimationContext.Provider>
  );
};

// ===== HOOKS =====

// Main hook for accessing the animation API
export const useAnimation = (): AnimationContextAPI & {
  pauseAnimation: () => void;
  resumeAnimation: () => void;
  toggleAnimation: () => void;
  isRunning: boolean;
} => {
  const context = useContext(UnifiedAnimationContext);
  if (!context) {
    throw new Error('useAnimation must be used within a UnifiedAnimationProvider');
  }
  return context as any;
};

// Alias for backward compatibility
export const useAnimationAPI = useAnimation;

// Hook for lab-specific functionality
export const useLabAnimation = () => {
  const context = useAnimation();

  return {
    // Core physics
    particles: context.getPhysicsState().particles,
    bonds: context.getPhysicsState().bonds,

    // Lab-specific
    addHeatSource: context.addHeatSource,
    updateHeatSource: context.updateHeatSource,
    addBoundary: context.addBoundary,
    getTemperatureAt: context.getTemperatureAt,
    setTemperature: context.setTemperature,

    // Particle management
    addParticle: context.addParticle,
    removeParticle: context.removeParticle,

    // Simulation control
    reset: () => context.resetSimulation(),

    // Animation control
    isRunning: context.isRunning,
    pause: context.pauseAnimation,
    resume: context.resumeAnimation,
    toggle: context.toggleAnimation,
  };
};

// Hook for molecular simulations
export const useMolecularAnimation = () => {
  const context = useAnimation();

  return {
    // Core physics
    particles: context.getPhysicsState().particles,
    bonds: context.getPhysicsState().bonds,

    // Molecular-specific
    addParticle: context.addParticle,
    removeParticle: context.removeParticle,
    addBond: context.addBond,
    removeBond: context.removeBond,
    setTemperature: context.setTemperature,

    // Scene building
    sceneBuilder: context.sceneBuilder,

    // Simulation control
    reset: (config?: AnimationConfig) => context.resetSimulation(config),

    // Animation control
    isRunning: context.isRunning,
    pause: context.pauseAnimation,
    resume: context.resumeAnimation,
    toggle: context.toggleAnimation,
  };
};

// Export types for convenience
export type {
  AnimationContextAPI,
  AnimationConfig,
  PhysicsState,
  Particle,
  Bond,
  LabBoundary,
  HeatSource
} from './core/types';

---- File Content End ----


=== File: AnimationProvider.tsx ===
Path: 2d\AnimationProvider.tsx
---- File Content Start ----
// src/data/animations/2d/AnimationProvider.tsx

import React, { createContext, useContext, useState, useEffect, useRef, useCallback, ReactNode } from 'react';
import { PhysicsEngine } from '../core/UnifiedPhysicsEngine';
import { PerformanceManager } from '../core/Performance';
import { SceneBuilder } from '../core/SceneBuilder';
import type { Particle, Bond, PhysicsState, AnimationContextAPI, AnimationConfig } from '../core/types';
import { UniqueID } from '@/utils/UniqueID';

const AnimationContext = createContext<AnimationContextAPI | undefined>(undefined);

export const AnimationProvider: React.FC<{ children: ReactNode, initialConfig?: AnimationConfig }> = ({ children, initialConfig }) => {
  const performanceManagerRef = useRef(new PerformanceManager(initialConfig?.performanceMode || 'low'));
  const physicsEngineRef = useRef(new PhysicsEngine(performanceManagerRef.current.getPerformanceSettings().level, initialConfig?.width || 300, initialConfig?.height || 300));
  const sceneBuilderRef = useRef(new SceneBuilder(physicsEngineRef.current));

  const [tick, setTick] = useState(0);
  const animationFrameIdRef = useRef<number | null>(null);
  const lastTimestampRef = useRef<number>(performance.now());
  const isRunningRef = useRef(true); // CHANGE: Use a ref to control the animation loop

  useEffect(() => {
    if (initialConfig) {
      sceneBuilderRef.current.buildFromConfig(initialConfig);
      if (initialConfig.initialTemperature !== undefined) {
        physicsEngineRef.current.setTemperature(initialConfig.initialTemperature);
      }
      setTick(t => t + 1);
    }
  }, [initialConfig]);

  useEffect(() => {
    isRunningRef.current = true;
    const engine = physicsEngineRef.current;
    const perfManager = performanceManagerRef.current;

    const animate = (currentTime: number) => {
      if (!isRunningRef.current) return;

      const deltaTime = currentTime - lastTimestampRef.current;
      const targetInterval = 1000 / perfManager.getPerformanceSettings().frameRate;

      if (deltaTime >= targetInterval * 0.9 || deltaTime > 250) {
        engine.update(Math.min(deltaTime, 250), currentTime);
        lastTimestampRef.current = currentTime;
        setTick(t => t + 1);
      }
      animationFrameIdRef.current = requestAnimationFrame(animate);
    };

    animationFrameIdRef.current = requestAnimationFrame(animate);

    return () => {
      isRunningRef.current = false;
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
    };
  }, []);

  const getPhysicsState = useCallback((): PhysicsState => {
    return physicsEngineRef.current.getState(lastTimestampRef.current);
  }, []);

  // ... (addParticle, addBond, removeParticle, removeBond callbacks remain the same) ...
  const setTemperature = useCallback((temp: number) => { physicsEngineRef.current.setTemperature(temp); setTick(t => t + 1); }, []);
  const addParticle = useCallback((particleData: Omit<Particle, 'vx' | 'vy' | 'maxSpeed' | 'vibrationIntensity' | 'color' | 'id'> & Partial<Particle>): string => { const id = particleData.id || UniqueID.generate('p_'); physicsEngineRef.current.addParticle({ ...particleData, id }); setTick(t => t + 1); return id; }, []);
  const addBond = useCallback((bondData: { p1Id: string, p2Id: string, restLength?: number, type?: Bond['type'], id?: string }) : string | null => { const id = bondData.id || UniqueID.generate('b_'); const resultId = physicsEngineRef.current.addBond({ ...bondData, id }); if (resultId) setTick(t => t + 1); return resultId; }, []);
  const removeParticle = useCallback((particleId: string) => { physicsEngineRef.current.removeParticle(particleId); setTick(t => t + 1); }, []);
  const removeBond = useCallback((bondId: string) => { physicsEngineRef.current.removeBond(bondId); setTick(t => t + 1); }, []);

  const resetSimulation = useCallback((config?: AnimationConfig) => {
    isRunningRef.current = false; // Pause the loop
    if (animationFrameIdRef.current) cancelAnimationFrame(animationFrameIdRef.current);

    physicsEngineRef.current.reset(config?.width, config?.height);
    if (config?.performanceMode) {
      performanceManagerRef.current.setPerformanceLevel(config.performanceMode);
      physicsEngineRef.current.setPerformanceMode(performanceManagerRef.current.getPerformanceSettings().level);
    }
    if (config) {
      sceneBuilderRef.current.buildFromConfig(config);
    }

    lastTimestampRef.current = performance.now();
    setTick(t => t + 1); // Render the reset state

    // Restart the loop
    isRunningRef.current = true;
    animationFrameIdRef.current = requestAnimationFrame(animate);
    function animate(currentTime: number){ /* as defined in useEffect */ } // just to satisfy linter, it will use the one from scope
  }, []);

  const contextValue: AnimationContextAPI = useMemo(() => ({
    physicsEngine: physicsEngineRef.current,
    performanceManager: performanceManagerRef.current,
    sceneBuilder: sceneBuilderRef.current, // CHANGE: Add sceneBuilder to context
    getPhysicsState,
    setTemperature,
    addParticle,
    addBond,
    removeParticle,
    removeBond,
    resetSimulation,
  }), [getPhysicsState, setTemperature, addParticle, addBond, removeParticle, removeBond, resetSimulation]);

  return (
    <AnimationContext.Provider value={contextValue}>
      {children}
    </AnimationContext.Provider>
  );
};

export const useAnimationAPI = (): AnimationContextAPI => {
  const context = useContext(AnimationContext);
  if (!context) { throw new Error('useAnimationAPI must be used within an AnimationProvider'); }
  return context;
};

export type { AnimationParticle, AnimationBond, PhysicsState, AnimationConfig } from '../core/types';

---- File Content End ----


=== File: AnimationCanvas.tsx.tsx ===
Path: components\AnimationCanvas.tsx.tsx
---- File Content Start ----
// src/data/animations/components/AnimationCanvas.tsx (renamed from Container.tsx for clarity)

import React from 'react';
import { View } from 'react-native'; // Import View for layout
import { Canvas, runTiming, useValue, Easing } from "@shopify/react-native-skia";
import { useAnimationAPI } from '../2d/AnimationProvider'; // Adjusted path
import { AnimationRenderer } from '../core/Renderer'; // Renderer instance, not a component

interface AnimationCanvasProps {
  width: number;
  height: number;
  style?: object;
  children?: React.ReactNode; // For overlaying UI elements on top of Skia canvas
}

const rendererInstance = new AnimationRenderer(); // Create one instance

export const AnimationCanvas: React.FC<AnimationCanvasProps> = ({
  width,
  height,
  style,
  children
}) => {
  const { getPhysicsState, performanceManager } = useAnimationAPI();

  // getPhysicsState() returns a new object each time, which would cause
  // the <Canvas> children to re-evaluate constantly if used directly as a dep.
  // The `tick` from AnimationProvider serves as the trigger for re-rendering the Canvas content.
  // However, Skia's <Canvas> typically redraws when its child elements change.
  // We need to ensure the elements array passed to <Canvas> is a new array on each tick.

  const physicsState = getPhysicsState(); // Get the latest state
  const perfSettings = performanceManager.getPerformanceSettings();

  // The renderer.renderFrame will produce a new array of JSX elements
  // which Skia will use to redraw.
  const skiaElements = rendererInstance.renderFrame(physicsState, perfSettings.enableParticleTrails);

  return (
    <View style={[{ width, height }, style]}>
      <Canvas style={{ flex: 1 }}>
        {/* Render Skia elements generated by the renderer */}
        {skiaElements}
      </Canvas>
      {/* Optional: Render children (React Native components) on top of the Canvas */}
      {children && (
        <View style={{ position: 'absolute', top: 0, left: 0, width, height }}>
          {children}
        </View>
      )}
    </View>
  );
};

---- File Content End ----


=== File: Bond.tsx ===
Path: components\Bond.tsx
---- File Content Start ----
// src/data/animations/components/Bond.tsx

import React, { useEffect, useLayoutEffect, useRef } from 'react';
// No direct Skia import
import { useAnimationAPI, AnimationBond } from '../2d/AnimationProvider'; // Adjusted path
import { UniqueID } from '@/utils/UniqueID';

interface BondComponentProps {
  id?: string; // Optional ID
  p1Id: string; // ID of the first particle
  p2Id: string; // ID of the second particle
  type?: AnimationBond['type'];
  restLength?: number; // Optional: if not provided, calculated from initial positions
  stiffness?: number;
  stability?: number;
  color?: string;
}

export const Bond: React.FC<BondComponentProps> = ({
  id: propId,
  p1Id,
  p2Id,
  type = 'single',
  restLength,
  stiffness,
  stability,
  color,
}) => {
  const { addBond, removeBond, getPhysicsState } = useAnimationAPI();
  const bondIdRef = useRef(propId || UniqueID.generate('b_'));

  useLayoutEffect(() => {
    const bondId = bondIdRef.current;

    let calculatedRestLength = restLength;
    // Calculate restLength if not provided, based on current particle positions
    if (calculatedRestLength === undefined) {
      const state = getPhysicsState(); // Get current state to find particles
      const particle1 = state.particles.find(p => p.id === p1Id);
      const particle2 = state.particles.find(p => p.id === p2Id);

      if (particle1 && particle2) {
        const dx = particle2.x - particle1.x;
        const dy = particle2.y - particle1.y;
        calculatedRestLength = Math.sqrt(dx * dx + dy * dy);
      } else {
        console.warn(`Bond: Could not find particles ${p1Id} or ${p2Id} to calculate rest length.`);
        // Don't add bond if particles are missing for restLength calculation
        return;
      }
    }

    if (calculatedRestLength === undefined) return; // Still undefined, something went wrong

    const bondData = {
      id: bondId,
      p1Id,
      p2Id,
      type,
      restLength: calculatedRestLength,
      stiffness,
      stability,
      color,
    };

    const addedBondId = addBond(bondData);

    return () => {
      if (addedBondId) { // Only try to remove if it was successfully added
        removeBond(addedBondId);
      }
    };
    // Add all props that define the bond to the dependency array
  }, [addBond, removeBond, getPhysicsState, p1Id, p2Id, type, restLength, stiffness, stability, color /*propId*/]);

  return null; // Logical component
};

---- File Content End ----


=== File: ConnectedAnimationCanvas.tsx ===
Path: components\ConnectedAnimationCanvas.tsx
---- File Content Start ----
// src/data/animations/components/ConnectedAnimationCanvas.tsx

import React from 'react';
import { View } from 'react-native';
import { SkiaRenderer } from '../core/SkiaRenderer';
import { useAnimation } from '../UnifiedAnimationProvider';

interface ConnectedAnimationCanvasProps {
  width: number;
  height: number;
  showTrails?: boolean;
  showHeatFields?: boolean;
  style?: object;
  children?: React.ReactNode; // SVG overlays for equipment
}

export const ConnectedAnimationCanvas: React.FC<ConnectedAnimationCanvasProps> = ({
  width,
  height,
  showTrails = false,
  showHeatFields = false,
  style,
  children
}) => {
  const {
    getPhysicsState,
    performanceManager,
    physicsEngine
  } = useAnimation();

  const physicsState = getPhysicsState();
  const performanceSettings = performanceManager.getPerformanceSettings();

  // Get heat sources from physics engine for heat field visualization
  const heatSources = physicsEngine.getHeatSources();

  return (
    <View style={[{ width, height, position: 'relative' }, style]}>
      {/* Skia Physics Layer */}
      <View style={{ position: 'absolute', top: 0, left: 0, width, height }}>
        <SkiaRenderer
          physicsState={physicsState}
          performanceSettings={performanceSettings}
          heatSources={heatSources}
          showTrails={showTrails}
          showHeatFields={showHeatFields}
          width={width}
          height={height}
        />
      </View>

      {/* SVG Equipment Overlay Layer */}
      {children && (
        <View style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width,
          height,
          pointerEvents: 'box-none' // Allow touches to pass through to equipment
        }}>
          {children}
        </View>
      )}
    </View>
  );
};

export default ConnectedAnimationCanvas;

---- File Content End ----


=== File: MolecularView.tsx ===
Path: components\MolecularView.tsx
---- File Content Start ----
// src/data/animations/components/MolecularView.tsx

import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Slider from '@react-native-community/slider'; // You might need to install this: npx expo install @react-native-community/slider
import { AnimationCanvas } from './AnimationCanvas'; // The Skia canvas
import { AnimationProvider, useAnimationAPI } from '../2d/AnimationProvider';
import type { AnimationConfig } from '../core/types';
import { useThemedStyles, useTheme } from '@/lib/ThemeContext'; // Your app's theme
import { Theme } from '@/lib/designSystem';

interface MolecularViewProps {
  moleculeType: 'water' | 'co2' | 'nacl';
  width: number;
  height: number;
  initialTemperature?: number;
}

// Inner component that consumes the animation context
const MoleculeScene: React.FC<MolecularViewProps> = ({ moleculeType, width, height, initialTemperature }) => {
  const { setTemperature } = useAnimationAPI();
  const { theme } = useTheme();

  const styles = useThemedStyles((theme: Theme) => ({
    container: {
      alignItems: 'center',
      padding: theme.spacing.md,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.borderRadius.lg,
    },
    canvasContainer: {
      width: width,
      height: height,
      backgroundColor: theme.colors.surface, // Background for the canvas area
      borderRadius: theme.borderRadius.md,
      ...theme.shadows.xs,
    },
    controlsContainer: {
      width: '100%',
      marginTop: theme.spacing.md,
    },
    sliderLabel: {
      fontSize: theme.typography.fontSize.sm,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: theme.spacing.xs,
    },
  }));

  return (
    <View style={styles.container}>
      <View style={styles.canvasContainer}>
        <AnimationCanvas width={width} height={height} />
      </View>

      <View style={styles.controlsContainer}>
        <Text style={styles.sliderLabel}>Temperature</Text>
        <Slider
          style={{ width: '100%', height: 40 }}
          minimumValue={0}
          maximumValue={100}
          step={1}
          value={initialTemperature || 25}
          minimumTrackTintColor={theme.colors.primary}
          maximumTrackTintColor={theme.colors.outlineVariant}
          thumbTintColor={theme.colors.primary}
          onValueChange={setTemperature}
        />
      </View>
    </View>
  );
};


// The exported component that wraps the scene in its own Provider
export const MolecularView: React.FC<MolecularViewProps> = (props) => {
  // Define the initial configuration for this specific animation instance
  const animationConfig: AnimationConfig = {
    type: 'molecule',
    moleculeType: props.moleculeType,
    width: props.width,
    height: props.height,
    initialTemperature: props.initialTemperature || 25,
    performanceMode: 'medium', // Molecules are not too intensive
  };

  return (
    <AnimationProvider initialConfig={animationConfig}>
      <MoleculeScene {...props} />
    </AnimationProvider>
  );
};

---- File Content End ----


=== File: Particle.tsx ===
Path: components\Particle.tsx
---- File Content Start ----
// src/data/animations/components/Particle.tsx

import React, { useEffect, useLayoutEffect } from 'react';
// No direct Skia import needed, it's a "logical" component
import { useAnimationAPI, AnimationParticle } from '../2d/AnimationProvider'; // Adjusted path
import { ColorSystem } from '../core/Colors'; // For default/element color logic

// Props for the declarative Particle component
// Most physics properties (vx, vy, maxSpeed etc.) are managed by the engine.
// We define the initial setup.
export interface ParticleComponentProps {
  id?: string; // Optional: if not provided, one will be generated
  x: number;
  y: number;
  z?: number;
  radius: number;
  mass?: number;
  boundaryWidth: number; // The boundaries this particle adheres to
  boundaryHeight: number;
  initialColor?: string; // Override default color logic
  elementType?: string; // e.g., 'H', 'O' for specific element coloring
  isFixed?: boolean;
  data?: Record<string, any>;
}

export const Particle: React.FC<ParticleComponentProps> = ({
  id: propId,
  x,
  y,
  z,
  radius,
  mass,
  boundaryWidth,
  boundaryHeight,
  initialColor,
  elementType,
  isFixed,
  data
}) => {
  const { addParticle, removeParticle } = useAnimationAPI();

  // useLayoutEffect to ensure particle is added before first paint if possible,
  // and to get a stable ID for the effect's dependency array.
  const particleIdRef = React.useRef(propId || UniqueID.generate('p_')); // Generate ID if not provided

  useLayoutEffect(() => {
    const particleId = particleIdRef.current;

    let determinedColor = initialColor;
    if (!determinedColor) {
      if (elementType) {
        determinedColor = ColorSystem.getElementColor(elementType);
      } else {
        determinedColor = RenderConfig.Particle.DefaultColor; // Fallback if no element type
      }
    }

    // Construct the particle data for the engine
    // Engine will set vx, vy, maxSpeed, vibrationIntensity etc.
    const particleData: Omit<AnimationParticle, 'vx' | 'vy' | 'maxSpeed' | 'vibrationIntensity'> & Partial<AnimationParticle> = {
      id: particleId,
      x,
      y,
      z,
      radius,
      mass: mass || radius, // Default mass proportional to radius
      color: determinedColor,
      boundaryWidth,
      boundaryHeight,
      isFixed,
      data
    };

    addParticle(particleData);

    return () => {
      removeParticle(particleId);
    };
    // Dependencies: include all props that define the particle's initial state
    // Note: If x, y, etc., are dynamic props that can change, this effect will
    // re-add/remove the particle. For dynamic updates to existing particles,
    // you'd need a different mechanism (e.g., physicsEngine.updateParticle(id, newProps)).
    // For now, this assumes initial setup.
  }, [
    addParticle, removeParticle, x, y, z, radius, mass,
    boundaryWidth, boundaryHeight, initialColor, elementType, isFixed, data
    // propId is not in deps because particleIdRef.current is used, which is stable
  ]);

  return null; // This component doesn't render anything itself
};

---- File Content End ----


=== File: StateTransition.tsx ===
Path: components\StateTransition.tsx
---- File Content Start ----

---- File Content End ----


=== File: AnimationContext.tsx ===
Path: contexts\AnimationContext.tsx
---- File Content Start ----

---- File Content End ----


=== File: Colors.ts ===
Path: core\Colors.ts
---- File Content Start ----
// src/data/animations/core/Colors.ts
import { RenderConfig } from './RenderConfig';
import type { Bond } from './types';
import { lerpColor } from '@/utils/animationUtils'; // Import the new utility

// ... (elementColors object remains the same) ...
const elementColors: Record<string, string> = { H: '#FFFFFF', He: '#DBFFD4', Li: '#CC80FF', Be: '#C2FF00', B: '#FFB5B5', C: '#909090', N: '#3050F8', O: '#FF0D0D', F: '#90E050', Ne: '#B3E3F5', Na: '#AB5CF2', Mg: '#8AFF00', Al: '#BFA6A6', Si: '#F0C8A0', P: '#FF8000', S: '#FFFF30', Cl: '#1FF01F', Ar: '#80D1F5', K: '#8F40D4', Ca: '#3DFF00', DEFAULT: '#CCCCCC' };


export class ColorSystem {
  static getElementColor(elementSymbol: string): string {
    return elementColors[elementSymbol.toUpperCase()] || elementColors.DEFAULT;
  }

  // ... (getStateColor and getBondColor remain the same) ...
  static getStateColor(state: 'solid' | 'liquid' | 'gas', temperature?: number): string {
    if (state === 'solid') return RenderConfig.TemperatureColors.Cool;
    if (state === 'liquid') return RenderConfig.TemperatureColors.Medium;
    if (state === 'gas') {
      if (temperature === undefined) return RenderConfig.TemperatureColors.Warm;
      return temperature > 75 ? RenderConfig.TemperatureColors.Hot :
             temperature > 50 ? RenderConfig.TemperatureColors.Warm :
             RenderConfig.TemperatureColors.Medium;
    }
    return elementColors.DEFAULT;
  }

  static getBondColor(type?: Bond['type']): string {
    switch (type) {
      case 'double': return '#2d3748';
      case 'triple': return '#1a202c';
      case 'hydrogen': return RenderConfig.TemperatureColors.Cool + '80';
      case 'ionic': return RenderConfig.Bond.DefaultColor + '50';
      case 'single':
      default:
        return RenderConfig.Bond.DefaultColor;
    }
  }

  static getTemperatureGradientColors(): string[] {
    return [
      RenderConfig.TemperatureColors.Cool,
      RenderConfig.TemperatureColors.Medium,
      RenderConfig.TemperatureColors.Warm,
      RenderConfig.TemperatureColors.Hot,
    ];
  }

  // CHANGE: Use the new lerpColor utility instead of depending on Skia
  static getColorFromNormalizedTemperature(value: number): string {
    const gradient = ColorSystem.getTemperatureGradientColors();
    if (value <= 0) return gradient[0];
    if (value >= 1) return gradient[gradient.length - 1];

    const scaledValue = value * (gradient.length - 1);
    const index = Math.floor(scaledValue);
    const t = scaledValue - index; // Interpolation factor

    const color1 = gradient[index];
    const color2 = gradient[index + 1];

    return lerpColor(color1, color2, t);
  }

  static getReactionIndicatorColor(type: 'exothermic' | 'endothermic'): string {
    return type === 'exothermic' ? RenderConfig.TemperatureColors.Hot : RenderConfig.TemperatureColors.Cool;
  }
}

---- File Content End ----


=== File: Performance.ts ===
Path: core\Performance.ts
---- File Content Start ----
// src/data/animations/core/Performance.ts
import type { PhysicsEngine, PerformanceSettings } from './types'; // Ensure correct import path

export class PerformanceManager {
  private currentSettings: PerformanceSettings;

  constructor(initialLevel: 'low' | 'medium' | 'high' = 'low') {
    // Initial detection is a placeholder - in a real app, this would be more sophisticated
    // or could be set based on user preference or device capabilities.
    this.currentSettings = this.getSettingsForLevel(initialLevel);
    this.detectDevicePerformance(); // Simulate detection on init
  }

  private getSettingsForLevel(level: 'low' | 'medium' | 'high'): PerformanceSettings {
    switch (level) {
      case 'high':
        return {
          level: 'high',
          frameRate: 60,
          maxParticles: 200, // Example
          physicsQuality: 'advanced',
          enableParticleTrails: true,
          enableComplexCollisions: true,
        };
      case 'medium':
        return {
          level: 'medium',
          frameRate: 45,
          maxParticles: 100,
          physicsQuality: 'standard',
          enableParticleTrails: false,
          enableComplexCollisions: true,
        };
      case 'low':
      default:
        return {
          level: 'low',
          frameRate: 30,
          maxParticles: 50,
          physicsQuality: 'basic',
          enableParticleTrails: false,
          enableComplexCollisions: false,
        };
    }
  }

  // Simulate device performance detection
  private detectDevicePerformance() {
    // Placeholder: In a real app, use libraries like react-native-device-info
    // to get device RAM, CPU cores, etc., and make an educated guess.
    // For now, we'll default to 'low' or allow it to be set externally.
    // Example:
    // const deviceInfo = getDeviceInfo();
    // if (deviceInfo.totalMemory > 4 * 1024 * 1024 * 1024 && deviceInfo.cpuCores > 4) {
    //   this.setPerformanceLevel('medium');
    // }
    console.log("PerformanceManager: Defaulting to initial or 'low' performance settings. Implement actual device detection.");
    // The constructor already sets initialLevel. This method could refine it.
  }

  getPerformanceSettings(): Readonly<PerformanceSettings> {
    return Object.freeze({ ...this.currentSettings }); // Return a copy
  }

  setPerformanceLevel(level: 'low' | 'medium' | 'high') {
    console.log(`PerformanceManager: Setting performance level to ${level}`);
    this.currentSettings = this.getSettingsForLevel(level);
    // Notify subscribers or engine if settings change dynamically during an animation
  }

  // These methods are more conceptual for now; actual optimization logic lives in PhysicsEngine/Renderer
  // based on the settings provided by this manager.
  // This manager's role is to DETERMINE the settings.
  shouldEnableComplexCollisions(): boolean {
    return this.currentSettings.enableComplexCollisions;
  }

  shouldEnableParticleTrails(): boolean {
    return this.currentSettings.enableParticleTrails;
  }

  getTargetFrameRate(): number {
    return this.currentSettings.frameRate;
  }
}

---- File Content End ----


=== File: RenderConfig.ts ===
Path: core\RenderConfig.ts
---- File Content Start ----
// src/data/animations/core/RenderConfig.ts

export const RenderConfig = {
  Bond: {
    DefaultColor: '#4a5568', // Default color for single bonds
    StrokeWidthMultiplier: 1.5, // Multiplied by bond.stability
    MinVisibleStability: 0.1,
  },
  Particle: {
    DefaultRadius: 10,
    DefaultColor: '#94a3b8', // Slate 400/500
  },
  Trail: {
    OpacityHex: '80', // Appended to color string for 50% opacity
    LengthMultiplier: 3, // Multiplied by velocity vector for trail length
    StrokeWidth: 1,
    MinSpeedThreshold: 0.5, // Only show trails for particles faster than this
  },
  TemperatureColors: { // Aligned with your theme's interactive colors
    Cool: '#4299e1',    // theme.colors.interactive.cold
    Medium: '#48bb78',  // theme.colors.interactive.medium
    Warm: '#f6ad55',    // A warm orange
    Hot: '#f56565',     // theme.colors.interactive.hot
  }
};

---- File Content End ----


=== File: Renderer.tsx ===
Path: core\Renderer.tsx
---- File Content Start ----
// src/data/animations/core/Renderer.ts
import { Skia, Canvas, Group, Path, Circle, vec, SkPath } from "@shopify/react-native-skia";
import type { PhysicsState, Particle, Bond } from "./types"; // Use 'type' import
import { RenderConfig } from "./RenderConfig";
import { ColorSystem } from "./Colors";


// --- Reusable Skia Functional Components (Friend's Suggestion) ---

interface BondLineProps {
  bond: Bond;
  // Consider passing a unique key if bonds are dynamic and rerendered
}
const BondLine: React.FC<BondLineProps> = React.memo(({ bond }) => {
  if (bond.stability < RenderConfig.Bond.MinVisibleStability) return null;

  const path = Skia.Path.Make();
  path.moveTo(bond.particle1.x, bond.particle1.y);
  path.lineTo(bond.particle2.x, bond.particle2.y);

  return (
    <Path
      path={path}
      style="stroke"
      strokeWidth={Math.max(1, RenderConfig.Bond.StrokeWidthMultiplier * bond.stability)}
      color={bond.color || ColorSystem.getBondColor(bond.type)} // Use bond's own color if defined
      antiAlias // Smooth lines
    />
  );
});

interface ParticleCircleProps {
  particle: Particle;
}
const ParticleCircle: React.FC<ParticleCircleProps> = React.memo(({ particle }) => {
  return (
    <Circle
      cx={particle.x}
      cy={particle.y}
      r={particle.radius}
      color={particle.color} // Color is now set by PhysicsEngine or SceneBuilder
      antiAlias
    />
  );
});

interface ParticleTrailProps {
    particle: Particle;
}
const ParticleTrail: React.FC<ParticleTrailProps> = React.memo(({ particle }) => {
    const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
    if (speed < RenderConfig.Trail.MinSpeedThreshold) return null;

    const path = Skia.Path.Make();
    path.moveTo(particle.x, particle.y);
    // Trail length proportional to velocity and config multiplier
    path.lineTo(
        particle.x - particle.vx * RenderConfig.Trail.LengthMultiplier,
        particle.y - particle.vy * RenderConfig.Trail.LengthMultiplier
    );

    return (
        <Path
            path={path}
            style="stroke"
            strokeWidth={RenderConfig.Trail.StrokeWidth}
            color={`${particle.color}${RenderConfig.Trail.OpacityHex}`}
            antiAlias
        />
    );
});


// Renderer for physics-based animations
export class AnimationRenderer {
  // No longer needs physics engine directly, just the state
  // private physics: PhysicsEngine;

  constructor() {
    // No setup needed if just receiving state
  }

  // Render particles and bonds based on the current physics state
  renderFrame(state: PhysicsState, showTrails: boolean): JSX.Element[] {
    const { particles, bonds } = state;
    const elements: JSX.Element[] = [];

    // Render bonds first (as they are "behind" particles)
    for (const bond of bonds) {
      elements.push(
        <BondLine key={bond.id} bond={bond} />
      );
    }

    // Render particles
    for (const particle of particles) {
      elements.push(
        <ParticleCircle key={particle.id} particle={particle} />
      );
      if (showTrails) {
        elements.push(
            <ParticleTrail key={`trail-${particle.id}`} particle={particle} />
        )
      }
    }
    return elements;
  }

  // renderTrails is now integrated into renderFrame based on a flag
}

---- File Content End ----


=== File: SceneBuilder.ts ===
Path: core\SceneBuilder.ts
---- File Content Start ----
// src/data/animations/core/SceneBuilder.ts

import { UnifiedPhysicsEngine } from './UnifiedPhysicsEngine';
import type { Particle, Bond, AnimationConfig } from './types';
import { ColorSystem } from './Colors';
import { UniqueID } from '@/utils/UniqueID';
import { RenderConfig } from './RenderConfig';

export class SceneBuilder {
  private physics: UnifiedPhysicsEngine;

  constructor(physicsEngine: UnifiedPhysicsEngine) {
    this.physics = physicsEngine;
  }

  // ===== SCENE MANAGEMENT =====
  public clearScene(): void {
    this.physics.reset();
  }

  // ===== MOLECULAR STRUCTURES =====
  public createWaterMolecule(
    baseId: string,
    x: number,
    y: number,
    scale: number = 1,
    boundaryWidth?: number,
    boundaryHeight?: number
  ): { oxygenId: string; hydrogen1Id: string; hydrogen2Id: string } {

    // Create oxygen atom
    const oxygenId = this.physics.addParticle({
      id: `${baseId}_O`,
      x,
      y,
      radius: 12 * scale,
      mass: 16,
      color: ColorSystem.getElementColor('O'),
      data: { elementType: 'O' },
    });

    // Create hydrogen atoms
    const hydrogen1Id = this.physics.addParticle({
      id: `${baseId}_H1`,
      x: x - 20 * scale,
      y: y + 15 * scale,
      radius: 8 * scale,
      mass: 1,
      color: ColorSystem.getElementColor('H'),
      data: { elementType: 'H' },
    });

    const hydrogen2Id = this.physics.addParticle({
      id: `${baseId}_H2`,
      x: x + 20 * scale,
      y: y + 15 * scale,
      radius: 8 * scale,
      mass: 1,
      color: ColorSystem.getElementColor('H'),
      data: { elementType: 'H' },
    });

    // Create bonds
    this.physics.addBond({
      p1Id: oxygenId,
      p2Id: hydrogen1Id,
      type: 'single',
      restLength: 22 * scale,
      stiffness: 0.8
    });

    this.physics.addBond({
      p1Id: oxygenId,
      p2Id: hydrogen2Id,
      type: 'single',
      restLength: 22 * scale,
      stiffness: 0.8
    });

    return { oxygenId, hydrogen1Id, hydrogen2Id };
  }

  public createCO2Molecule(
    baseId: string,
    x: number,
    y: number,
    scale: number = 1
  ): { cId: string; o1Id: string; o2Id: string } {

    const cId = this.physics.addParticle({
      id: `${baseId}_C`,
      x,
      y,
      radius: 12 * scale,
      mass: 12,
      color: ColorSystem.getElementColor('C'),
      data: { elementType: 'C' },
    });

    const o1Id = this.physics.addParticle({
      id: `${baseId}_O1`,
      x: x - 25 * scale,
      y,
      radius: 11 * scale,
      mass: 16,
      color: ColorSystem.getElementColor('O'),
      data: { elementType: 'O' },
    });

    const o2Id = this.physics.addParticle({
      id: `${baseId}_O2`,
      x: x + 25 * scale,
      y,
      radius: 11 * scale,
      mass: 16,
      color: ColorSystem.getElementColor('O'),
      data: { elementType: 'O' },
    });

    // Double bonds
    this.physics.addBond({
      p1Id: cId,
      p2Id: o1Id,
      type: 'double',
      restLength: 25 * scale,
      stiffness: 0.9
    });

    this.physics.addBond({
      p1Id: cId,
      p2Id: o2Id,
      type: 'double',
      restLength: 25 * scale,
      stiffness: 0.9
    });

    return { cId, o1Id, o2Id };
  }

  public createNaClUnit(
    baseId: string,
    x: number,
    y: number,
    scale: number = 1
  ): { naId: string; clId: string } {

    const naId = this.physics.addParticle({
      id: `${baseId}_Na`,
      x,
      y,
      radius: 15 * scale,
      mass: 23,
      color: ColorSystem.getElementColor('Na'),
      data: { elementType: 'Na' },
    });

    const clId = this.physics.addParticle({
      id: `${baseId}_Cl`,
      x: x + 35 * scale,
      y,
      radius: 18 * scale,
      mass: 35.5,
      color: ColorSystem.getElementColor('Cl'),
      data: { elementType: 'Cl' },
    });

    // Ionic bond
    this.physics.addBond({
      p1Id: naId,
      p2Id: clId,
      type: 'ionic',
      restLength: 35 * scale,
      stability: 0.9,
      stiffness: 0.6
    });

    return { naId, clId };
  }

  // ===== STATES OF MATTER =====
  public createStatesOfMatter(
    count: number,
    state: 'solid' | 'liquid' | 'gas',
    width: number,
    height: number,
    elementSymbol: string = 'Ar'
  ): string[] {
    const particleIds: string[] = [];
    const baseRadius = state === 'gas' ? 6 : (state === 'liquid' ? 8 : 10);
    const particleColor = ColorSystem.getElementColor(elementSymbol);

    for (let i = 0; i < count; i++) {
      const particleId = this.physics.addParticle({
        id: UniqueID.generate(`${state}_particle_`),
        x: Math.random() * (width - baseRadius * 2) + baseRadius,
        y: Math.random() * (height - baseRadius * 2) + baseRadius,
        radius: baseRadius + (Math.random() - 0.5) * 2,
        mass: baseRadius,
        color: particleColor,
        data: { elementType: elementSymbol, initialState: state },
      });

      particleIds.push(particleId);
    }

    // For solid state, arrange in lattice and add bonds
    if (state === 'solid' && count > 1) {
      this.arrangeSolidLattice(particleIds, width, height, baseRadius);
    }

    return particleIds;
  }

  private arrangeSolidLattice(particleIds: string[], width: number, height: number, baseRadius: number): void {
    const cols = Math.ceil(Math.sqrt(particleIds.length));
    const rows = Math.ceil(particleIds.length / cols);
    const spacingX = (width - 2 * baseRadius) / Math.max(1, cols - 1);
    const spacingY = (height - 2 * baseRadius) / Math.max(1, rows - 1);

    particleIds.forEach((id, i) => {
      const particle = this.physics.getParticles().find(p => p.id === id);
      if (!particle) return;

      const row = Math.floor(i / cols);
      const col = i % cols;

      particle.x = baseRadius + col * spacingX;
      particle.y = baseRadius + row * spacingY;
      particle.isFixed = false; // Solids vibrate but aren't fixed

      // Add bonds to neighbors
      if (col < cols - 1 && i + 1 < particleIds.length) {
        this.physics.addBond({
          p1Id: particleIds[i],
          p2Id: particleIds[i + 1],
          type: 'single',
          restLength: spacingX * 0.8,
          stiffness: 0.7
        });
      }

      if (row < rows - 1 && i + cols < particleIds.length) {
        this.physics.addBond({
          p1Id: particleIds[i],
          p2Id: particleIds[i + cols],
          type: 'single',
          restLength: spacingY * 0.8,
          stiffness: 0.7
        });
      }
    });
  }

  // ===== LAB EXPERIMENTS =====
  public createLabContainer(
    x: number,
    y: number,
    width: number,
    height: number,
    containerType: 'beaker' | 'flask' | 'test-tube' = 'beaker'
  ): string {
    return this.physics.addBoundary({
      type: 'container',
      shape: 'rectangle',
      x: x + 8,
      y: y + height * 0.3,
      width: width - 16,
      height: height * 0.6,
      restitution: 0.3,
      friction: 0.1,
    });
  }

  public createLabParticles(
    count: number,
    containerX: number,
    containerY: number,
    containerWidth: number,
    containerHeight: number,
    liquidType: 'water' | 'acid' | 'base' = 'water'
  ): string[] {
    const colors = {
      water: '#4A90E2',
      acid: '#FFE135',
      base: '#4ECDC4'
    };

    const particleIds: string[] = [];
    const color = colors[liquidType];

    for (let i = 0; i < count; i++) {
      const particleId = this.physics.addParticle({
        x: containerX + 15 + Math.random() * (containerWidth - 30),
        y: containerY + containerHeight * 0.4 + Math.random() * (containerHeight * 0.4),
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        radius: 2 + Math.random() * 2,
        mass: 1,
        color,
        maxSpeed: 1,
        vibrationIntensity: 0.1,
        temperature: 25,
        data: { liquidType, elementType: liquidType === 'water' ? 'H2O' : liquidType }
      });

      particleIds.push(particleId);
    }

    return particleIds;
  }

  public createHeatingSource(
    x: number,
    y: number,
    radius: number = 60,
    temperature: number = 75
  ): string {
    return this.physics.addHeatSource({
      x,
      y,
      radius,
      intensity: 0,
      temperature,
      isActive: false
    });
  }

  // ===== SCENE BUILDING FROM CONFIG =====
  public buildFromConfig(config: AnimationConfig): void {
    this.clearScene();

    try {
      switch (config.type) {
        case 'molecule':
          this.buildMolecularScene(config);
          break;
        case 'states':
          this.buildStatesScene(config);
          break;
        case 'lab':
          this.buildLabScene(config);
          break;
        case 'reaction':
          this.buildReactionScene(config);
          break;
        default:
          console.warn(`Unknown animation type: ${config.type}`);
      }

      // Apply global settings
      if (config.initialTemperature !== undefined) {
        this.physics.setTemperature(config.initialTemperature);
      }

      if (config.performanceMode) {
        this.physics.setPerformanceMode(config.performanceMode);
      }
    } catch (error) {
      console.error('Failed to build scene from config:', error);
    }
  }

  private buildMolecularScene(config: AnimationConfig): void {
    const { width, height, moleculeType } = config;
    const centerX = width / 2;
    const centerY = height / 2;

    switch (moleculeType) {
      case 'water':
        this.createWaterMolecule('water_main', centerX, centerY, 1, width, height);
        break;
      case 'co2':
        this.createCO2Molecule('co2_main', centerX, centerY, 1);
        break;
      case 'nacl':
        this.createNaClUnit('nacl_main', centerX, centerY, 1);
        break;
      default:
        // Create a generic molecule
        this.createWaterMolecule('generic_mol', centerX, centerY, 1, width, height);
    }
  }

  private buildStatesScene(config: AnimationConfig): void {
    const { width, height, stateType, particleCount = 30 } = config;

    if (stateType) {
      this.createStatesOfMatter(particleCount, stateType, width, height);
    }
  }

  private buildLabScene(config: AnimationConfig): void {
    const { width, height, experimentType } = config;

    switch (experimentType) {
      case 'heating':
        this.buildHeatingExperiment(width, height);
        break;
      case 'mixing':
        this.buildMixingExperiment(width, height);
        break;
      case 'titration':
        this.buildTitrationExperiment(width, height);
        break;
      default:
        this.buildBasicLabSetup(width, height);
    }
  }

  private buildReactionScene(config: AnimationConfig): void {
    const { width, height } = config;

    // Example: H2 + Cl2 -> 2HCl reaction
    const h2Id = this.createH2Molecule('h2_1', width * 0.3, height * 0.5);
    const cl2Id = this.createCl2Molecule('cl2_1', width * 0.7, height * 0.5);

    // Set initial velocities for collision
    const h2Particles = this.physics.getParticles().filter(p => p.id.startsWith('h2_1'));
    const cl2Particles = this.physics.getParticles().filter(p => p.id.startsWith('cl2_1'));

    h2Particles.forEach(p => p.vx = 0.5);
    cl2Particles.forEach(p => p.vx = -0.5);
  }

  // ===== LAB EXPERIMENT BUILDERS =====
  private buildHeatingExperiment(width: number, height: number): void {
    // Create beaker container
    this.createLabContainer(width * 0.3, height * 0.3, width * 0.4, height * 0.5, 'beaker');

    // Add water particles
    this.createLabParticles(
      20,
      width * 0.3,
      height * 0.3,
      width * 0.4,
      height * 0.5,
      'water'
    );

    // Add heat source (Bunsen burner position)
    this.createHeatingSource(width * 0.5, height * 0.85, 60, 80);
  }

  private buildMixingExperiment(width: number, height: number): void {
    // Create container
    this.createLabContainer(width * 0.25, height * 0.2, width * 0.5, height * 0.6, 'beaker');

    // Add different liquid types
    this.createLabParticles(15, width * 0.25, height * 0.2, width * 0.25, height * 0.6, 'water');
    this.createLabParticles(15, width * 0.5, height * 0.2, width * 0.25, height * 0.6, 'acid');
  }

  private buildTitrationExperiment(width: number, height: number): void {
    // Main beaker
    this.createLabContainer(width * 0.3, height * 0.4, width * 0.4, height * 0.4, 'beaker');
    this.createLabParticles(25, width * 0.3, height * 0.4, width * 0.4, height * 0.4, 'acid');

    // Burette simulation (particles fall from top)
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        this.physics.addParticle({
          x: width * 0.5 + (Math.random() - 0.5) * 10,
          y: height * 0.1,
          vx: 0,
          vy: 1,
          radius: 2,
          mass: 1,
          color: '#4ECDC4', // Base color
          data: { liquidType: 'base' }
        });
      }, i * 1000);
    }
  }

  private buildBasicLabSetup(width: number, height: number): void {
    // Simple setup with container and particles
    this.createLabContainer(width * 0.3, height * 0.3, width * 0.4, height * 0.5);
    this.createLabParticles(15, width * 0.3, width * 0.3, width * 0.4, height * 0.5);
  }

  // ===== HELPER MOLECULE CREATORS =====
  private createH2Molecule(baseId: string, x: number, y: number): { h1Id: string; h2Id: string } {
    const h1Id = this.physics.addParticle({
      id: `${baseId}_H1`,
      x: x - 10,
      y,
      radius: 8,
      mass: 1,
      color: ColorSystem.getElementColor('H'),
      data: { elementType: 'H' }
    });

    const h2Id = this.physics.addParticle({
      id: `${baseId}_H2`,
      x: x + 10,
      y,
      radius: 8,
      mass: 1,
      color: ColorSystem.getElementColor('H'),
      data: { elementType: 'H' }
    });

    this.physics.addBond({
      p1Id: h1Id,
      p2Id: h2Id,
      type: 'single',
      restLength: 20,
      stiffness: 0.8
    });

    return { h1Id, h2Id };
  }

  private createCl2Molecule(baseId: string, x: number, y: number): { cl1Id: string; cl2Id: string } {
    const cl1Id = this.physics.addParticle({
      id: `${baseId}_Cl1`,
      x: x - 15,
      y,
      radius: 12,
      mass: 35.5,
      color: ColorSystem.getElementColor('Cl'),
      data: { elementType: 'Cl' }
    });

    const cl2Id = this.physics.addParticle({
      id: `${baseId}_Cl2`,
      x: x + 15,
      y,
      radius: 12,
      mass: 35.5,
      color: ColorSystem.getElementColor('Cl'),
      data: { elementType: 'Cl' }
    });

    this.physics.addBond({
      p1Id: cl1Id,
      p2Id: cl2Id,
      type: 'single',
      restLength: 30,
      stiffness: 0.8
    });

    return { cl1Id, cl2Id };
  }

  // ===== UTILITY METHODS =====
  public createCustomMolecule(
    atoms: Array<{ element: string; x: number; y: number; radius?: number }>,
    bonds: Array<{ atom1Index: number; atom2Index: number; type?: Bond['type'] }>,
    baseId: string = 'custom'
  ): string[] {
    const atomIds: string[] = [];

    // Create atoms
    atoms.forEach((atom, index) => {
      const atomId = this.physics.addParticle({
        id: `${baseId}_${atom.element}_${index}`,
        x: atom.x,
        y: atom.y,
        radius: atom.radius || 10,
        mass: atom.radius || 10,
        color: ColorSystem.getElementColor(atom.element),
        data: { elementType: atom.element }
      });
      atomIds.push(atomId);
    });

    // Create bonds
    bonds.forEach(bond => {
      if (bond.atom1Index < atomIds.length && bond.atom2Index < atomIds.length) {
        this.physics.addBond({
          p1Id: atomIds[bond.atom1Index],
          p2Id: atomIds[bond.atom2Index],
          type: bond.type || 'single',
          stiffness: 0.7
        });
      }
    });

    return atomIds;
  }

  public getSceneStats(): {
    particleCount: number;
    bondCount: number;
    heatSourceCount: number;
    boundaryCount: number;
  } {
    return {
      particleCount: this.physics.getParticles().length,
      bondCount: this.physics.getBonds().length,
      heatSourceCount: this.physics.getHeatSources().length,
      boundaryCount: this.physics.getBoundaries().length,
    };
  }
}

---- File Content End ----


=== File: SkiaRenderer.tsx ===
Path: core\SkiaRenderer.tsx
---- File Content Start ----
// src/data/animations/core/SkiaRenderer.tsx

import React from 'react';
import { Canvas, Group, Circle, Path, Skia, vec } from "@shopify/react-native-skia";
import type { PhysicsState, Particle, Bond, PerformanceSettings } from "./types";
import { RenderConfig } from "./RenderConfig";
import { ColorSystem } from "./Colors";

// ===== PARTICLE COMPONENT =====
interface SkiaParticleProps {
  particle: Particle;
}

const SkiaParticle: React.FC<SkiaParticleProps> = React.memo(({ particle }) => {
  return (
    <Circle
      cx={particle.x}
      cy={particle.y}
      r={particle.radius}
      color={particle.color}
      opacity={0.9}
    />
  );
});

// ===== BOND COMPONENT =====
interface SkiaBondProps {
  bond: Bond;
}

const SkiaBond: React.FC<SkiaBondProps> = React.memo(({ bond }) => {
  if (bond.stability < RenderConfig.Bond.MinVisibleStability) return null;

  const path = Skia.Path.Make();
  path.moveTo(bond.particle1.x, bond.particle1.y);
  path.lineTo(bond.particle2.x, bond.particle2.y);

  const strokeWidth = Math.max(1, RenderConfig.Bond.StrokeWidthMultiplier * bond.stability);

  return (
    <Path
      path={path}
      style="stroke"
      strokeWidth={strokeWidth}
      color={bond.color || ColorSystem.getBondColor(bond.type)}
      strokeCap="round"
    />
  );
});

// ===== PARTICLE TRAIL COMPONENT =====
interface SkiaParticleTrailProps {
  particle: Particle;
}

const SkiaParticleTrail: React.FC<SkiaParticleTrailProps> = React.memo(({ particle }) => {
  const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
  if (speed < RenderConfig.Trail.MinSpeedThreshold) return null;

  const path = Skia.Path.Make();
  path.moveTo(particle.x, particle.y);

  // Trail length proportional to velocity
  const trailLength = speed * RenderConfig.Trail.LengthMultiplier;
  const trailEndX = particle.x - (particle.vx / speed) * trailLength;
  const trailEndY = particle.y - (particle.vy / speed) * trailLength;

  path.lineTo(trailEndX, trailEndY);

  // Create gradient effect using opacity
  const trailColor = particle.color + RenderConfig.Trail.OpacityHex;

  return (
    <Path
      path={path}
      style="stroke"
      strokeWidth={RenderConfig.Trail.StrokeWidth}
      color={trailColor}
      strokeCap="round"
    />
  );
});

// ===== HEAT FIELD COMPONENT =====
interface SkiaHeatFieldProps {
  x: number;
  y: number;
  radius: number;
  intensity: number;
  temperature: number;
}

const SkiaHeatField: React.FC<SkiaHeatFieldProps> = React.memo(({
  x,
  y,
  radius,
  intensity,
  temperature
}) => {
  const color = ColorSystem.getColorFromNormalizedTemperature(temperature / 100);
  const opacity = Math.min(0.3, intensity * 0.4);

  return (
    <Circle
      cx={x}
      cy={y}
      r={radius}
      color={color}
      opacity={opacity}
    />
  );
});

// ===== MAIN SKIA RENDERER =====
interface SkiaRendererProps {
  physicsState: PhysicsState;
  performanceSettings: PerformanceSettings;
  heatSources?: Array<{
    id: string;
    x: number;
    y: number;
    radius: number;
    intensity: number;
    temperature: number;
    isActive: boolean;
  }>;
  showTrails?: boolean;
  showHeatFields?: boolean;
  width: number;
  height: number;
}

export const SkiaRenderer: React.FC<SkiaRendererProps> = ({
  physicsState,
  performanceSettings,
  heatSources = [],
  showTrails = false,
  showHeatFields = false,
  width,
  height
}) => {
  const { particles, bonds } = physicsState;

  // Filter active heat sources
  const activeHeatSources = heatSources.filter(source => source.isActive);

  // Performance optimizations
  const shouldShowTrails = showTrails && performanceSettings.enableParticleTrails;
  const maxParticles = performanceSettings.maxParticles;
  const visibleParticles = particles.slice(0, maxParticles);

  return (
    <Canvas style={{ width, height }}>
      <Group>
        {/* Heat fields (render first, behind everything) */}
        {showHeatFields && activeHeatSources.map(source => (
          <SkiaHeatField
            key={`heat-${source.id}`}
            x={source.x}
            y={source.y}
            radius={source.radius}
            intensity={source.intensity}
            temperature={source.temperature}
          />
        ))}

        {/* Particle trails (render before particles) */}
        {shouldShowTrails && visibleParticles.map(particle => (
          <SkiaParticleTrail
            key={`trail-${particle.id}`}
            particle={particle}
          />
        ))}

        {/* Bonds (render before particles so particles appear on top) */}
        {bonds.map(bond => (
          <SkiaBond
            key={bond.id}
            bond={bond}
          />
        ))}

        {/* Particles (render on top) */}
        {visibleParticles.map(particle => (
          <SkiaParticle
            key={particle.id}
            particle={particle}
          />
        ))}
      </Group>
    </Canvas>
  );
};

// ===== ANIMATION CANVAS COMPONENT =====
interface AnimationCanvasProps {
  width: number;
  height: number;
  showTrails?: boolean;
  showHeatFields?: boolean;
  style?: object;
  children?: React.ReactNode; // For SVG overlays
}

export const AnimationCanvas: React.FC<AnimationCanvasProps> = ({
  width,
  height,
  showTrails = false,
  showHeatFields = false,
  style,
  children
}) => {
  // This will be connected to the UnifiedAnimationProvider
  // For now, return a placeholder that shows the structure

  return (
    <div style={[{ width, height, position: 'relative' }, style]}>
      {/* Skia Canvas Layer */}
      <div style={{ position: 'absolute', top: 0, left: 0, width, height }}>
        {/* SkiaRenderer will be rendered here when connected to provider */}
        <div style={{
          width,
          height,
          backgroundColor: 'rgba(240, 248, 255, 0.1)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: 8,
          border: '1px dashed #ccc'
        }}>
          <span style={{ color: '#666', fontSize: 12 }}>
            Skia Physics Canvas ({width}×{height})
          </span>
        </div>
      </div>

      {/* SVG Overlay Layer */}
      {children && (
        <div style={{ position: 'absolute', top: 0, left: 0, width, height, pointerEvents: 'none' }}>
          {children}
        </div>
      )}
    </div>
  );
};

// ===== CONNECTED CANVAS COMPONENT =====
// This will be created separately to connect with the provider
export const ConnectedAnimationCanvas: React.FC<AnimationCanvasProps> = (props) => {
  // This component will use useAnimation() hook to get physics state
  // and render the SkiaRenderer with live data

  return (
    <AnimationCanvas {...props}>
      {/* Connected SkiaRenderer will be rendered here */}
    </AnimationCanvas>
  );
};

// ===== UTILITY FUNCTIONS =====

/**
 * Creates a Skia path for complex molecular bonds
 */
export const createBondPath = (
  p1: { x: number; y: number },
  p2: { x: number; y: number },
  bondType: Bond['type'] = 'single'
): ReturnType<typeof Skia.Path.Make> => {
  const path = Skia.Path.Make();

  switch (bondType) {
    case 'single':
      path.moveTo(p1.x, p1.y);
      path.lineTo(p2.x, p2.y);
      break;

    case 'double':
      // Create two parallel lines
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const offsetX = (-dy / length) * 2; // Perpendicular offset
      const offsetY = (dx / length) * 2;

      // First line
      path.moveTo(p1.x + offsetX, p1.y + offsetY);
      path.lineTo(p2.x + offsetX, p2.y + offsetY);

      // Second line
      path.moveTo(p1.x - offsetX, p1.y - offsetY);
      path.lineTo(p2.x - offsetX, p2.y - offsetY);
      break;

    case 'triple':
      // Create three parallel lines
      const dx3 = p2.x - p1.x;
      const dy3 = p2.y - p1.y;
      const length3 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
      const offsetX3 = (-dy3 / length3) * 3;
      const offsetY3 = (dx3 / length3) * 3;

      // Center line
      path.moveTo(p1.x, p1.y);
      path.lineTo(p2.x, p2.y);

      // Side lines
      path.moveTo(p1.x + offsetX3, p1.y + offsetY3);
      path.lineTo(p2.x + offsetX3, p2.y + offsetY3);
      path.moveTo(p1.x - offsetX3, p1.y - offsetY3);
      path.lineTo(p2.x - offsetX3, p2.y - offsetY3);
      break;

    default:
      path.moveTo(p1.x, p1.y);
      path.lineTo(p2.x, p2.y);
  }

  return path;
};

/**
 * Performance monitoring for Skia rendering
 */
export const useSkiaPerformance = () => {
  const [fps, setFps] = React.useState(60);
  const frameCountRef = React.useRef(0);
  const lastTimeRef = React.useRef(performance.now());

  React.useEffect(() => {
    const updateFPS = () => {
      frameCountRef.current++;
      const now = performance.now();
      const elapsed = now - lastTimeRef.current;

      if (elapsed >= 1000) {
        setFps(Math.round((frameCountRef.current * 1000) / elapsed));
        frameCountRef.current = 0;
        lastTimeRef.current = now;
      }

      requestAnimationFrame(updateFPS);
    };

    requestAnimationFrame(updateFPS);
  }, []);

  return { fps };
};

---- File Content End ----


=== File: types.ts ===
Path: core\types.ts
---- File Content Start ----
// src/data/animations/core/types.ts

// ... (Particle, Bond, PhysicsState, AnimationConfig, PerformanceSettings interfaces remain the same) ...
export interface Particle { id: string; x: number; y: number; z?: number; vx: number; vy: number; radius: number; mass?: number; color: string; maxSpeed: number; vibrationIntensity: number; vibrationFrequency?: number; boundaryWidth: number; boundaryHeight: number; isFixed?: boolean; data?: Record<string, any>; }
export interface Bond { id: string; particle1: Particle; particle2: Particle; restLength: number; stability: number; stiffness?: number; color?: string; type?: 'single' | 'double' | 'triple' | 'hydrogen' | 'ionic'; }
export interface PhysicsState { particles: ReadonlyArray<Particle>; bonds: ReadonlyArray<Bond>; timestamp: number; }
export interface AnimationConfig { type: 'states' | 'molecule' | 'reaction' | 'custom'; width: number; height: number; particleCount?: number; moleculeType?: string; stateType?: 'solid' | 'liquid' | 'gas'; initialTemperature?: number; performanceMode?: 'low' | 'medium' | 'high'; }
export interface PerformanceSettings { level: 'low' | 'medium' | 'high'; frameRate: number; maxParticles: number; physicsQuality: 'basic' | 'standard' | 'advanced'; enableShadows?: boolean; enableParticleTrails: boolean; enableComplexCollisions: boolean; }

// Forward declare for context API
export class PhysicsEngine {}
export class PerformanceManager {}
export class SceneBuilder {} // Add SceneBuilder forward declaration

// Animation context
export interface AnimationContextAPI {
  physicsEngine: PhysicsEngine;
  performanceManager: PerformanceManager;
  sceneBuilder: SceneBuilder; // CHANGE: Add sceneBuilder instance to the API
  getPhysicsState: () => PhysicsState;
  setTemperature: (temp: number) => void;
  addParticle: (particleData: Omit<Particle, 'vx' | 'vy' | 'maxSpeed' | 'vibrationIntensity' | 'color'> & Partial<Particle>) => string;
  addBond: (bondData: { p1Id: string, p2Id: string, restLength?: number, type?: Bond['type'] }) => string | null;
  removeParticle: (particleId: string) => void;
  removeBond: (bondId: string) => void;
  resetSimulation: (config?: AnimationConfig) => void;
}

// ===== SKIA RENDERING TYPES =====
export interface SkiaRenderElements {
  particles: JSX.Element[];
  bonds: JSX.Element[];
  effects: JSX.Element[];
  heatFields: JSX.Element[];
}

// ===== EQUIPMENT INTERACTION TYPES =====
export interface EquipmentInteraction {
  type: 'heating' | 'stirring' | 'pouring' | 'measuring';
  targetId: string;
  value: number;
  duration?: number;
}

export interface LabExperimentState {
  isRunning: boolean;
  currentStep: number;
  totalSteps: number;
  measurements: Record<string, number>;
  observations: string[];
}

// ===== ANIMATION ALIASES FOR COMPATIBILITY =====
export type AnimationParticle = Particle;
export type AnimationBond = Bond;

---- File Content End ----


=== File: UnifiedPhysicsEngine.ts ===
Path: core\UnifiedPhysicsEngine.ts
---- File Content Start ----
// src/data/animations/core/UnifiedPhysicsEngine.ts

import type {
  Particle,
  Bond,
  PhysicsState,
  LabBoundary,
  HeatSource
} from './types';
import { RenderConfig } from './RenderConfig';
import { ColorSystem } from './Colors';
import { UniqueID } from '@/utils/UniqueID';

export class UnifiedPhysicsEngine {
  private particles: Map<string, Particle> = new Map();
  private bonds: Map<string, Bond> = new Map();
  private boundaries: Map<string, LabBoundary> = new Map();
  private heatSources: Map<string, HeatSource> = new Map();

  private width: number;
  private height: number;
  private globalTemperature: number = 25;
  private performanceMode: 'low' | 'medium' | 'high' = 'low';
  private lastTimestamp: number = 0;

  constructor(width: number, height: number, performanceMode: 'low' | 'medium' | 'high' = 'low') {
    this.width = width;
    this.height = height;
    this.performanceMode = performanceMode;
    this.lastTimestamp = performance.now();
  }

  // ===== PARTICLE MANAGEMENT =====
  addParticle(particleData: Omit<Particle, 'id'> & { id?: string }): string {
    const id = particleData.id || UniqueID.generate('p_');

    const particle: Particle = {
      vx: 0,
      vy: 0,
      maxSpeed: 1,
      vibrationIntensity: 0.1,
      vibrationFrequency: 200 + Math.random() * 50,
      color: particleData.color || RenderConfig.Particle.DefaultColor,
      mass: particleData.mass || particleData.radius || RenderConfig.Particle.DefaultRadius,
      boundaryWidth: this.width,
      boundaryHeight: this.height,
      temperature: this.globalTemperature,
      ...particleData,
      id,
    };

    this.particles.set(id, particle);
    this.updateParticleBehavior(particle);
    return id;
  }

  removeParticle(particleId: string): void {
    this.particles.delete(particleId);
    // Remove connected bonds
    const bondsToRemove: string[] = [];
    this.bonds.forEach(bond => {
      if (bond.particle1.id === particleId || bond.particle2.id === particleId) {
        bondsToRemove.push(bond.id);
      }
    });
    bondsToRemove.forEach(bondId => this.bonds.delete(bondId));
  }

  // ===== BOND MANAGEMENT =====
  addBond(bondData: {
    p1Id: string;
    p2Id: string;
    restLength?: number;
    type?: Bond['type'];
    stiffness?: number;
    stability?: number;
    id?: string;
  }): string | null {
    const p1 = this.particles.get(bondData.p1Id);
    const p2 = this.particles.get(bondData.p2Id);

    if (!p1 || !p2) {
      console.warn("Cannot create bond: particles not found.", bondData.p1Id, bondData.p2Id);
      return null;
    }

    const id = bondData.id || UniqueID.generate('b_');
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    const bond: Bond = {
      id,
      particle1: p1,
      particle2: p2,
      restLength: bondData.restLength ?? Math.sqrt(dx * dx + dy * dy),
      stability: bondData.stability ?? 1.0,
      stiffness: bondData.stiffness ?? 0.5,
      type: bondData.type ?? 'single',
      color: ColorSystem.getBondColor(bondData.type),
    };

    this.bonds.set(id, bond);
    return id;
  }

  removeBond(bondId: string): void {
    this.bonds.delete(bondId);
  }

  // ===== LAB EQUIPMENT MANAGEMENT =====
  addBoundary(boundary: Omit<LabBoundary, 'id'>): string {
    const id = UniqueID.generate('boundary_');
    this.boundaries.set(id, { ...boundary, id });
    return id;
  }

  addHeatSource(heatSource: Omit<HeatSource, 'id'>): string {
    const id = UniqueID.generate('heat_');
    this.heatSources.set(id, { ...heatSource, id });
    return id;
  }

  updateHeatSource(id: string, updates: Partial<HeatSource>): void {
    const heatSource = this.heatSources.get(id);
    if (heatSource) {
      Object.assign(heatSource, updates);
    }
  }

  // ===== SIMULATION CONTROL =====
  setTemperature(temp: number): void {
    this.globalTemperature = Math.max(0, Math.min(100, temp));
    this.particles.forEach(p => this.updateParticleBehavior(p));
    this.bonds.forEach(b => this.updateBondBehavior(b));
  }

  get temperature(): number {
    return this.globalTemperature;
  }

  setPerformanceMode(mode: 'low' | 'medium' | 'high'): void {
    this.performanceMode = mode;
  }

  reset(newWidth?: number, newHeight?: number): void {
    this.particles.clear();
    this.bonds.clear();
    this.boundaries.clear();
    this.heatSources.clear();
    this.globalTemperature = 25;
    if (newWidth) this.width = newWidth;
    if (newHeight) this.height = newHeight;
    this.lastTimestamp = performance.now();
  }

  // ===== PHYSICS UPDATE =====
  update(deltaTimeMs: number, currentTimeMs: number): void {
    if (deltaTimeMs <= 0) return;

    const timeStep = Math.min(deltaTimeMs / 1000, 0.033);
    this.lastTimestamp = currentTimeMs;

    // Apply lab heat effects first
    this.applyLabHeatEffects();

    // Update particles
    const particles = Array.from(this.particles.values());

    for (const particle of particles) {
      if (particle.isFixed) continue;
      this.applyTemperatureEffects(particle, timeStep, currentTimeMs);
    }

    // Apply bond constraints
    const iterations = this.performanceMode === 'low' ? 1 : 2;
    for (let i = 0; i < iterations; i++) {
      this.bonds.forEach(bond => this.applyBondConstraint(bond, timeStep));
    }

    // Update positions and apply constraints
    for (const particle of particles) {
      if (particle.isFixed) continue;
      this.applyFriction(particle);
      this.updatePosition(particle, timeStep);
      this.applyBoundaryConstraints(particle);
      this.applyLabBoundaryConstraints(particle);
    }

    // Collision detection for better performance modes
    if (this.performanceMode !== 'low') {
      this.detectCollisions(particles);
    }
  }

  // ===== PHYSICS HELPERS =====
  private updateParticleBehavior(particle: Particle): void {
    const intensity = this.globalTemperature / 100;

    particle.maxSpeed = 0.2 + intensity * (this.performanceMode === 'low' ? 1.5 : 2.5);
    particle.vibrationIntensity = (0.05 + intensity * 0.5) * (1 - intensity) * particle.radius * 0.1;

    // Update color based on temperature
    if (this.globalTemperature < 33) particle.color = RenderConfig.TemperatureColors.Cool;
    else if (this.globalTemperature < 66) particle.color = RenderConfig.TemperatureColors.Medium;
    else particle.color = RenderConfig.TemperatureColors.Hot;

    // Apply element color if available
    if (particle.data?.elementType) {
      particle.color = ColorSystem.getElementColor(particle.data.elementType);
    }
  }

  private updateBondBehavior(bond: Bond): void {
    const intensity = this.globalTemperature / 100;
    bond.stability = Math.max(RenderConfig.Bond.MinVisibleStability, 1 - intensity * 0.9);
  }

  private applyLabHeatEffects(): void {
    this.particles.forEach(particle => {
      let maxTemp = this.globalTemperature;

      // Check heat sources (lab equipment)
      this.heatSources.forEach(heatSource => {
        if (!heatSource.isActive) return;

        const dx = particle.x - heatSource.x;
        const dy = particle.y - heatSource.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < heatSource.radius) {
          const heatFactor = Math.max(0, 1 - distance / heatSource.radius);
          const heatContribution = heatSource.temperature * heatSource.intensity * heatFactor;
          maxTemp = Math.max(maxTemp, this.globalTemperature + heatContribution);
        }
      });

      // Gradually adjust particle temperature
      const tempDiff = maxTemp - (particle.temperature || this.globalTemperature);
      particle.temperature = (particle.temperature || this.globalTemperature) + tempDiff * 0.02;

      // Update particle appearance based on temperature
      this.updateParticleFromTemperature(particle);
    });
  }

  private updateParticleFromTemperature(particle: Particle): void {
    const temp = particle.temperature || this.globalTemperature;

    // Don't override element colors, just intensity
    if (!particle.data?.elementType) {
      if (temp < 40) particle.color = RenderConfig.TemperatureColors.Cool;
      else if (temp < 70) particle.color = RenderConfig.TemperatureColors.Medium;
      else particle.color = RenderConfig.TemperatureColors.Hot;
    }

    // Speed increases with temperature
    const tempFactor = (temp - 25) / 75;
    particle.maxSpeed = 0.5 + Math.max(0, tempFactor) * 2.0;
  }

  private applyTemperatureEffects(particle: Particle, timeStep: number, currentTimeMs: number): void {
    const temp = particle.temperature || this.globalTemperature;
    const tempFactor = temp / 50;

    // Random brownian motion
    const randomForceScale = this.performanceMode === 'high' ? 0.5 : 0.2;
    particle.vx += (Math.random() - 0.5) * tempFactor * randomForceScale * (particle.mass || 1) * timeStep;
    particle.vy += (Math.random() - 0.5) * tempFactor * randomForceScale * (particle.mass || 1) * timeStep;

    // Vibration for low temperature (solid-like behavior)
    if (temp < 35 && particle.vibrationIntensity > 0) {
      const angle = (currentTimeMs / (particle.vibrationFrequency || 200)) * Math.PI * 2;
      particle.x += Math.sin(angle) * particle.vibrationIntensity * timeStep * 50;
      particle.y += Math.cos(angle) * particle.vibrationIntensity * timeStep * 50;
    }
  }

  private applyFriction(particle: Particle): void {
    const friction = 0.98;
    particle.vx *= friction;
    particle.vy *= friction;
  }

  private updatePosition(particle: Particle, timeStep: number): void {
    const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
    if (speed > particle.maxSpeed && particle.maxSpeed > 0) {
      particle.vx = (particle.vx / speed) * particle.maxSpeed;
      particle.vy = (particle.vy / speed) * particle.maxSpeed;
    }

    particle.x += particle.vx * timeStep * 50;
    particle.y += particle.vy * timeStep * 50;
  }

  private applyBondConstraint(bond: Bond, timeStep: number): void {
    const p1 = bond.particle1;
    const p2 = bond.particle2;
    if (p1.isFixed && p2.isFixed) return;

    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const distance = Math.max(1, Math.sqrt(dx * dx + dy * dy));
    const diffRatio = (bond.restLength - distance) / distance;

    const p1Share = p1.isFixed ? 0 : (p2.isFixed ? 1 : 0.5);
    const p2Share = p2.isFixed ? 0 : (p1.isFixed ? 1 : 0.5);

    const springForce = diffRatio * (bond.stiffness || 0.5) * bond.stability;
    const moveX = dx * springForce;
    const moveY = dy * springForce;

    if (!p1.isFixed) {
      p1.vx -= moveX * p1Share * timeStep;
      p1.vy -= moveY * p1Share * timeStep;
    }
    if (!p2.isFixed) {
      p2.vx += moveX * p2Share * timeStep;
      p2.vy += moveY * p2Share * timeStep;
    }
  }

  private applyBoundaryConstraints(particle: Particle): void {
    const restitution = 0.5;

    if (particle.x < particle.radius) {
      particle.x = particle.radius;
      particle.vx *= -restitution;
    } else if (particle.x > this.width - particle.radius) {
      particle.x = this.width - particle.radius;
      particle.vx *= -restitution;
    }

    if (particle.y < particle.radius) {
      particle.y = particle.radius;
      particle.vy *= -restitution;
    } else if (particle.y > this.height - particle.radius) {
      particle.y = this.height - particle.radius;
      particle.vy *= -restitution;
    }
  }

  private applyLabBoundaryConstraints(particle: Particle): void {
    this.boundaries.forEach(boundary => {
      const collision = this.checkBoundaryCollision(particle, boundary);
      if (collision.hasCollision && collision.normal) {
        // Move particle out
        particle.x -= collision.normal.x * collision.penetration;
        particle.y -= collision.normal.y * collision.penetration;

        // Reflect velocity
        const dot = particle.vx * collision.normal.x + particle.vy * collision.normal.y;
        particle.vx -= 2 * dot * collision.normal.x * boundary.restitution;
        particle.vy -= 2 * dot * collision.normal.y * boundary.restitution;

        // Apply friction
        particle.vx *= (1 - boundary.friction);
        particle.vy *= (1 - boundary.friction);
      }
    });
  }

  private checkBoundaryCollision(particle: Particle, boundary: LabBoundary): {
    hasCollision: boolean;
    normal?: { x: number; y: number };
    penetration: number;
  } {
    if (boundary.shape === 'rectangle' && boundary.width && boundary.height) {
      const left = boundary.x;
      const right = boundary.x + boundary.width;
      const top = boundary.y;
      const bottom = boundary.y + boundary.height;

      if (particle.x + particle.radius > left &&
          particle.x - particle.radius < right &&
          particle.y + particle.radius > top &&
          particle.y - particle.radius < bottom) {

        const distLeft = particle.x - left;
        const distRight = right - particle.x;
        const distTop = particle.y - top;
        const distBottom = bottom - particle.y;

        const minDist = Math.min(distLeft, distRight, distTop, distBottom);
        let normal: { x: number; y: number };

        if (minDist === distLeft) normal = { x: -1, y: 0 };
        else if (minDist === distRight) normal = { x: 1, y: 0 };
        else if (minDist === distTop) normal = { x: 0, y: -1 };
        else normal = { x: 0, y: 1 };

        return {
          hasCollision: true,
          normal,
          penetration: particle.radius - minDist
        };
      }
    }

    return { hasCollision: false, penetration: 0 };
  }

  private detectCollisions(particles: Particle[]): void {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        if (p1.isFixed && p2.isFixed) continue;

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = p1.radius + p2.radius;

        if (distance < minDistance && distance > 0) {
          // Resolve overlap
          const overlap = (minDistance - distance) / distance;
          const offsetX = dx * overlap * 0.5;
          const offsetY = dy * overlap * 0.5;

          if (!p1.isFixed) {
            p1.x -= offsetX;
            p1.y -= offsetY;
          }
          if (!p2.isFixed) {
            p2.x += offsetX;
            p2.y += offsetY;
          }

          // Elastic collision response
          const angle = Math.atan2(dy, dx);
          const sin = Math.sin(angle);
          const cos = Math.cos(angle);

          const v1 = { x: p1.vx * cos + p1.vy * sin, y: p1.vy * cos - p1.vx * sin };
          const v2 = { x: p2.vx * cos + p2.vy * sin, y: p2.vy * cos - p2.vx * sin };

          const v1xFinal = p2.isFixed ? -v1.x : v2.x;
          const v2xFinal = p1.isFixed ? -v2.x : v1.x;

          const p1vx = v1xFinal * cos - v1.y * sin;
          const p1vy = v1.y * cos + v1xFinal * sin;
          const p2vx = v2xFinal * cos - v2.y * sin;
          const p2vy = v2.y * cos + v2xFinal * sin;

          const restitution = 0.8;

          if (!p1.isFixed) {
            p1.vx = p1vx * restitution;
            p1.vy = p1vy * restitution;
          }
          if (!p2.isFixed) {
            p2.vx = p2vx * restitution;
            p2.vy = p2vy * restitution;
          }
        }
      }
    }
  }

  // ===== GETTERS =====
  getState(currentTimeMs: number): PhysicsState {
    return {
      particles: Object.freeze(Array.from(this.particles.values()).map(p => ({ ...p }))),
      bonds: Object.freeze(Array.from(this.bonds.values()).map(b => ({ ...b }))),
      timestamp: currentTimeMs,
    };
  }

  getParticles(): Particle[] {
    return Array.from(this.particles.values());
  }

  getBonds(): Bond[] {
    return Array.from(this.bonds.values());
  }

  getBoundaries(): LabBoundary[] {
    return Array.from(this.boundaries.values());
  }

  getHeatSources(): HeatSource[] {
    return Array.from(this.heatSources.values());
  }

  getTemperatureAt(x: number, y: number): number {
    let maxTemp = this.globalTemperature;

    this.heatSources.forEach(heatSource => {
      if (!heatSource.isActive) return;
      const distance = Math.sqrt((x - heatSource.x) ** 2 + (y - heatSource.y) ** 2);
      if (distance < heatSource.radius) {
        const factor = 1 - distance / heatSource.radius;
        maxTemp = Math.max(maxTemp, this.globalTemperature + heatSource.temperature * factor);
      }
    });

    return maxTemp;
  }
}

---- File Content End ----


=== File: LabExperimentExample.tsx ===
Path: examples\LabExperimentExample.tsx
---- File Content Start ----
// src/data/animations/examples/LabExperimentExample.tsx

import React, { useState } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import Svg, { Rect, Circle } from 'react-native-svg';
import { UnifiedAnimationProvider, useLabAnimation } from '../UnifiedAnimationProvider';
import { ConnectedAnimationCanvas } from '../components/ConnectedAnimationCanvas';
import type { AnimationConfig } from '../core/types';

// ===== EQUIPMENT OVERLAY COMPONENTS =====

interface BunsenBurnerOverlayProps {
  x: number;
  y: number;
  width: number;
  height: number;
  isActive: boolean;
  onToggle: () => void;
}

const BunsenBurnerOverlay: React.FC<BunsenBurnerOverlayProps> = ({
  x, y, width, height, isActive, onToggle
}) => (
  <TouchableOpacity
    onPress={onToggle}
    style={{ position: 'absolute', left: x, top: y, width, height }}
    activeOpacity={0.7}
  >
    <Svg width={width} height={height}>
      {/* Burner base */}
      <Rect
        x={width * 0.3}
        y={height * 0.7}
        width={width * 0.4}
        height={height * 0.3}
        rx={4}
        fill={isActive ? "#ff6600" : "#666"}
        stroke="#333"
        strokeWidth={1}
      />

      {/* Gas outlet */}
      <Circle
        cx={width * 0.5}
        cy={height * 0.6}
        r={width * 0.1}
        fill={isActive ? "#ff9900" : "#999"}
        stroke="#333"
      />

      {/* Status indicator */}
      <Circle
        cx={width * 0.8}
        cy={height * 0.8}
        r={4}
        fill={isActive ? "#00ff00" : "#ff0000"}
      />
    </Svg>
  </TouchableOpacity>
);

interface BeakerOverlayProps {
  x: number;
  y: number;
  width: number;
  height: number;
  temperature: number;
}

const BeakerOverlay: React.FC<BeakerOverlayProps> = ({
  x, y, width, height, temperature
}) => (
  <View style={{ position: 'absolute', left: x, top: y, width, height, pointerEvents: 'none' }}>
    <Svg width={width} height={height}>
      {/* Beaker outline */}
      <Rect
        x={width * 0.1}
        y={height * 0.3}
        width={width * 0.8}
        height={height * 0.6}
        rx={8}
        fill="transparent"
        stroke="rgba(100, 100, 100, 0.8)"
        strokeWidth={2}
      />

      {/* Temperature indicator */}
      <Rect
        x={width * 0.02}
        y={height * 0.1}
        width={width * 0.15}
        height={height * 0.8}
        rx={4}
        fill="rgba(255, 255, 255, 0.9)"
        stroke="#666"
      />

      {/* Temperature mercury */}
      <Rect
        x={width * 0.04}
        y={height * 0.9 - (temperature / 100) * height * 0.76}
        width={width * 0.11}
        height={(temperature / 100) * height * 0.76}
        rx={2}
        fill={temperature > 60 ? "#ff4444" : temperature > 30 ? "#ff8844" : "#4488ff"}
      />
    </Svg>
  </View>
);

// ===== MAIN LAB EXPERIMENT COMPONENT =====

interface LabExperimentProps {
  width?: number;
  height?: number;
}

const LabExperimentInner: React.FC<LabExperimentProps> = ({
  width = 400,
  height = 300
}) => {
  const {
    addParticle,
    addBoundary,
    addHeatSource,
    updateHeatSource,
    getTemperatureAt,
    setTemperature,
    isRunning,
    toggle,
    reset
  } = useLabAnimation();

  const [burnerActive, setBurnerActive] = useState(false);
  const [heatSourceId, setHeatSourceId] = useState<string | null>(null);
  const [containerId, setContainerId] = useState<string | null>(null);
  const [particlesAdded, setParticlesAdded] = useState(false);

  // Initialize lab setup
  React.useEffect(() => {
    // Create beaker container
    const containerId = addBoundary({
      type: 'container',
      shape: 'rectangle',
      x: width * 0.25 + 8,
      y: height * 0.3 + height * 0.5 * 0.3,
      width: width * 0.4 - 16,
      height: height * 0.5 * 0.6,
      restitution: 0.3,
      friction: 0.1,
    });
    setContainerId(containerId);

    // Create heat source
    const heatId = addHeatSource({
      x: width * 0.45,
      y: height * 0.85,
      radius: 80,
      intensity: 0,
      temperature: 0,
      isActive: false
    });
    setHeatSourceId(heatId);

    // Add water particles
    if (!particlesAdded) {
      for (let i = 0; i < 25; i++) {
        addParticle({
          x: width * 0.25 + 15 + Math.random() * (width * 0.4 - 30),
          y: height * 0.3 + height * 0.5 * 0.4 + Math.random() * (height * 0.5 * 0.4),
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          radius: 2 + Math.random() * 1.5,
          mass: 1,
          color: '#4A90E2',
          maxSpeed: 1,
          vibrationIntensity: 0.1,
          temperature: 25,
          data: { elementType: 'H2O', liquidType: 'water' }
        });
      }
      setParticlesAdded(true);
    }
  }, [addBoundary, addHeatSource, addParticle, width, height, particlesAdded]);

  const toggleBurner = () => {
    if (heatSourceId) {
      const newActive = !burnerActive;
      setBurnerActive(newActive);

      updateHeatSource(heatSourceId, {
        intensity: newActive ? 0.8 : 0,
        temperature: newActive ? 75 : 0,
        isActive: newActive
      });
    }
  };

  const addMoreWater = () => {
    for (let i = 0; i < 5; i++) {
      addParticle({
        x: width * 0.25 + 20 + Math.random() * (width * 0.4 - 40),
        y: height * 0.3 + 10,
        vx: (Math.random() - 0.5) * 0.2,
        vy: 0.5,
        radius: 2 + Math.random() * 1.5,
        mass: 1,
        color: '#4A90E2',
        maxSpeed: 1,
        vibrationIntensity: 0.1,
        temperature: 25,
        data: { elementType: 'H2O', liquidType: 'water' }
      });
    }
  };

  const currentTemp = getTemperatureAt(width * 0.45, height * 0.6);

  return (
    <View style={{ width, height, backgroundColor: '#f8f9fa', borderRadius: 12, overflow: 'hidden' }}>
      {/* Header */}
      <View style={{
        padding: 12,
        backgroundColor: 'rgba(255,255,255,0.9)',
        borderBottomWidth: 1,
        borderBottomColor: '#e0e0e0'
      }}>
        <Text style={{ fontSize: 18, fontWeight: 'bold', color: '#333', textAlign: 'center' }}>
          🧪 Interactive Heating Experiment
        </Text>
        <Text style={{ fontSize: 12, color: '#666', textAlign: 'center', marginTop: 4 }}>
          Skia Physics + SVG Equipment • Temperature: {Math.round(currentTemp)}°C
        </Text>
      </View>

      {/* Animation Canvas with Equipment Overlays */}
      <View style={{ flex: 1, position: 'relative' }}>
        <ConnectedAnimationCanvas
          width={width}
          height={height - 100}
          showTrails={currentTemp > 40}
          showHeatFields={burnerActive}
        >
          {/* Bunsen Burner Overlay */}
          <BunsenBurnerOverlay
            x={width * 0.35}
            y={height * 0.7}
            width={width * 0.2}
            height={height * 0.25}
            isActive={burnerActive}
            onToggle={toggleBurner}
          />

          {/* Beaker Overlay */}
          <BeakerOverlay
            x={width * 0.25}
            y={height * 0.3}
            width={width * 0.4}
            height={height * 0.5}
            temperature={currentTemp}
          />
        </ConnectedAnimationCanvas>
      </View>

      {/* Controls */}
      <View style={{
        flexDirection: 'row',
        justifyContent: 'space-around',
        alignItems: 'center',
        padding: 12,
        backgroundColor: 'rgba(255,255,255,0.95)',
        borderTopWidth: 1,
        borderTopColor: '#e0e0e0'
      }}>
        <TouchableOpacity
          onPress={toggleBurner}
          style={{
            backgroundColor: burnerActive ? '#ff6600' : '#666',
            paddingHorizontal: 16,
            paddingVertical: 8,
            borderRadius: 6,
            flex: 1,
            marginHorizontal: 4
          }}
        >
          <Text style={{ color: 'white', textAlign: 'center', fontWeight: 'bold' }}>
            {burnerActive ? '🔥 Turn Off' : '🔥 Heat'}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          onPress={addMoreWater}
          style={{
            backgroundColor: '#4A90E2',
            paddingHorizontal: 16,
            paddingVertical: 8,
            borderRadius: 6,
            flex: 1,
            marginHorizontal: 4
          }}
        >
          <Text style={{ color: 'white', textAlign: 'center', fontWeight: 'bold' }}>
            💧 Add Water
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          onPress={toggle}
          style={{
            backgroundColor: isRunning ? '#ff9900' : '#00aa00',
            paddingHorizontal: 16,
            paddingVertical: 8,
            borderRadius: 6,
            flex: 1,
            marginHorizontal: 4
          }}
        >
          <Text style={{ color: 'white', textAlign: 'center', fontWeight: 'bold' }}>
            {isRunning ? '⏸️ Pause' : '▶️ Play'}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          onPress={() => reset()}
          style={{
            backgroundColor: '#cc0000',
            paddingHorizontal: 16,
            paddingVertical: 8,
            borderRadius: 6,
            flex: 1,
            marginHorizontal: 4
          }}
        >
          <Text style={{ color: 'white', textAlign: 'center', fontWeight: 'bold' }}>
            🔄 Reset
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

// ===== EXPORTED COMPONENT WITH PROVIDER =====

export const LabExperimentExample: React.FC<LabExperimentProps> = (props) => {
  const labConfig: AnimationConfig = {
    type: 'lab',
    width: props.width || 400,
    height: (props.height || 300) - 100, // Account for header/controls
    experimentType: 'heating',
    initialTemperature: 25,
    performanceMode: 'medium',
    enablePhysics: true,
    enableLabEquipment: true,
  };

  return (
    <UnifiedAnimationProvider initialConfig={labConfig} autoStart={true}>
      <LabExperimentInner {...props} />
    </UnifiedAnimationProvider>
  );
};

export default LabExperimentExample;

---- File Content End ----


=== File: useAnimationSystem.ts ===
Path: hooks\useAnimationSystem.ts
---- File Content Start ----
// src/data/animations/hooks/useAnimationSystem.ts
// This hook provides the AnimationContextAPI and can be a place for complex, multi-step animation sequences.
// Simple presets are now better handled by the SceneBuilder.

import { useAnimationAPI } from '../2d/AnimationProvider';
import type { AnimationConfig } from '../core/types';

// This hook now primarily serves as a convenient re-export of the main API.
// For building scenes, you should now use the `sceneBuilder` from the context.
export const useAnimationSystem = () => {
  const animationAPI = useAnimationAPI();

  // Presets are now better handled by `sceneBuilder.buildFromConfig(config)`
  // or by calling `sceneBuilder.createWaterMolecule(...)` directly.
  // This hook is for getting the API. A component would use it like this:
  //
  // const { sceneBuilder, resetSimulation } = useAnimationSystem();
  // useEffect(() => {
  //   const config = { type: 'molecule', moleculeType: 'water', ... };
  //   resetSimulation(config);
  // }, []);
  //
  // No need to replicate preset logic here anymore.

  return animationAPI;
};

---- File Content End ----


=== File: usePerformance.ts ===
Path: hooks\usePerformance.ts
---- File Content Start ----

---- File Content End ----


=== File: usePhysics.ts ===
Path: hooks\usePhysics.ts
---- File Content Start ----

---- File Content End ----


=== File: index.ts ===
Path: lab\index.ts
---- File Content Start ----
// ===========================================
// 12. src/data/animations/lab/index.ts
// ===========================================

export { LabAnimationProvider, useLabAnimation } from './LabAnimationProvider';
export { LabHeatingExperiment } from './components/LabExperiments';
export { InteractiveEquipment } from './components/InteractiveEquipment';
export { LabCanvas } from './components/LabCanvas';
export { LabPhysicsEngine } from './core/LabPhysicsEngine';
export * from './core/labTypes';
export * from './assets';

---- File Content End ----


=== File: LabAnimationProvider.tsx ===
Path: lab\LabAnimationProvider.tsx
---- File Content Start ----
import React, { createContext, useContext, useState, useEffect, useRef, useCallback, ReactNode } from 'react';
import { View, Text } from 'react-native'; // ✅ ADDED MISSING IMPORTS
import { LabPhysicsEngine } from './core/LabPhysicsEngine';
import type { Particle, LabBoundary, HeatSource } from './core/labTypes';

interface LabAnimationContextType {
  physics: LabPhysicsEngine;
  particles: Particle[];
  boundaries: LabBoundary[];
  heatSources: HeatSource[];
  addParticle: (data: Omit<Particle, 'id'>) => string;
  addHeatSource: (data: Omit<HeatSource, 'id'>) => string;
  updateHeatSource: (id: string, updates: Partial<HeatSource>) => void;
  addBoundary: (data: Omit<LabBoundary, 'id'>) => string;
  getTemperatureAt: (x: number, y: number) => number;
  reset: () => void;
}

const LabAnimationContext = createContext<LabAnimationContextType | null>(null);

export const LabAnimationProvider: React.FC<{
  children: ReactNode;
  width: number;
  height: number;
}> = ({ children, width, height }) => {
  const physicsRef = useRef<LabPhysicsEngine | null>(null);
  const [tick, setTick] = useState(0);
  const animationRef = useRef<number>();
  const [isInitialized, setIsInitialized] = useState(false);

  // Initialize physics engine safely
  useEffect(() => {
    try {
      if (!physicsRef.current) {
        physicsRef.current = new LabPhysicsEngine(width, height);
        setIsInitialized(true);
      }
    } catch (error) {
      console.error('Failed to initialize physics engine:', error);
    }
  }, [width, height]);

  // Animation loop with error handling
  useEffect(() => {
    if (!isInitialized || !physicsRef.current) return;

    let lastTime = performance.now();

    const animate = (currentTime: number) => {
      try {
        if (!physicsRef.current) return;

        const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.016); // Cap at 60fps
        physicsRef.current.update(deltaTime);
        lastTime = currentTime;
        setTick(t => t + 1);
        animationRef.current = requestAnimationFrame(animate);
      } catch (error) {
        console.error('Animation loop error:', error);
        // Continue animation despite errors
        animationRef.current = requestAnimationFrame(animate);
      }
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isInitialized]);

  // Safe API methods with error handling
  const addParticle = useCallback((data: Omit<Particle, 'id'>) => {
    try {
      if (!physicsRef.current) throw new Error('Physics engine not initialized');
      return physicsRef.current.addParticle(data);
    } catch (error) {
      console.error('Failed to add particle:', error);
      return 'error';
    }
  }, []);

  const addHeatSource = useCallback((data: Omit<HeatSource, 'id'>) => {
    try {
      if (!physicsRef.current) throw new Error('Physics engine not initialized');
      return physicsRef.current.addHeatSource(data);
    } catch (error) {
      console.error('Failed to add heat source:', error);
      return 'error';
    }
  }, []);

  const updateHeatSource = useCallback((id: string, updates: Partial<HeatSource>) => {
    try {
      if (!physicsRef.current) throw new Error('Physics engine not initialized');
      physicsRef.current.updateHeatSource(id, updates);
    } catch (error) {
      console.error('Failed to update heat source:', error);
    }
  }, []);

  const addBoundary = useCallback((data: Omit<LabBoundary, 'id'>) => {
    try {
      if (!physicsRef.current) throw new Error('Physics engine not initialized');
      return physicsRef.current.addBoundary(data);
    } catch (error) {
      console.error('Failed to add boundary:', error);
      return 'error';
    }
  }, []);

  const getTemperatureAt = useCallback((x: number, y: number) => {
    try {
      if (!physicsRef.current) return 25;
      return physicsRef.current.getTemperatureAt(x, y);
    } catch (error) {
      console.error('Failed to get temperature:', error);
      return 25;
    }
  }, []);

  const reset = useCallback(() => {
    try {
      if (!physicsRef.current) return;
      physicsRef.current.reset();
    } catch (error) {
      console.error('Failed to reset physics:', error);
    }
  }, []);

  // Safe getters with fallbacks
  const getParticles = () => {
    try {
      return physicsRef.current?.getParticles() || [];
    } catch (error) {
      console.error('Failed to get particles:', error);
      return [];
    }
  };

  const getBoundaries = () => {
    try {
      return physicsRef.current?.getBoundaries() || [];
    } catch (error) {
      console.error('Failed to get boundaries:', error);
      return [];
    }
  };

  const getHeatSources = () => {
    try {
      return physicsRef.current?.getHeatSources() || [];
    } catch (error) {
      console.error('Failed to get heat sources:', error);
      return [];
    }
  };

  // Don't provide context until initialized
  if (!isInitialized || !physicsRef.current) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text>Initializing Lab...</Text>
      </View>
    );
  }

  const contextValue: LabAnimationContextType = {
    physics: physicsRef.current,
    particles: getParticles(),
    boundaries: getBoundaries(),
    heatSources: getHeatSources(),
    addParticle,
    addHeatSource,
    updateHeatSource,
    addBoundary,
    getTemperatureAt,
    reset
  };

  return (
    <LabAnimationContext.Provider value={contextValue}>
      {children}
    </LabAnimationContext.Provider>
  );
};

export const useLabAnimation = () => {
  const context = useContext(LabAnimationContext);
  if (!context) {
    throw new Error('useLabAnimation must be used within LabAnimationProvider');
  }
  return context;
};

interface LabAnimationContextType {
  physics: LabPhysicsEngine;
  particles: Particle[];
  boundaries: LabBoundary[];
  heatSources: HeatSource[];
  addParticle: (data: Omit<Particle, 'id'>) => string;
  addHeatSource: (data: Omit<HeatSource, 'id'>) => string;
  updateHeatSource: (id: string, updates: Partial<HeatSource>) => void;
  addBoundary: (data: Omit<LabBoundary, 'id'>) => string;
  getTemperatureAt: (x: number, y: number) => number;
  reset: () => void;
}

---- File Content End ----


=== File: Beaker.tsx ===
Path: lab\assets\Beaker.tsx
---- File Content Start ----

import React from 'react';
import Svg, {
  Path,
  G,
  Circle,
  Line,
  Rect,
  AnimateTransform,
  Animate
} from 'react-native-svg';
import { LabColors } from './colors';

interface BeakerProps {
  width: number;
  height: number;
  liquidLevel: number;
  bubbles?: boolean;
}

export const BeakerSVG: React.FC<BeakerProps> = ({ width, height, liquidLevel, bubbles = false }) => (
  <Svg width={width} height={height} viewBox="0 0 80 100">
    {/* Beaker body */}
    <Path
      d="M 15 85 L 15 25 L 65 25 L 65 85 Q 65 90 40 90 Q 15 90 15 85 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="2"
      opacity="0.8"
    />

    {/* Spout */}
    <Path
      d="M 65 25 L 75 20 L 75 30 L 65 35 Z"
      fill={LabColors.glass.clear}
      stroke={LabColors.glass.shadow}
      strokeWidth="1.5"
      opacity="0.8"
    />

    {/* Liquid */}
    {liquidLevel > 0 && (
      <Path
        d={`M 17 ${85 - liquidLevel * 60} L 17 83 Q 17 88 40 88 Q 63 88 63 83 L 63 ${85 - liquidLevel * 60} Q 40 ${87 - liquidLevel * 60} 17 ${85 - liquidLevel * 60} Z`}
        fill={LabColors.liquids.water}
        opacity="0.7"
      />
    )}

    {/* Bubbles */}
    {bubbles && liquidLevel > 0 && (
      <G>
        <Circle cx="25" cy="70" r="2" fill="rgba(255,255,255,0.6)">
          <AnimateTransform
            attributeName="transform"
            type="translate"
            values="0,0; 2,-40"
            dur="2s"
            repeatCount="indefinite"
          />
          <Animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" />
        </Circle>
        <Circle cx="40" cy="75" r="1.5" fill="rgba(255,255,255,0.6)">
          <AnimateTransform
            attributeName="transform"
            type="translate"
            values="0,0; -1,-35"
            dur="1.8s"
            repeatCount="indefinite"
          />
          <Animate attributeName="opacity" values="0;1;0" dur="1.8s" repeatCount="indefinite" />
        </Circle>
        <Circle cx="55" cy="72" r="2.5" fill="rgba(255,255,255,0.6)">
          <AnimateTransform
            attributeName="transform"
            type="translate"
            values="0,0; 1,-38"
            dur="2.2s"
            repeatCount="indefinite"
          />
          <Animate attributeName="opacity" values="0;1;0" dur="2.2s" repeatCount="indefinite" />
        </Circle>
      </G>
    )}

    {/* Volume markings */}
    <G stroke={LabColors.glass.shadow} strokeWidth="0.5" opacity="0.6">
      <Line x1="12" y1="45" x2="20" y2="45" />
      <Line x1="12" y1="60" x2="20" y2="60" />
      <Line x1="12" y1="75" x2="20" y2="75" />
    </G>

    {/* Glass highlight */}
    <Rect
      x="18"
      y="27"
      width="2"
      height="55"
      rx="1"
      fill={LabColors.glass.reflection}
      opacity="0.4"
    />
  </Svg>
);

---- File Content End ----


=== File: BeakerFromRepassets.tsx ===
Path: lab\assets\BeakerFromRepassets.tsx
---- File Content Start ----
// src/data/animations/lab/assets/enhanced/BeakerFromRepassets.tsx

import React, { useEffect } from 'react';
import { View } from 'react-native';
import Svg, {
  Path,
  Rect,
  Defs,
  LinearGradient,
  Stop,
  G,
  Circle
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  withSequence,
  interpolateColor,
  Easing,
} from 'react-native-reanimated';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
const AnimatedPath = Animated.createAnimatedComponent(Path);

interface BeakerFromRepassetsProps {
  size?: number;
  liquidLevel?: number; // 0-100
  liquidColor?: string;
  hasBubbles?: boolean;
  temperature?: number; // 0-100
}

export const BeakerFromRepassets: React.FC<BeakerFromRepassetsProps> = ({
  size = 120,
  liquidLevel = 30,
  liquidColor,
  hasBubbles = false,
  temperature = 20
}) => {
  // Animation values for bubbles
  const bubble1Y = useSharedValue(0);
  const bubble2Y = useSharedValue(0);
  const bubble3Y = useSharedValue(0);
  const bubble4Y = useSharedValue(0);
  const bubble5Y = useSharedValue(0);

  const bubble1Opacity = useSharedValue(0);
  const bubble2Opacity = useSharedValue(0);
  const bubble3Opacity = useSharedValue(0);
  const bubble4Opacity = useSharedValue(0);
  const bubble5Opacity = useSharedValue(0);

  const level = size * 0.9 - (liquidLevel / 100) * size * 0.6;

  // Get liquid color based on temperature
  const getLiquidColor = () => {
    if (liquidColor) return liquidColor;

    if (temperature < 30) return '#64B5F6'; // Cool blue
    if (temperature < 60) return '#4DB6AC'; // Medium teal
    if (temperature < 80) return '#FFB74D'; // Warm orange
    return '#E57373'; // Hot red
  };

  const liquidFill = getLiquidColor();

  // Bubble animations
  useEffect(() => {
    if (hasBubbles) {
      // Bubble 1
      bubble1Y.value = withRepeat(
        withSequence(
          withTiming(0, { duration: 0 }),
          withTiming(-30, { duration: 2000, easing: Easing.out(Easing.ease) })
        ),
        -1,
        false
      );
      bubble1Opacity.value = withRepeat(
        withSequence(
          withTiming(0, { duration: 0 }),
          withTiming(0.7, { duration: 300 }),
          withTiming(0.7, { duration: 1400 }),
          withTiming(0, { duration: 300 })
        ),
        -1,
        false
      );

      // Bubble 2 (offset timing)
      setTimeout(() => {
        bubble2Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-35, { duration: 1800, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble2Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 300 }),
            withTiming(0.7, { duration: 1200 }),
            withTiming(0, { duration: 300 })
          ),
          -1,
          false
        );
      }, 400);

      // Bubble 3
      setTimeout(() => {
        bubble3Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-32, { duration: 2200, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble3Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 300 }),
            withTiming(0.7, { duration: 1600 }),
            withTiming(0, { duration: 300 })
          ),
          -1,
          false
        );
      }, 800);

      // Bubble 4
      setTimeout(() => {
        bubble4Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-38, { duration: 1600, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble4Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 300 }),
            withTiming(0.7, { duration: 1000 }),
            withTiming(0, { duration: 300 })
          ),
          -1,
          false
        );
      }, 1200);

      // Bubble 5
      setTimeout(() => {
        bubble5Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-28, { duration: 2400, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble5Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 300 }),
            withTiming(0.7, { duration: 1800 }),
            withTiming(0, { duration: 300 })
          ),
          -1,
          false
        );
      }, 1600);
    } else {
      // Stop all bubble animations
      bubble1Y.value = withTiming(0, { duration: 300 });
      bubble2Y.value = withTiming(0, { duration: 300 });
      bubble3Y.value = withTiming(0, { duration: 300 });
      bubble4Y.value = withTiming(0, { duration: 300 });
      bubble5Y.value = withTiming(0, { duration: 300 });

      bubble1Opacity.value = withTiming(0, { duration: 300 });
      bubble2Opacity.value = withTiming(0, { duration: 300 });
      bubble3Opacity.value = withTiming(0, { duration: 300 });
      bubble4Opacity.value = withTiming(0, { duration: 300 });
      bubble5Opacity.value = withTiming(0, { duration: 300 });
    }
  }, [hasBubbles]);

  // Animated bubble props
  const bubble1Props = useAnimatedProps(() => ({
    cy: size * (0.8 - (liquidLevel / 100) * 0.6) + bubble1Y.value,
    opacity: bubble1Opacity.value
  }));

  const bubble2Props = useAnimatedProps(() => ({
    cy: size * (0.8 - (liquidLevel / 100) * 0.6) + bubble2Y.value,
    opacity: bubble2Opacity.value
  }));

  const bubble3Props = useAnimatedProps(() => ({
    cy: size * (0.8 - (liquidLevel / 100) * 0.6) + bubble3Props.value,
    opacity: bubble3Opacity.value
  }));

  const bubble4Props = useAnimatedProps(() => ({
    cy: size * (0.8 - (liquidLevel / 100) * 0.6) + bubble4Y.value,
    opacity: bubble4Opacity.value
  }));

  const bubble5Props = useAnimatedProps(() => ({
    cy: size * (0.8 - (liquidLevel / 100) * 0.6) + bubble5Y.value,
    opacity: bubble5Opacity.value
  }));

  return (
    <View style={{ width: size, height: size }}>
      <Svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <Defs>
          <LinearGradient id="glassGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#E0E0E0" stopOpacity="0.8" />
            <Stop offset="1" stopColor="#BDBDBD" stopOpacity="0.8" />
          </LinearGradient>

          <LinearGradient id="liquidGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor={liquidFill} stopOpacity="0.9" />
            <Stop offset="1" stopColor={liquidFill} stopOpacity="0.6" />
          </LinearGradient>
        </Defs>

        {/* Beaker outline */}
        <Path
          d={`
            M ${size * 0.3} ${size * 0.9}
            L ${size * 0.25} ${size * 0.1}
            C ${size * 0.25} ${size * 0.05}, ${size * 0.3} 0, ${size * 0.35} 0
            L ${size * 0.65} 0
            C ${size * 0.7} 0, ${size * 0.75} ${size * 0.05}, ${size * 0.75} ${size * 0.1}
            L ${size * 0.7} ${size * 0.9}
            Z
          `}
          fill="url(#glassGradient)"
          stroke="#757575"
          strokeWidth="1"
        />

        {/* Liquid */}
        <Path
          d={`
            M ${size * 0.3} ${size * 0.9}
            L ${size * 0.3} ${level}
            C ${size * 0.3} ${level - size * 0.05},
              ${size * 0.7} ${level - size * 0.05},
              ${size * 0.7} ${level}
            L ${size * 0.7} ${size * 0.9}
            Z
          `}
          fill="url(#liquidGradient)"
        />

        {/* Measurement markings */}
        <G stroke="#78909C" strokeWidth="0.5">
          {[10, 30, 50, 70, 90].map(markLevel => (
            <Rect
              key={markLevel}
              x={size * 0.28}
              y={size * 0.9 - (markLevel / 100) * size * 0.6}
              width={size * 0.44}
              height="0.5"
            />
          ))}
        </G>

        {/* Bubbles */}
        {hasBubbles && (
          <G>
            <AnimatedCircle
              cx={size * 0.4}
              r={size * 0.015}
              fill="#FFFFFF"
              animatedProps={bubble1Props}
            />
            <AnimatedCircle
              cx={size * 0.45}
              r={size * 0.018}
              fill="#FFFFFF"
              animatedProps={bubble2Props}
            />
            <AnimatedCircle
              cx={size * 0.5}
              r={size * 0.012}
              fill="#FFFFFF"
              animatedProps={bubble3Props}
            />
            <AnimatedCircle
              cx={size * 0.55}
              r={size * 0.02}
              fill="#FFFFFF"
              animatedProps={bubble4Props}
            />
            <AnimatedCircle
              cx={size * 0.6}
              r={size * 0.014}
              fill="#FFFFFF"
              animatedProps={bubble5Props}
            />
          </G>
        )}

        {/* Beaker base */}
        <Rect
          x={size * 0.25}
          y={size * 0.9}
          width={size * 0.5}
          height={size * 0.03}
          fill="#616161"
          rx={size * 0.01}
        />

        {/* Glass highlight */}
        <Rect
          x={size * 0.32}
          y={size * 0.02}
          width={size * 0.03}
          height={size * 0.85}
          fill="#FFFFFF"
          opacity={0.3}
          rx={size * 0.01}
        />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: BunsenBurner.tsx ===
Path: lab\assets\BunsenBurner.tsx
---- File Content Start ----
import React from 'react';
import Svg, {
  Rect,
  Circle,
  Path,
  Defs,
  RadialGradient,
  Stop,
  AnimateTransform,
  G
} from 'react-native-svg';
import { LabColors } from './colors';

interface BunsenBurnerProps {
  width: number;
  height: number;
  isActive: boolean;
}

export const BunsenBurnerSVG: React.FC<BunsenBurnerProps> = ({ width, height, isActive }) => (
  <Svg width={width} height={height} viewBox="0 0 60 80">
    {/* Base */}
    <Rect x="20" y="70" width="20" height="8" rx="2" fill={LabColors.metal.primary} />

    {/* Main tube */}
    <Rect
      x="26"
      y="20"
      width="8"
      height="50"
      rx="4"
      fill={LabColors.metal.primary}
      stroke={LabColors.metal.secondary}
      strokeWidth="1"
    />

    {/* Gas control */}
    <Rect x="24" y="45" width="12" height="6" rx="3" fill={LabColors.metal.secondary} />

    {/* Air holes */}
    <Circle cx="27" cy="48" r="0.8" fill={LabColors.metal.shadow} />
    <Circle cx="33" cy="48" r="0.8" fill={LabColors.metal.shadow} />

    {/* Burner head */}
    <Rect x="24" y="18" width="12" height="8" rx="2" fill={LabColors.metal.secondary} />

    {/* Gas outlet */}
    <Circle cx="30" cy="20" r="2" fill={LabColors.metal.shadow} />

    {/* Flame */}
    {isActive && (
      <G>
        <Defs>
          <RadialGradient id="flameGradient" cx="50%" cy="80%" r="60%">
            <Stop offset="0%" stopColor={LabColors.flame.blue} />
            <Stop offset="50%" stopColor={LabColors.flame.orange} />
            <Stop offset="100%" stopColor={LabColors.flame.red} />
          </RadialGradient>
        </Defs>
        <Path
          d="M 30 20 Q 25 15 27 8 Q 29 5 30 3 Q 31 5 33 8 Q 35 15 30 20 Z"
          fill="url(#flameGradient)"
          opacity="0.9"
        >
          <AnimateTransform
            attributeName="transform"
            type="scale"
            values="1,1;1.1,1.2;1,1"
            dur="0.5s"
            repeatCount="indefinite"
          />
        </Path>
      </G>
    )}
  </Svg>
);

---- File Content End ----


=== File: BunsenBurnerFromRepassets.tsx ===
Path: lab\assets\BunsenBurnerFromRepassets.tsx
---- File Content Start ----
// src/data/animations/lab/assets/enhanced/BunsenBurnerFromRepassets.tsx

import React, { useEffect } from 'react';
import { View } from 'react-native';
import Svg, {
  Rect,
  Circle,
  Path,
  Defs,
  LinearGradient,
  Stop,
  G
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  withSequence,
  Easing,
} from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface BunsenBurnerFromRepassetsProps {
  size?: number;
  isActive?: boolean;
  intensity?: number; // 0-100
  flameColor?: string;
}

export const BunsenBurnerFromRepassets: React.FC<BunsenBurnerFromRepassetsProps> = ({
  size = 100,
  isActive = false,
  intensity = 50,
  flameColor = '#FF5722'
}) => {
  // Animation values
  const flameScale = useSharedValue(1);
  const flameRotation = useSharedValue(0);
  const glowOpacity = useSharedValue(0);
  const glowScale = useSharedValue(1);

  const flameHeight = size * (0.2 + (intensity / 100) * 0.4);

  useEffect(() => {
    if (isActive) {
      // Flickering flame animation
      flameScale.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 150, easing: Easing.inOut(Easing.ease) }),
          withTiming(1.05, { duration: 150, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      );

      // Flame rotation for natural movement
      flameRotation.value = withRepeat(
        withSequence(
          withTiming(-1, { duration: 300, easing: Easing.inOut(Easing.ease) }),
          withTiming(1, { duration: 300, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      );

      // Glow effect
      glowOpacity.value = withTiming(0.3 + (intensity / 100) * 0.3, { duration: 300 });
      glowScale.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 500 }),
          withTiming(1.1, { duration: 500 })
        ),
        -1,
        true
      );
    } else {
      // Reset animations
      flameScale.value = withTiming(1, { duration: 300 });
      flameRotation.value = withTiming(0, { duration: 300 });
      glowOpacity.value = withTiming(0, { duration: 300 });
      glowScale.value = withTiming(1, { duration: 300 });
    }
  }, [isActive, intensity]);

  // Animated flame properties
  const animatedFlameProps = useAnimatedProps(() => ({
    transform: [
      { scale: flameScale.value },
      { rotate: `${flameRotation.value}deg` }
    ],
    opacity: isActive ? 0.8 : 0
  }));

  // Animated glow properties
  const animatedGlowProps = useAnimatedProps(() => ({
    opacity: glowOpacity.value,
    r: (size * 0.2 + (intensity / 100) * size * 0.1) * glowScale.value
  }));

  return (
    <View style={{ width: size, height: size }}>
      <Svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <Defs>
          <LinearGradient id="burnerGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#424242" stopOpacity="0.8" />
            <Stop offset="1" stopColor="#757575" stopOpacity="0.8" />
          </LinearGradient>

          <LinearGradient id="flameGradient" x1="0" y1="1" x2="0" y2="0">
            <Stop offset="0" stopColor="#1E88E5" />
            <Stop offset="0.3" stopColor={flameColor} />
            <Stop offset="0.7" stopColor="#FFD700" />
            <Stop offset="1" stopColor="#FF6B35" />
          </LinearGradient>
        </Defs>

        {/* Flame glow effect */}
        {isActive && (
          <AnimatedCircle
            cx={size * 0.5}
            cy={size * 0.6}
            fill={flameColor}
            animatedProps={animatedGlowProps}
          />
        )}

        {/* Burner base */}
        <G opacity={0.8}>
          <Rect
            x={size * 0.25}
            y={size * 0.7}
            width={size * 0.5}
            height={size * 0.05}
            fill="#424242"
            rx={size * 0.01}
          />
          <Rect
            x={size * 0.3}
            y={size * 0.65}
            width={size * 0.4}
            height={size * 0.05}
            fill="#616161"
            rx={size * 0.01}
          />
          <Circle
            cx={size * 0.5}
            cy={size * 0.6}
            r={size * 0.15}
            fill="url(#burnerGradient)"
          />
        </G>

        {/* Main flame */}
        {isActive && (
          <AnimatedPath
            d={`
              M ${size * 0.3} ${size * 0.7}
              C ${size * 0.25} ${size * 0.7 - flameHeight},
                ${size * 0.4} ${size * 0.7 - flameHeight},
                ${size * 0.5} ${size * 0.7 - flameHeight}
              C ${size * 0.6} ${size * 0.7 - flameHeight},
                ${size * 0.75} ${size * 0.7 - flameHeight},
                ${size * 0.7} ${size * 0.7}
              Z
            `}
            fill="url(#flameGradient)"
            animatedProps={animatedFlameProps}
          />
        )}

        {/* Burner details */}
        <Circle
          cx={size * 0.5}
          cy={size * 0.6}
          r={size * 0.1}
          fill="#9E9E9E"
        />
        <Circle
          cx={size * 0.5}
          cy={size * 0.6}
          r={size * 0.05}
          fill="#BDBDBD"
        />

        {/* Gas control valve */}
        <Rect
          x={size * 0.45}
          y={size * 0.75}
          width={size * 0.1}
          height={size * 0.02}
          fill="#757575"
          rx={size * 0.01}
        />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: colors.ts ===
Path: lab\assets\colors.ts
---- File Content Start ----
// ===========================================
// 3. src/data/animations/lab/assets/colors.ts
// ===========================================

export const LabColors = {
  metal: {
    primary: '#8B9DC3',
    secondary: '#6B7FA3',
    highlight: '#B5C4E8',
    shadow: '#4A5568'
  },
  glass: {
    clear: '#E8F4F8',
    tint: '#D1E9F0',
    reflection: '#FFFFFF',
    shadow: '#B8D4DC'
  },
  flame: {
    blue: '#4299E1',
    orange: '#F6AD55',
    yellow: '#FFD700',
    red: '#F56565',
    white: '#FFFFFF'
  },
  liquids: {
    water: '#4A90E2',
    acid: '#FFE135',
    base: '#4ECDC4',
    indicator: '#FF69B4'
  },
  temperature: {
    cold: '#4A90E2',
    warm: '#F6AD55',
    hot: '#F56565'
  }
};

---- File Content End ----


=== File: FlaskEnhanced.tsx ===
Path: lab\assets\FlaskEnhanced.tsx
---- File Content Start ----
// src/data/animations/lab/assets/enhanced/FlaskEnhanced.tsx

import React, { useEffect } from 'react';
import { View } from 'react-native';
import Svg, {
  Path,
  Defs,
  LinearGradient,
  Stop,
  G,
  Circle
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  withSequence,
  Easing,
} from 'react-native-reanimated';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface FlaskEnhancedProps {
  size?: number;
  liquidLevel?: number; // 0-100
  liquidColor?: string;
  isHeating?: boolean;
  hasBubbles?: boolean;
  temperature?: number;
}

export const FlaskEnhanced: React.FC<FlaskEnhancedProps> = ({
  size = 120,
  liquidLevel = 40,
  liquidColor = '#81C784',
  isHeating = false,
  hasBubbles = false,
  temperature = 25
}) => {
  // Animation values
  const glowOpacity = useSharedValue(0);
  const glowScale = useSharedValue(1);

  // Bubble animations
  const bubble1Y = useSharedValue(0);
  const bubble2Y = useSharedValue(0);
  const bubble3Y = useSharedValue(0);
  const bubble4Y = useSharedValue(0);

  const bubble1Opacity = useSharedValue(0);
  const bubble2Opacity = useSharedValue(0);
  const bubble3Opacity = useSharedValue(0);
  const bubble4Opacity = useSharedValue(0);

  const level = size * 0.85 - (liquidLevel / 100) * size * 0.55;

  // Get liquid color based on heating/temperature
  const getActiveLiquidColor = () => {
    if (isHeating) {
      if (temperature > 80) return '#FFB74D'; // Hot orange
      if (temperature > 60) return '#FFA726'; // Warm orange
      return '#FF8A65'; // Light orange
    }
    return liquidColor;
  };

  const activeLiquidColor = getActiveLiquidColor();

  useEffect(() => {
    if (isHeating) {
      // Heating glow effect
      glowOpacity.value = withRepeat(
        withSequence(
          withTiming(0.2, { duration: 1000, easing: Easing.inOut(Easing.ease) }),
          withTiming(0.4, { duration: 1000, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      );
      glowScale.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 1000 }),
          withTiming(1.1, { duration: 1000 })
        ),
        -1,
        true
      );
    } else {
      glowOpacity.value = withTiming(0, { duration: 500 });
      glowScale.value = withTiming(1, { duration: 500 });
    }
  }, [isHeating]);

  useEffect(() => {
    if (hasBubbles) {
      // Float bubble animations with random movement
      bubble1Y.value = withRepeat(
        withSequence(
          withTiming(0, { duration: 0 }),
          withTiming(-40, { duration: 1500, easing: Easing.out(Easing.ease) })
        ),
        -1,
        false
      );
      bubble1Opacity.value = withRepeat(
        withSequence(
          withTiming(0, { duration: 0 }),
          withTiming(0.7, { duration: 200 }),
          withTiming(0.7, { duration: 1100 }),
          withTiming(0, { duration: 200 })
        ),
        -1,
        false
      );

      // Staggered bubble timings
      setTimeout(() => {
        bubble2Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-35, { duration: 1300, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble2Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 200 }),
            withTiming(0.7, { duration: 900 }),
            withTiming(0, { duration: 200 })
          ),
          -1,
          false
        );
      }, 300);

      setTimeout(() => {
        bubble3Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-42, { duration: 1800, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble3Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 200 }),
            withTiming(0.7, { duration: 1400 }),
            withTiming(0, { duration: 200 })
          ),
          -1,
          false
        );
      }, 600);

      setTimeout(() => {
        bubble4Y.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(-38, { duration: 1600, easing: Easing.out(Easing.ease) })
          ),
          -1,
          false
        );
        bubble4Opacity.value = withRepeat(
          withSequence(
            withTiming(0, { duration: 0 }),
            withTiming(0.7, { duration: 200 }),
            withTiming(0.7, { duration: 1200 }),
            withTiming(0, { duration: 200 })
          ),
          -1,
          false
        );
      }, 900);
    } else {
      // Stop bubble animations
      bubble1Y.value = withTiming(0, { duration: 300 });
      bubble2Y.value = withTiming(0, { duration: 300 });
      bubble3Y.value = withTiming(0, { duration: 300 });
      bubble4Y.value = withTiming(0, { duration: 300 });

      bubble1Opacity.value = withTiming(0, { duration: 300 });
      bubble2Opacity.value = withTiming(0, { duration: 300 });
      bubble3Opacity.value = withTiming(0, { duration: 300 });
      bubble4Opacity.value = withTiming(0, { duration: 300 });
    }
  }, [hasBubbles]);

  // Animated properties
  const glowProps = useAnimatedProps(() => ({
    opacity: glowOpacity.value,
    r: (size * 0.25 + size * 0.1) * glowScale.value
  }));

  const bubble1Props = useAnimatedProps(() => ({
    cy: size * (0.7 - (liquidLevel / 100) * 0.55) + bubble1Y.value,
    opacity: bubble1Opacity.value
  }));

  const bubble2Props = useAnimatedProps(() => ({
    cy: size * (0.7 - (liquidLevel / 100) * 0.55) + bubble2Y.value,
    opacity: bubble2Opacity.value
  }));

  const bubble3Props = useAnimatedProps(() => ({
    cy: size * (0.7 - (liquidLevel / 100) * 0.55) + bubble3Y.value,
    opacity: bubble3Opacity.value
  }));

  const bubble4Props = useAnimatedProps(() => ({
    cy: size * (0.7 - (liquidLevel / 100) * 0.55) + bubble4Y.value,
    opacity: bubble4Opacity.value
  }));

  return (
    <View style={{ width: size, height: size }}>
      <Svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <Defs>
          <LinearGradient id="flaskGlass" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#F5F5F5" stopOpacity="0.9" />
            <Stop offset="1" stopColor="#E0E0E0" stopOpacity="0.9" />
          </LinearGradient>

          <LinearGradient id="flaskLiquid" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor={activeLiquidColor} stopOpacity="0.8" />
            <Stop offset="1" stopColor={activeLiquidColor} stopOpacity="0.5" />
          </LinearGradient>

          <LinearGradient id="flaskNeck" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#E0E0E0" stopOpacity="0.8" />
            <Stop offset="1" stopColor="#BDBDBD" stopOpacity="0.8" />
          </LinearGradient>
        </Defs>

        {/* Heating glow effect */}
        {isHeating && (
          <AnimatedCircle
            cx={size * 0.5}
            cy={size * 0.85}
            fill="#FF9800"
            animatedProps={glowProps}
          />
        )}

        {/* Flask body */}
        <Path
          d={`
            M ${size * 0.5} ${size * 0.85}
            C ${size * 0.7} ${size * 0.85},
              ${size * 0.85} ${size * 0.3},
              ${size * 0.8} ${size * 0.2}
            C ${size * 0.75} ${size * 0.1},
              ${size * 0.65} 0,
              ${size * 0.5} 0
            C ${size * 0.35} 0,
              ${size * 0.25} ${size * 0.1},
              ${size * 0.2} ${size * 0.2}
            C ${size * 0.15} ${size * 0.3},
              ${size * 0.3} ${size * 0.85},
              ${size * 0.5} ${size * 0.85}
            Z
          `}
          fill="url(#flaskGlass)"
          stroke="#757575"
          strokeWidth="1"
        />

        {/* Liquid */}
        <Path
          d={`
            M ${size * 0.5} ${size * 0.85}
            C ${size * 0.7} ${size * 0.85},
              ${size * 0.85} ${level + size * 0.1},
              ${size * 0.8} ${level}
            C ${size * 0.75} ${level - size * 0.05},
              ${size * 0.65} ${level - size * 0.1},
              ${size * 0.5} ${level - size * 0.1}
            C ${size * 0.35} ${level - size * 0.1},
              ${size * 0.25} ${level - size * 0.05},
              ${size * 0.2} ${level}
            C ${size * 0.15} ${level + size * 0.1},
              ${size * 0.3} ${size * 0.85},
              ${size * 0.5} ${size * 0.85}
            Z
          `}
          fill="url(#flaskLiquid)"
        />

        {/* Flask neck */}
        <Path
          d={`
            M ${size * 0.4} ${size * 0.05}
            L ${size * 0.4} ${size * 0.2}
            C ${size * 0.4} ${size * 0.25}, ${size * 0.6} ${size * 0.25}, ${size * 0.6} ${size * 0.2}
            L ${size * 0.6} ${size * 0.05}
            C ${size * 0.6} 0, ${size * 0.4} 0, ${size * 0.4} ${size * 0.05}
            Z
          `}
          fill="url(#flaskNeck)"
          stroke="#757575"
          strokeWidth="1"
        />

        {/* Measurement markings */}
        <G stroke="#78909C" strokeWidth="0.5">
          {[20, 40, 60, 80].map(markLevel => (
            <Path
              key={markLevel}
              d={`
                M ${size * 0.35} ${size * 0.85 - (markLevel / 100) * size * 0.55}
                C ${size * 0.4} ${size * 0.84 - (markLevel / 100) * size * 0.55},
                  ${size * 0.6} ${size * 0.84 - (markLevel / 100) * size * 0.55},
                  ${size * 0.65} ${size * 0.85 - (markLevel / 100) * size * 0.55}
              `}
              fill="none"
              stroke="#78909C"
              strokeWidth="0.5"
            />
          ))}
        </G>

        {/* Bubbles */}
        {hasBubbles && (
          <G>
            <AnimatedCircle
              cx={size * (0.45 + Math.random() * 0.1)}
              r={size * 0.015}
              fill="#FFFFFF"
              animatedProps={bubble1Props}
            />
            <AnimatedCircle
              cx={size * (0.45 + Math.random() * 0.1)}
              r={size * 0.018}
              fill="#FFFFFF"
              animatedProps={bubble2Props}
            />
            <AnimatedCircle
              cx={size * (0.45 + Math.random() * 0.1)}
              r={size * 0.012}
              fill="#FFFFFF"
              animatedProps={bubble3Props}
            />
            <AnimatedCircle
              cx={size * (0.45 + Math.random() * 0.1)}
              r={size * 0.016}
              fill="#FFFFFF"
              animatedProps={bubble4Props}
            />
          </G>
        )}

        {/* Glass reflection */}
        <Path
          d={`
            M ${size * 0.22} ${size * 0.25}
            C ${size * 0.25} ${size * 0.15}, ${size * 0.3} ${size * 0.1}, ${size * 0.35} ${size * 0.15}
            L ${size * 0.32} ${size * 0.75}
            C ${size * 0.28} ${size * 0.7}, ${size * 0.24} ${size * 0.5}, ${size * 0.22} ${size * 0.25}
            Z
          `}
          fill="#FFFFFF"
          opacity={0.3}
        />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: index.ts ===
Path: lab\assets\index.ts
---- File Content Start ----
// src/data/animations/lab/assets/index.ts

// Basic Equipment
export { GraduatedCylinder } from './basic/GraduatedCylinder';
export { Pipette } from './basic/Pipette';
export { Funnel } from './basic/Funnel';
export { StirringRod } from './basic/StirringRod';
export { WatchGlass } from './basic/WatchGlass';
export { PetriDish } from './basic/PetriDish';

// Heating & Temperature
export { HotPlate } from './heating/HotPlate';
export { ThermometerStand } from './heating/ThermometerStand';
export { HeatingMantle } from './heating/HeatingMantle';
export { IceBath } from './heating/IceBath';

// Measurement & Analysis
export { BalanceScale } from './measurement/BalanceScale';
export { PHMeter } from './measurement/PHMeter';
export { LitmusPaper } from './measurement/LitmusPaper';
export { MeasuringSpoons } from './measurement/MeasuringSpoons';

// Safety Equipment
export { SafetyGoggles } from './safety/SafetyGoggles';
export { SafetyGloves } from './safety/SafetyGloves';
export { FumeHood } from './safety/FumeHood';
export { FireExtinguisher } from './safety/FireExtinguisher';
export { EmergencyShower } from './safety/EmergencyShower';

// Specialized Equipment
export { Microscope } from './specialized/Microscope';
export { MortarAndPestle } from './specialized/MortarAndPestle';
export { Tongs } from './specialized/Tongs';
export { RingStand } from './specialized/RingStand';
export { Condenser } from './specialized/Condenser';

// Enhanced Equipment (existing)
export { BunsenBurnerFromRepassets } from './enhanced/BunsenBurnerFromRepassets';
export { BeakerFromRepassets } from './enhanced/BeakerFromRepassets';
export { FlaskEnhanced } from './enhanced/FlaskEnhanced';
export { TestTubeRackEnhanced } from './enhanced/TestTubeRackEnhanced';

// Lab colors and utilities
export { LabColors } from './colors';

---- File Content End ----


=== File: TestTubeRackEnhanced.tsx ===
Path: lab\assets\TestTubeRackEnhanced.tsx
---- File Content Start ----
// src/data/animations/lab/assets/enhanced/TestTubeRackEnhanced.tsx

import React from 'react';
import { View } from 'react-native';
import Svg, {
  Rect,
  Path,
  Defs,
  LinearGradient,
  Stop,
  G
} from 'react-native-svg';

interface TubeContent {
  level: number; // 0-100
  color: string;
  label?: string;
}

interface TestTubeRackEnhancedProps {
  size?: number;
  tubeCount?: number;
  tubeContents?: TubeContent[];
  rackColor?: string;
}

export const TestTubeRackEnhanced: React.FC<TestTubeRackEnhancedProps> = ({
  size = 200,
  tubeCount = 3,
  tubeContents = [
    { level: 60, color: '#4FC3F7', label: 'H₂O' },
    { level: 40, color: '#81C784', label: 'NaCl' },
    { level: 80, color: '#FFF176', label: 'HCl' }
  ],
  rackColor = '#8D6E63'
}) => {
  const tubeWidth = size * 0.15;
  const tubeSpacing = size * 0.2;
  const rackHeight = size * 0.05;

  // Ensure we have content for all tubes
  const normalizedContents = Array.from({ length: tubeCount }, (_, index) =>
    tubeContents[index] || { level: 50, color: '#BDBDBD', label: 'Empty' }
  );

  return (
    <View style={{ width: size, height: size }}>
      <Svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <Defs>
          {/* Wood grain gradient for rack */}
          <LinearGradient id="rackGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#A1887F" />
            <Stop offset="0.3" stopColor="#8D6E63" />
            <Stop offset="0.7" stopColor="#6D4C41" />
            <Stop offset="1" stopColor="#5D4037" />
          </LinearGradient>

          {/* Glass gradient for tubes */}
          <LinearGradient id="glassGradient" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#F5F5F5" stopOpacity="0.9" />
            <Stop offset="0.5" stopColor="#FFFFFF" stopOpacity="0.7" />
            <Stop offset="1" stopColor="#E0E0E0" stopOpacity="0.9" />
          </LinearGradient>

          {/* Individual liquid gradients for each tube */}
          {normalizedContents.map((content, index) => (
            <LinearGradient
              key={`liquid-${index}`}
              id={`liquidGradient${index}`}
              x1="0"
              y1="0"
              x2="0"
              y2="1"
            >
              <Stop offset="0" stopColor={content.color} stopOpacity="0.9" />
              <Stop offset="1" stopColor={content.color} stopOpacity="0.6" />
            </LinearGradient>
          ))}
        </Defs>

        {/* Rack base */}
        <Rect
          x={size * 0.1}
          y={size * 0.8}
          width={size * 0.8}
          height={rackHeight}
          fill="url(#rackGradient)"
          rx={size * 0.01}
        />

        {/* Rack left side */}
        <Rect
          x={size * 0.1}
          y={size * 0.3}
          width={size * 0.05}
          height={size * 0.5}
          fill="url(#rackGradient)"
        />

        {/* Rack right side */}
        <Rect
          x={size * 0.85}
          y={size * 0.3}
          width={size * 0.05}
          height={size * 0.5}
          fill="url(#rackGradient)"
        />

        {/* Rack top with tube holes */}
        <Path
          d={`
            M ${size * 0.15} ${size * 0.3}
            L ${size * 0.85} ${size * 0.3}
            L ${size * 0.8} ${size * 0.35}
            L ${size * 0.2} ${size * 0.35}
            Z
          `}
          fill="url(#rackGradient)"
        />

        {/* Test tubes */}
        <G>
          {normalizedContents.map((content, index) => {
            const tubeX = size * 0.2 + index * tubeSpacing;
            const tubeBottomY = size * 0.85;
            const tubeTopY = size * 0.2;
            const tubeHeight = tubeBottomY - tubeTopY;
            const liquidHeight = (tubeHeight * content.level) / 100;

            return (
              <G key={index}>
                {/* Tube outline */}
                <Path
                  d={`
                    M ${tubeX} ${tubeBottomY}
                    L ${tubeX} ${tubeTopY + size * 0.02}
                    C ${tubeX} ${tubeTopY},
                      ${tubeX + tubeWidth} ${tubeTopY},
                      ${tubeX + tubeWidth} ${tubeTopY + size * 0.02}
                    L ${tubeX + tubeWidth} ${tubeBottomY}
                    C ${tubeX + tubeWidth} ${tubeBottomY + size * 0.02},
                      ${tubeX} ${tubeBottomY + size * 0.02},
                      ${tubeX} ${tubeBottomY}
                    Z
                  `}
                  fill="url(#glassGradient)"
                  stroke="#9E9E9E"
                  strokeWidth="1"
                />

                {/* Tube liquid */}
                {content.level > 0 && (
                  <Rect
                    x={tubeX + 1}
                    y={tubeBottomY - liquidHeight}
                    width={tubeWidth - 2}
                    height={liquidHeight}
                    fill={`url(#liquidGradient${index})`}
                    rx={1}
                  />
                )}

                {/* Tube top rim */}
                <Rect
                  x={tubeX - size * 0.01}
                  y={size * 0.15}
                  width={tubeWidth + size * 0.02}
                  height={size * 0.05}
                  fill="#E0E0E0"
                  rx={size * 0.01}
                />

                {/* Glass reflection highlight */}
                <Rect
                  x={tubeX + tubeWidth * 0.1}
                  y={tubeTopY + size * 0.03}
                  width={tubeWidth * 0.1}
                  height={tubeHeight - size * 0.04}
                  fill="#FFFFFF"
                  opacity={0.4}
                  rx={size * 0.005}
                />

                {/* Measurement marks on tube */}
                <G stroke="#B0BEC5" strokeWidth="0.3" opacity={0.7}>
                  {[25, 50, 75].map(mark => (
                    <Rect
                      key={mark}
                      x={tubeX + tubeWidth * 0.8}
                      y={tubeBottomY - (tubeHeight * mark) / 100}
                      width={tubeWidth * 0.15}
                      height="0.5"
                    />
                  ))}
                </G>
              </G>
            );
          })}
        </G>

        {/* Rack wood grain details */}
        <G stroke="#6D4C41" strokeWidth="0.5" opacity={0.6}>
          {/* Horizontal grain lines */}
          <Path d={`M ${size * 0.12} ${size * 0.82} L ${size * 0.88} ${size * 0.82}`} />
          <Path d={`M ${size * 0.12} ${size * 0.32} L ${size * 0.88} ${size * 0.32}`} />

          {/* Vertical grain lines */}
          <Path d={`M ${size * 0.125} ${size * 0.32} L ${size * 0.125} ${size * 0.8}`} />
          <Path d={`M ${size * 0.875} ${size * 0.32} L ${size * 0.875} ${size * 0.8}`} />
        </G>

        {/* Rack support details */}
        <G>
          {/* Corner brackets */}
          <Rect
            x={size * 0.14}
            y={size * 0.28}
            width={size * 0.03}
            height={size * 0.04}
            fill="#5D4037"
            rx={size * 0.005}
          />
          <Rect
            x={size * 0.83}
            y={size * 0.28}
            width={size * 0.03}
            height={size * 0.04}
            fill="#5D4037"
            rx={size * 0.005}
          />
        </G>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: Thermometer.tsx ===
Path: lab\assets\Thermometer.tsx
---- File Content Start ----
import React from 'react';
import Svg, {
  Rect,
  Circle,
  G,
  Line
} from 'react-native-svg';
import { LabColors } from './colors';

interface ThermometerProps {
  width: number;
  height: number;
  temperature: number;
}

export const ThermometerSVG: React.FC<ThermometerProps> = ({ width, height, temperature }) => {
  const mercuryLevel = Math.max(0, Math.min(1, (temperature - 0) / 100));

  return (
    <Svg width={width} height={height} viewBox="0 0 20 120">
      {/* Thermometer body */}
      <Rect
        x="6"
        y="15"
        width="8"
        height="85"
        rx="4"
        fill={LabColors.glass.clear}
        stroke={LabColors.glass.shadow}
        strokeWidth="1"
      />

      {/* Bulb */}
      <Circle
        cx="10"
        cy="105"
        r="7"
        fill={LabColors.glass.clear}
        stroke={LabColors.glass.shadow}
        strokeWidth="1"
      />

      {/* Mercury */}
      <Rect
        x="7"
        y={100 - mercuryLevel * 80}
        width="6"
        height={mercuryLevel * 80}
        rx="3"
        fill={temperature > 50 ? '#FF4444' : '#FF6666'}
      />

      {/* Mercury bulb */}
      <Circle
        cx="10"
        cy="105"
        r="5"
        fill={temperature > 50 ? '#FF4444' : '#FF6666'}
      />

      {/* Scale markings */}
      <G stroke={LabColors.glass.shadow} strokeWidth="0.3">
        <Line x1="15" y1="30" x2="18" y2="30" />
        <Line x1="15" y1="60" x2="18" y2="60" />
        <Line x1="15" y1="90" x2="18" y2="90" />
      </G>
    </Svg>
  );
};

---- File Content End ----


=== File: types.ts ===
Path: lab\assets\types.ts
---- File Content Start ----
// src/data/animations/lab/assets/types.ts

// Base interface for all lab equipment
export interface BaseEquipmentProps {
  width?: number;
  height?: number;
}

// Basic Equipment Props
export interface GraduatedCylinderProps extends BaseEquipmentProps {
  maxVolume?: number; // in mL
  liquidColor?: string;
  onVolumeChange?: (volume: number) => void;
}

export interface PipetteProps extends BaseEquipmentProps {
  liquidColor?: string;
  capacity?: number; // in mL
  onDispense?: (amount: number) => void;
}

export interface FunnelProps extends BaseEquipmentProps {
  liquidColor?: string;
}

export interface StirringRodProps extends BaseEquipmentProps {}

export interface WatchGlassProps extends BaseEquipmentProps {}

export interface PetriDishProps extends BaseEquipmentProps {}

// Heating & Temperature Equipment Props
export interface HotPlateProps extends BaseEquipmentProps {
  onTemperatureChange?: (temperature: number) => void;
  maxTemperature?: number;
}

export interface ThermometerStandProps extends BaseEquipmentProps {
  temperature?: number;
}

export interface HeatingMantleProps extends BaseEquipmentProps {}

export interface IceBathProps extends BaseEquipmentProps {}

// Measurement & Analysis Equipment Props
export interface BalanceScaleProps extends BaseEquipmentProps {
  onMassChange?: (leftMass: number, rightMass: number) => void;
  maxMass?: number;
}

export interface PHMeterProps extends BaseEquipmentProps {
  onPHChange?: (pH: number) => void;
}

export interface LitmusPaperProps extends BaseEquipmentProps {}

export interface MeasuringSpoonsProps extends BaseEquipmentProps {
  maxCapacity?: number;
}

// Safety Equipment Props
export interface SafetyGogglesProps extends BaseEquipmentProps {
  lensColor?: string;
  isWorn?: boolean;
}

export interface SafetyGlovesProps extends BaseEquipmentProps {}

export interface FumeHoodProps extends BaseEquipmentProps {}

export interface FireExtinguisherProps extends BaseEquipmentProps {}

export interface EmergencyShowerProps extends BaseEquipmentProps {}

// Specialized Equipment Props
export interface MicroscopeProps extends BaseEquipmentProps {
  onFocusChange?: (focus: number) => void;
  magnification?: number;
}

export interface MortarAndPestleProps extends BaseEquipmentProps {}

export interface TongsProps extends BaseEquipmentProps {}

export interface RingStandProps extends BaseEquipmentProps {}

export interface CondenserProps extends BaseEquipmentProps {}

// Enhanced Equipment Props (existing)
export interface BunsenBurnerFromRepassetsProps extends BaseEquipmentProps {
  size?: number;
  isActive?: boolean;
  intensity?: number;
  flameColor?: string;
}

export interface BeakerFromRepassetsProps extends BaseEquipmentProps {
  size?: number;
  liquidLevel?: number;
  liquidColor?: string;
  hasBubbles?: boolean;
  temperature?: number;
}

export interface FlaskEnhancedProps extends BaseEquipmentProps {
  size?: number;
  liquidLevel?: number;
  liquidColor?: string;
  isHeating?: boolean;
  hasBubbles?: boolean;
  temperature?: number;
}

export interface TestTubeRackEnhancedProps extends BaseEquipmentProps {
  size?: number;
  tubeCount?: number;
  tubeContents?: TubeContent[];
  rackColor?: string;
}

export interface TubeContent {
  level: number; // 0-100
  color: string;
  label?: string;
}

// Equipment categories for organization
export type EquipmentCategory =
  | 'basic'
  | 'heating'
  | 'measurement'
  | 'safety'
  | 'specialized'
  | 'enhanced';

export interface EquipmentInfo {
  name: string;
  category: EquipmentCategory;
  description: string;
  component: React.ComponentType<any>;
  icon?: string;
  difficulty?: 'beginner' | 'intermediate' | 'advanced';
  tags?: string[];
}

// Common animation states
export interface AnimationState {
  isActive: boolean;
  progress: number; // 0-1
  intensity?: number; // 0-1
}

// Common measurement units
export type VolumeUnit = 'mL' | 'L' | 'µL';
export type MassUnit = 'g' | 'kg' | 'mg';
export type TemperatureUnit = '°C' | '°F' | 'K';
export type LengthUnit = 'mm' | 'cm' | 'm';

// Equipment interaction types
export type InteractionType =
  | 'press'
  | 'longPress'
  | 'panHorizontal'
  | 'panVertical'
  | 'rotation'
  | 'pinch';

export interface InteractionConfig {
  type: InteractionType;
  sensitivity?: number;
  bounds?: {
    min: number;
    max: number;
  };
  hapticFeedback?: boolean;
}

// Lab safety levels
export type SafetyLevel = 'low' | 'medium' | 'high' | 'critical';

export interface SafetyInfo {
  level: SafetyLevel;
  warnings: string[];
  requiredEquipment: string[];
  procedures: string[];
}

---- File Content End ----


=== File: Funnel.tsx ===
Path: lab\assets\basic\Funnel.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/Funnel.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Path, Defs, LinearGradient, Stop } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);

interface FunnelProps {
  width?: number;
  height?: number;
  liquidColor?: string;
}

export const Funnel: React.FC<FunnelProps> = ({ width = 140, height = 180, liquidColor = '#2a9df4' }) => {
  const [pouring, setPouring] = useState(false);
  const pourOpacity = useSharedValue(0);

  const togglePour = () => {
    setPouring(!pouring);
    pourOpacity.value = withTiming(pouring ? 0 : 0.8, { duration: 500 });
  };

  const pourProps = useAnimatedProps(() => ({ opacity: pourOpacity.value }));

  return (
    <Pressable onPress={togglePour}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="funnelGradient" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#ffffff" stopOpacity="0.3" />
            <Stop offset="1" stopColor="#f0f0f0" stopOpacity="0.1" />
          </LinearGradient>
        </Defs>

        <Path d={`M20 20 L120 20 L80 100 L80 160 L60 180 L40 160 L40 100 Z`}
              fill="url(#funnelGradient)" stroke="#ccc" strokeWidth="2" />

        {pouring && (
          <AnimatedPath
            d={`M50 120 Q60 140, 70 120 Q80 150, 90 140 Q100 160, 110 150 L110 180 L50 180 Z`}
            fill={liquidColor}
            animatedProps={pourProps}
          />
        )}
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: GraduatedCylinder.tsx ===
Path: lab\assets\basic\GraduatedCylinder.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/GraduatedCylinder.tsx

import React, { useState } from 'react';
import { PanResponder, View } from 'react-native';
import Svg, { Rect, Line, Path, Defs, LinearGradient, Stop, Text } from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming
} from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);
const AnimatedPath = Animated.createAnimatedComponent(Path);

interface GraduatedCylinderProps {
  width?: number;
  height?: number;
  maxVolume?: number; // in mL
  liquidColor?: string;
  onVolumeChange?: (volume: number) => void;
}

export const GraduatedCylinder: React.FC<GraduatedCylinderProps> = ({
  width = 120,
  height = 200,
  maxVolume = 100,
  liquidColor = '#2a9df4',
  onVolumeChange
}) => {
  const [volume, setVolume] = useState(50); // 0-maxVolume scale
  const liquidHeight = useSharedValue(height * 0.75 * 0.5); // Start at 50%

  const updateVolume = (newVolume: number) => {
    newVolume = Math.min(maxVolume, Math.max(0, newVolume));
    const heightPercent = newVolume / maxVolume;
    liquidHeight.value = withTiming(height * 0.75 * heightPercent, { duration: 500 });
    setVolume(newVolume);
    onVolumeChange?.(newVolume);
  };

  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updateVolume(volume + gesture.dy / -2);
    }
  });

  const liquidProps = useAnimatedProps(() => ({
    y: height * 0.9 - liquidHeight.value,
    height: liquidHeight.value
  }));

  const meniscusProps = useAnimatedProps(() => ({
    d: `M${width * 0.25 + 1} ${height * 0.9 - liquidHeight.value}
        C${width * 0.35} ${height * 0.9 - liquidHeight.value - 4},
        ${width * 0.65} ${height * 0.9 - liquidHeight.value - 4},
        ${width * 0.75 - 1} ${height * 0.9 - liquidHeight.value}`
  }));

  const cylinderWidth = width * 0.5;
  const cylinderX = width * 0.25;

  return (
    <View {...panResponder.panHandlers} style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <LinearGradient id="liquidGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor={liquidColor} stopOpacity="0.8" />
            <Stop offset="1" stopColor={liquidColor} stopOpacity="0.9" />
          </LinearGradient>

          <LinearGradient id="glassGradient" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#ffffff" stopOpacity="0.3" />
            <Stop offset="0.1" stopColor="#f0f0f0" stopOpacity="0.1" />
            <Stop offset="0.9" stopColor="#f0f0f0" stopOpacity="0.1" />
            <Stop offset="1" stopColor="#ffffff" stopOpacity="0.3" />
          </LinearGradient>
        </Defs>

        {/* Glass cylinder */}
        <Rect
          x={cylinderX}
          y={height * 0.15}
          width={cylinderWidth}
          height={height * 0.75}
          rx="5"
          fill="url(#glassGradient)"
          stroke="#aaa"
          strokeWidth="1"
        />

        {/* Spout */}
        <Path
          d={`M${cylinderX + cylinderWidth} ${height * 0.25}
              L${cylinderX + cylinderWidth + 15} ${height * 0.22}
              L${cylinderX + cylinderWidth + 15} ${height * 0.28}
              Z`}
          fill="#e0e0e0"
          stroke="#aaa"
        />

        {/* Measurement markings */}
        {Array.from({ length: 11 }, (_, i) => {
          const markY = height * 0.15 + (i * height * 0.75) / 10;
          const markValue = maxVolume - (i * maxVolume) / 10;
          const isMainMark = i % 2 === 0;

          return (
            <React.Fragment key={i}>
              <Line
                x1={cylinderX - (isMainMark ? 8 : 5)}
                y1={markY}
                x2={cylinderX + cylinderWidth + (isMainMark ? 8 : 5)}
                y2={markY}
                stroke="#555"
                strokeWidth={isMainMark ? 1.5 : 0.8}
              />
              {isMainMark && (
                <Text
                  x={cylinderX - 12}
                  y={markY + 3}
                  fontSize="8"
                  fill="#333"
                  textAnchor="end"
                >
                  {markValue}
                </Text>
              )}
            </React.Fragment>
          );
        })}

        {/* Liquid */}
        <AnimatedRect
          x={cylinderX + 1}
          width={cylinderWidth - 2}
          fill="url(#liquidGradient)"
          rx="4"
          animatedProps={liquidProps}
        />

        {/* Meniscus curve */}
        <AnimatedPath
          fill={liquidColor}
          opacity="0.9"
          animatedProps={meniscusProps}
        />

        {/* Volume label */}
        <Text
          x={width / 2}
          y={height * 0.05}
          fontSize="12"
          fill="#333"
          textAnchor="middle"
          fontWeight="bold"
        >
          {volume.toFixed(1)} mL
        </Text>

        {/* Base */}
        <Rect
          x={cylinderX - 5}
          y={height * 0.9}
          width={cylinderWidth + 10}
          height={height * 0.05}
          rx="3"
          fill="#666"
        />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: PetriDish.tsx ===
Path: lab\assets\basic\PetriDish.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/PetriDish.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Circle, G } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface PetriDishProps {
  width?: number;
  height?: number;
}

export const PetriDish: React.FC<PetriDishProps> = ({ width = 150, height = 150 }) => {
  const [growing, setGrowing] = useState(false);
  const crystalSize = useSharedValue(5);

  const growCrystals = () => {
    crystalSize.value = withTiming(20, { duration: 2000 });
    setGrowing(true);
  };

  const crystalProps = useAnimatedProps(() => ({ r: crystalSize.value }));

  return (
    <Pressable onPress={growCrystals}>
      <Svg width={width} height={height}>
        <Circle cx="75" cy="75" r="60" fill="#f0f0f0" stroke="#ccc" />

        {growing && (
          <G>
            <AnimatedCircle cx="60" cy="60" fill="#a5d8ff" animatedProps={crystalProps} />
            <AnimatedCircle cx="90" cy="70" fill="#a5d8ff" animatedProps={crystalProps} />
            <AnimatedCircle cx="70" cy="90" fill="#a5d8ff" animatedProps={crystalProps} />
          </G>
        )}

        <Circle cx="75" cy="75" r="55" fill="none" stroke="#aaa" strokeDasharray="5,5" />
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: Pipette.tsx ===
Path: lab\assets\basic\Pipette.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/Pipette.tsx

import React, { useState, useEffect } from 'react';
import { Pressable, View } from 'react-native';
import Svg, {
  Path,
  Rect,
  Circle,
  Defs,
  LinearGradient,
  Stop,
  G
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withSequence,
  withDelay,
  Easing
} from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedRect = Animated.createAnimatedComponent(Rect);

interface PipetteProps {
  width?: number;
  height?: number;
  liquidColor?: string;
  capacity?: number; // in mL
  onDispense?: (amount: number) => void;
}

export const Pipette: React.FC<PipetteProps> = ({
  width = 60,
  height = 180,
  liquidColor = '#2a9df4',
  capacity = 10,
  onDispense
}) => {
  const [isDispensing, setIsDispensing] = useState(false);
  const [liquidLevel, setLiquidLevel] = useState(0.7); // 0-1 scale

  const bulbScale = useSharedValue(1);
  const liquidHeight = useSharedValue(height * 0.4);
  const dropOpacity = useSharedValue(0);
  const dropY = useSharedValue(0);

  const startDispensing = () => {
    if (liquidLevel <= 0) return;

    setIsDispensing(true);

    // Squeeze bulb animation
    bulbScale.value = withSequence(
      withTiming(0.8, { duration: 200 }),
      withTiming(1, { duration: 300 })
    );

    // Liquid level decreases
    const newLevel = Math.max(0, liquidLevel - 0.2);
    setLiquidLevel(newLevel);
    liquidHeight.value = withTiming(height * 0.4 * newLevel, { duration: 500 });

    // Drop animation
    dropOpacity.value = withSequence(
      withDelay(200, withTiming(1, { duration: 100 })),
      withTiming(1, { duration: 800 }),
      withTiming(0, { duration: 200 })
    );

    dropY.value = withSequence(
      withTiming(0, { duration: 200 }),
      withTiming(30, {
        duration: 1000,
        easing: Easing.out(Easing.quad)
      }),
      withTiming(0, { duration: 0 })
    );

    onDispense?.(capacity * 0.2);

    setTimeout(() => setIsDispensing(false), 1200);
  };

  const refill = () => {
    setLiquidLevel(0.8);
    liquidHeight.value = withTiming(height * 0.4 * 0.8, { duration: 800 });
  };

  const bulbProps = useAnimatedProps(() => ({
    transform: [{ scale: bulbScale.value }]
  }));

  const liquidProps = useAnimatedProps(() => ({
    y: height * 0.85 - liquidHeight.value,
    height: liquidHeight.value
  }));

  const dropProps = useAnimatedProps(() => ({
    opacity: dropOpacity.value,
    transform: [{ translateY: dropY.value }]
  }));

  const centerX = width / 2;
  const bulbRadius = width * 0.35;

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <LinearGradient id="bulbGradient" x1="0" y1="0" x2="1" y2="1">
            <Stop offset="0" stopColor="#f8f8f8" />
            <Stop offset="0.3" stopColor="#e8f8ff" />
            <Stop offset="1" stopColor="#d4f1f9" />
          </LinearGradient>

          <LinearGradient id="tubeGradient" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#ffffff" stopOpacity="0.3" />
            <Stop offset="0.5" stopColor="#e0f7ff" stopOpacity="0.1" />
            <Stop offset="1" stopColor="#ffffff" stopOpacity="0.3" />
          </LinearGradient>

          <LinearGradient id="liquidGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor={liquidColor} stopOpacity="0.8" />
            <Stop offset="1" stopColor={liquidColor} stopOpacity="0.9" />
          </LinearGradient>
        </Defs>

        {/* Rubber bulb */}
        <Pressable onPress={startDispensing}>
          <AnimatedPath
            d={`M${centerX} ${bulbRadius + 5}
                C${centerX - bulbRadius} ${bulbRadius + 5},
                ${centerX - bulbRadius} ${bulbRadius * 2 + 15},
                ${centerX} ${bulbRadius * 2 + 20}
                C${centerX + bulbRadius} ${bulbRadius * 2 + 15},
                ${centerX + bulbRadius} ${bulbRadius + 5},
                ${centerX} ${bulbRadius + 5} Z`}
            fill={isDispensing ? "#d0e8f0" : "url(#bulbGradient)"}
            stroke="#b0d0e0"
            strokeWidth="1"
            animatedProps={bulbProps}
          />
        </Pressable>

        {/* Bulb texture lines */}
        <G>
          {Array.from({ length: 4 }, (_, i) => (
            <Path
              key={i}
              d={`M${centerX - bulbRadius + 5 + i * 8} ${bulbRadius + 10}
                  Q${centerX} ${bulbRadius + 5},
                  ${centerX + bulbRadius - 5 - i * 8} ${bulbRadius + 10}`}
              stroke="#c0d8e8"
              strokeWidth="0.5"
              fill="none"
            />
          ))}
        </G>

        {/* Glass tube */}
        <Rect
          x={centerX - 3}
          y={bulbRadius * 2 + 20}
          width="6"
          height={height - bulbRadius * 2 - 30}
          fill="url(#tubeGradient)"
          stroke="#c0e8ff"
          strokeWidth="1"
          rx="3"
        />

        {/* Liquid in tube */}
        <AnimatedRect
          x={centerX - 2.5}
          width="5"
          fill="url(#liquidGradient)"
          rx="2.5"
          animatedProps={liquidProps}
        />

        {/* Volume markings */}
        {Array.from({ length: 6 }, (_, i) => {
          const markY = bulbRadius * 2 + 30 + (i * (height - bulbRadius * 2 - 40)) / 5;
          const volume = capacity - (i * capacity) / 5;

          return (
            <G key={i}>
              <Rect
                x={centerX + 3}
                y={markY}
                width="4"
                height="1"
                fill="#666"
              />
              {i % 2 === 0 && (
                <text
                  x={centerX + 10}
                  y={markY + 2}
                  fontSize="6"
                  fill="#666"
                >
                  {volume.toFixed(1)}
                </text>
              )}
            </G>
          );
        })}

        {/* Tip */}
        <Path
          d={`M${centerX - 3} ${height - 10}
              L${centerX + 3} ${height - 10}
              L${centerX + 1} ${height - 2}
              L${centerX - 1} ${height - 2} Z`}
          fill="#e0f0ff"
          stroke="#c0e8ff"
        />

        {/* Dispensing drop */}
        <AnimatedPath
          d={`M${centerX} ${height - 2}
              Q${centerX + 3} ${height + 2}, ${centerX + 2} ${height + 8}
              Q${centerX} ${height + 12}, ${centerX - 2} ${height + 8}
              Q${centerX - 3} ${height + 2}, ${centerX} ${height - 2} Z`}
          fill={liquidColor}
          animatedProps={dropProps}
        />

        {/* Volume display */}
        <Rect
          x={5}
          y={10}
          width={width - 10}
          height="20"
          fill="#000"
          stroke="#333"
          rx="3"
        />

        <text
          x={centerX}
          y={22}
          fontSize="8"
          fill="#0f0"
          textAnchor="middle"
          fontFamily="monospace"
        >
          {(liquidLevel * capacity).toFixed(1)}mL
        </text>

        {/* Refill button (long press area) */}
        <Pressable onLongPress={refill}>
          <Circle
            cx={width - 12}
            cy={height - 25}
            r="8"
            fill="#4CAF50"
            stroke="#2E7D32"
            strokeWidth="1"
          />
          <text
            x={width - 12}
            y={height - 22}
            fontSize="6"
            fill="white"
            textAnchor="middle"
          >
            ↻
          </text>
        </Pressable>

        {/* Instructions */}
        <text
          x={centerX}
          y={height - 5}
          fontSize="6"
          fill="#666"
          textAnchor="middle"
        >
          Tap to dispense | Hold ↻ to refill
        </text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: StirringRod.tsx ===
Path: lab\assets\basic\StirringRod.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/StirringRod.tsx
import React from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedStyle, withRepeat, withTiming } from 'react-native-reanimated';

interface StirringRodProps {
  width?: number;
  height?: number;
}

export const StirringRod: React.FC<StirringRodProps> = ({ width = 10, height = 200 }) => {
  const rotation = useSharedValue(0);

  const animateStirring = () => {
    rotation.value = withRepeat(withTiming(360, { duration: 1000 }), -1, false);
  };

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }]
  }));

  return (
    <Pressable onPress={animateStirring}>
      <Animated.View style={[animatedStyle, { height }]}>
        <Svg width={width} height={height}>
          <Rect width={width} height={height} rx="5" fill="#d3d3d3" />
        </Svg>
      </Animated.View>
    </Pressable>
  );
};

---- File Content End ----


=== File: WatchGlass.tsx ===
Path: lab\assets\basic\WatchGlass.tsx
---- File Content Start ----
// src/data/animations/lab/assets/basic/WatchGlass.tsx
import React from 'react';
import { View } from 'react-native';
import Svg, { Path, Defs, LinearGradient, Stop } from 'react-native-svg';

interface WatchGlassProps {
  width?: number;
  height?: number;
}

export const WatchGlass: React.FC<WatchGlassProps> = ({ width = 150, height = 100 }) => {
  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="glassReflection" x1="0" y1="0" x2="1" y2="1">
            <Stop offset="0" stopColor="white" stopOpacity="0.5"/>
            <Stop offset="1" stopColor="transparent"/>
          </LinearGradient>
        </Defs>

        <Path d="M20 40 Q75 5, 130 40 Q75 80, 20 40 Z"
              fill="#f8f8f8" stroke="#ddd" strokeWidth="1" />
        <Path d="M40 35 Q75 15, 110 35"
              fill="url(#glassReflection)" opacity="0.7" />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: HeatingMantle.tsx ===
Path: lab\assets\heating\HeatingMantle.tsx
---- File Content Start ----
// src/data/animations/lab/assets/heating/HeatingMantle.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Path, Defs, RadialGradient, Stop, G, Circle, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming, withRepeat, withSequence } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

interface HeatingMantleProps {
  width?: number;
  height?: number;
}

export const HeatingMantle: React.FC<HeatingMantleProps> = ({ width = 180, height = 200 }) => {
  const [isOn, setIsOn] = useState(false);
  const glowIntensity = useSharedValue(0);
  const pulse = useSharedValue(0);

  const toggleMantle = () => {
    setIsOn(prev => {
      if (!prev) {
        glowIntensity.value = withTiming(1, { duration: 1000 });
        pulse.value = withRepeat(
          withSequence(
            withTiming(0.8, { duration: 1500 }),
            withTiming(1, { duration: 1500 })
          ), -1, true
        );
      } else {
        glowIntensity.value = withTiming(0, { duration: 500 });
        pulse.value = 0;
      }
      return !prev;
    });
  };

  const mantleProps = useAnimatedProps(() => ({
    fill: isOn ? '#ff6600' : '#555555'
  }));

  const glowProps = useAnimatedProps(() => ({
    opacity: pulse.value * glowIntensity.value
  }));

  return (
    <Pressable onPress={toggleMantle}>
      <Svg width={width} height={height}>
        <Defs>
          <RadialGradient id="mantleGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#ffaa00" stopOpacity="0.8" />
            <Stop offset="100%" stopColor="#ff5500" stopOpacity="0" />
          </RadialGradient>
        </Defs>

        {/* Flask outline (optional) */}
        <Path d="M90 40 Q100 30, 110 40 Q115 100, 110 160 Q100 180, 90 180 Q80 180, 70 160 Q65 100, 70 40 Q80 30, 90 40 Z"
              fill="#aaccff55" />

        {/* Heating mantle */}
        <AnimatedPath
          d="M85 50 Q95 40, 105 50 Q110 90, 105 150 Q95 170, 85 170 Q75 170, 65 150 Q60 90, 65 50 Q75 40, 85 50 Z"
          stroke="#333" strokeWidth="2"
          animatedProps={mantleProps}
        />

        {/* Glow effect */}
        {isOn && (
          <AnimatedG animatedProps={glowProps}>
            <Circle cx="90" cy="100" r="50" fill="url(#mantleGlow)" />
          </AnimatedG>
        )}

        {/* Controls */}
        <Rect x="120" y="170" width="30" height="20" rx="5" fill="#333" />
        <Circle cx="135" cy="180" r="6" fill={isOn ? "#0f0" : "#f00"} />
        <Text x="155" y="185" fontSize="8" fill="#333">{isOn ? "ON" : "OFF"}</Text>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: HotPlate.tsx ===
Path: lab\assets\heating\HotPlate.tsx
---- File Content Start ----
// src/data/animations/lab/assets/heating/HotPlate.tsx

import React, { useState, useEffect } from 'react';
import { PanResponder, View } from 'react-native';
import Svg, {
  Rect,
  Circle,
  Path,
  Defs,
  RadialGradient,
  Stop,
  Text,
  G
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withRepeat,
  withSequence,
  interpolateColor,
  Easing
} from 'react-native-reanimated';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

interface HotPlateProps {
  width?: number;
  height?: number;
  onTemperatureChange?: (temperature: number) => void;
  maxTemperature?: number;
}

export const HotPlate: React.FC<HotPlateProps> = ({
  width = 200,
  height = 200,
  onTemperatureChange,
  maxTemperature = 500
}) => {
  const [temperature, setTemperature] = useState(25); // Room temperature start
  const plateHeat = useSharedValue(0); // 0-1 scale
  const heatWaveOpacity = useSharedValue(0);
  const glowIntensity = useSharedValue(0);

  const updateTemperature = (newTemp: number) => {
    newTemp = Math.min(maxTemperature, Math.max(25, newTemp));
    const heatLevel = (newTemp - 25) / (maxTemperature - 25);

    plateHeat.value = withTiming(heatLevel, { duration: 1000 });
    heatWaveOpacity.value = withTiming(heatLevel > 0.3 ? heatLevel : 0, { duration: 500 });
    glowIntensity.value = withTiming(heatLevel, { duration: 800 });

    setTemperature(newTemp);
    onTemperatureChange?.(newTemp);
  };

  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updateTemperature(temperature + gesture.dy / -2);
    }
  });

  useEffect(() => {
    if (temperature > 100) {
      // Add heat wave animation for high temperatures
      heatWaveOpacity.value = withRepeat(
        withSequence(
          withTiming(0.6, { duration: 1000, easing: Easing.inOut(Easing.ease) }),
          withTiming(0.8, { duration: 1000, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      );
    }
  }, [temperature]);

  const plateProps = useAnimatedProps(() => ({
    fill: interpolateColor(
      plateHeat.value,
      [0, 0.3, 0.6, 1],
      ['#cccccc', '#ff9900', '#ff6600', '#ff3300']
    )
  }));

  const glowProps = useAnimatedProps(() => ({
    opacity: glowIntensity.value * 0.5
  }));

  const heatWaveProps = useAnimatedProps(() => ({
    opacity: heatWaveOpacity.value
  }));

  const plateRadius = Math.min(width, height) * 0.3;
  const centerX = width / 2;
  const centerY = height * 0.45;

  return (
    <View {...panResponder.panHandlers} style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <RadialGradient id="plateGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#ffffff" stopOpacity="0.8" />
            <Stop offset="70%" stopColor="#ff5500" stopOpacity="0.3" />
            <Stop offset="100%" stopColor="#ff5500" stopOpacity="0" />
          </RadialGradient>

          <RadialGradient id="plateGradient" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#f0f0f0" />
            <Stop offset="100%" stopColor="#cccccc" />
          </RadialGradient>
        </Defs>

        {/* Base unit */}
        <Rect
          x={width * 0.1}
          y={height * 0.7}
          width={width * 0.8}
          height={height * 0.25}
          rx="8"
          fill="#666"
        />

        {/* Heating plate glow effect */}
        <AnimatedCircle
          cx={centerX}
          cy={centerY}
          r={plateRadius + 20}
          fill="url(#plateGlow)"
          animatedProps={glowProps}
        />

        {/* Main heating plate */}
        <AnimatedCircle
          cx={centerX}
          cy={centerY}
          r={plateRadius}
          stroke="#444"
          strokeWidth="2"
          animatedProps={plateProps}
        />

        {/* Heating coils */}
        <Circle
          cx={centerX}
          cy={centerY}
          r={plateRadius * 0.7}
          fill="none"
          stroke="#333"
          strokeWidth="2"
          strokeDasharray="10,5"
        />
        <Circle
          cx={centerX}
          cy={centerY}
          r={plateRadius * 0.4}
          fill="none"
          stroke="#333"
          strokeWidth="2"
          strokeDasharray="8,4"
        />

        {/* Heat waves when hot */}
        <AnimatedG animatedProps={heatWaveProps}>
          <Path
            d={`M${centerX - 40} ${centerY - 30}
                Q${centerX - 20} ${centerY - 40}, ${centerX} ${centerY - 30}
                Q${centerX + 20} ${centerY - 20}, ${centerX + 40} ${centerY - 30}`}
            stroke="#ffaa00"
            strokeWidth="2"
            fill="none"
            opacity="0.8"
          />
          <Path
            d={`M${centerX - 50} ${centerY - 50}
                Q${centerX - 25} ${centerY - 60}, ${centerX} ${centerY - 50}
                Q${centerX + 25} ${centerY - 40}, ${centerX + 50} ${centerY - 50}`}
            stroke="#ff7700"
            strokeWidth="2"
            fill="none"
            opacity="0.6"
          />
          <Path
            d={`M${centerX - 30} ${centerY - 70}
                Q${centerX - 15} ${centerY - 80}, ${centerX} ${centerY - 70}
                Q${centerX + 15} ${centerY - 60}, ${centerX + 30} ${centerY - 70}`}
            stroke="#ff5500"
            strokeWidth="2"
            fill="none"
            opacity="0.7"
          />
        </AnimatedG>

        {/* Temperature control panel */}
        <Rect
          x={width * 0.15}
          y={height * 0.78}
          width={width * 0.7}
          height={height * 0.08}
          rx="4"
          fill="#333"
        />

        {/* Temperature indicator bar */}
        <Rect
          x={width * 0.17}
          y={height * 0.8}
          width={(width * 0.66) * ((temperature - 25) / (maxTemperature - 25))}
          height={height * 0.04}
          rx="2"
          fill={temperature > 300 ? "#ff3300" : temperature > 150 ? "#ff6600" : "#ff9900"}
        />

        {/* Digital display */}
        <Rect
          x={width * 0.35}
          y={height * 0.15}
          width={width * 0.3}
          height={height * 0.12}
          rx="3"
          fill="#000"
          stroke="#555"
        />

        {/* Temperature reading */}
        <Text
          x={centerX}
          y={height * 0.23}
          fontSize="14"
          fill="#0f0"
          textAnchor="middle"
          fontFamily="monospace"
        >
          {Math.round(temperature)}°C
        </Text>

        {/* Control knob */}
        <Circle
          cx={width * 0.85}
          cy={height * 0.82}
          r="12"
          fill="#555"
          stroke="#777"
          strokeWidth="2"
        />
        <Circle
          cx={width * 0.85}
          cy={height * 0.82}
          r="8"
          fill="#777"
        />
        <Rect
          x={width * 0.85 - 1}
          y={height * 0.82 - 10}
          width="2"
          height="8"
          fill="#bbb"
        />

        {/* ON/OFF indicator */}
        <Circle
          cx={width * 0.15}
          cy={height * 0.82}
          r="6"
          fill={temperature > 25 ? "#0f0" : "#f00"}
        />
        <Text
          x={width * 0.15}
          y={height * 0.95}
          fontSize="8"
          fill="#333"
          textAnchor="middle"
        >
          {temperature > 25 ? "ON" : "OFF"}
        </Text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: IceBath.tsx ===
Path: lab\assets\heating\IceBath.tsx
---- File Content Start ----
// src/data/animations/lab/assets/heating/IceBath.tsx
import React, { useEffect } from 'react';
import { View } from 'react-native';
import Svg, { Rect, Circle, Path, Defs, ClipPath, LinearGradient, Stop } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming, Easing } from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface IceBathProps {
  width?: number;
  height?: number;
}

export const IceBath: React.FC<IceBathProps> = ({ width = 200, height = 200 }) => {
  const y1 = useSharedValue(0);
  const y2 = useSharedValue(0);
  const y3 = useSharedValue(0);
  const rotate = useSharedValue(0);
  const drop1 = useSharedValue(0);
  const drop2 = useSharedValue(0);
  const drop3 = useSharedValue(0);

  useEffect(() => {
    // Ice cubes floating animation
    y1.value = withRepeat(withTiming(10, { duration: 3000, easing: Easing.inOut(Easing.ease) }), -1, true);
    y2.value = withRepeat(withTiming(10, { duration: 3500, easing: Easing.inOut(Easing.ease) }), -1, true);
    y3.value = withRepeat(withTiming(10, { duration: 4000, easing: Easing.inOut(Easing.ease) }), -1, true);

    rotate.value = withRepeat(withTiming(10, { duration: 10000, easing: Easing.linear }), -1, true);

    // Condensation drops
    drop1.value = withRepeat(withTiming(1, { duration: 5000 }), -1, false);
    drop2.value = withRepeat(withTiming(1, { duration: 7000 }), -1, false);
    drop3.value = withRepeat(withTiming(1, { duration: 6000 }), -1, false);
  }, []);

  const ice1Props = useAnimatedProps(() => ({ y: 80 + y1.value, rotation: rotate.value }));
  const ice2Props = useAnimatedProps(() => ({ y: 100 + y2.value, rotation: rotate.value }));
  const ice3Props = useAnimatedProps(() => ({ y: 70 + y3.value, rotation: rotate.value }));

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="waterGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#a5d8ff" />
            <Stop offset="1" stopColor="#4da6ff" />
          </LinearGradient>
          <ClipPath id="bathClip">
            <Rect x="40" y="50" width="120" height="120" rx="5" />
          </ClipPath>
        </Defs>

        {/* Bath container */}
        <Rect x="40" y="50" width="120" height="120" rx="5" fill="#e0f7ff" stroke="#aaa" />

        {/* Water */}
        <Rect x="40" y="80" width="120" height="90" fill="url(#waterGradient)" clipPath="url(#bathClip)" />

        {/* Floating ice cubes */}
        <AnimatedRect x="60" width="20" height="20" rx="3" fill="#e6f7ff" stroke="#99d6ff" animatedProps={ice1Props} />
        <AnimatedRect x="100" width="20" height="20" rx="3" fill="#e6f7ff" stroke="#99d6ff" animatedProps={ice2Props} />
        <AnimatedRect x="140" width="20" height="20" rx="3" fill="#e6f7ff" stroke="#99d6ff" animatedProps={ice3Props} />

        {/* Condensation drops */}
        <AnimatedCircle cx="45" cy="60" r="3" fill="#aaa" opacity={drop1} />
        <AnimatedCircle cx="65" cy="55" r="2" fill="#aaa" opacity={drop2} />
        <AnimatedCircle cx="55" cy="65" r="3" fill="#aaa" opacity={drop3} />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: ThermometerStand.tsx ===
Path: lab\assets\heating\ThermometerStand.tsx
---- File Content Start ----
// src/data/animations/lab/assets/heating/ThermometerStand.tsx
import React, { useState } from 'react';
import { View } from 'react-native';
import Svg, { Rect, Path, Circle, Defs, LinearGradient, Stop, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming, withSequence, withRepeat } from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);
const AnimatedG = Animated.createAnimatedComponent(G);

interface ThermometerStandProps {
  width?: number;
  height?: number;
  temperature?: number;
}

export const ThermometerStand: React.FC<ThermometerStandProps> = ({
  width = 150,
  height = 250,
  temperature = 25
}) => {
  const mercuryHeight = useSharedValue(50);
  const shake = useSharedValue(0);

  const updateTemp = (newTemp: number) => {
    newTemp = Math.min(100, Math.max(-10, newTemp));
    mercuryHeight.value = withTiming(20 + (newTemp/100)*80, { duration: 1000 });

    shake.value = withSequence(
      withTiming(5, { duration: 100 }),
      withRepeat(withTiming(-5, { duration: 100 }), 3, true),
      withTiming(0, { duration: 100 })
    );
  };

  const mercuryProps = useAnimatedProps(() => ({
    y: height * 0.8 - mercuryHeight.value,
    height: mercuryHeight.value
  }));

  const shakeProps = useAnimatedProps(() => ({
    transform: [{ translateX: shake.value }]
  }));

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="mercuryGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#ff3300" />
            <Stop offset="1" stopColor="#cc0000" />
          </LinearGradient>
        </Defs>

        {/* Stand base */}
        <Rect x="60" y={height * 0.9} width="30" height="10" fill="#555" rx="2" />

        {/* Stand rod */}
        <Rect x="70" y={height * 0.4} width="10" height={height * 0.5} fill="#777" />

        {/* Clamp */}
        <Rect x="60" y={height * 0.36} width="30" height="15" fill="#999" rx="3" />

        {/* Thermometer */}
        <AnimatedG animatedProps={shakeProps}>
          <Rect x="68" y={height * 0.2} width="14" height={height * 0.6} rx="7"
                fill="#e0e0e0" stroke="#999" />
          <Circle cx="75" cy={height * 0.8} r="8" fill="#e0e0e0" stroke="#999" />

          {/* Mercury */}
          <AnimatedRect
            x="70"
            width="10"
            rx="5"
            fill="url(#mercuryGradient)"
            animatedProps={mercuryProps}
          />
        </AnimatedG>

        {/* Temperature scale */}
        {Array.from({ length: 6 }, (_, i) => (
          <Text key={i} x="90" y={height * 0.25 + i * height * 0.1} fontSize="8" fill="#333">
            {100 - i * 20}°
          </Text>
        ))}
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: BalanceScale.tsx ===
Path: lab\assets\measurement\BalanceScale.tsx
---- File Content Start ----
// src/data/animations/lab/assets/measurement/BalanceScale.tsx

import React, { useState } from 'react';
import { View, PanResponder } from 'react-native';
import Svg, {
  Rect,
  Circle,
  Line,
  Path,
  G,
  Text,
  Defs,
  LinearGradient,
  Stop
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withSpring
} from 'react-native-reanimated';

const AnimatedG = Animated.createAnimatedComponent(G);
const AnimatedPath = Animated.createAnimatedComponent(Path);

interface BalanceScaleProps {
  width?: number;
  height?: number;
  onMassChange?: (leftMass: number, rightMass: number) => void;
  maxMass?: number;
}

export const BalanceScale: React.FC<BalanceScaleProps> = ({
  width = 300,
  height = 250,
  onMassChange,
  maxMass = 100
}) => {
  const [leftMass, setLeftMass] = useState(0);
  const [rightMass, setRightMass] = useState(0);
  const [dragMode, setDragMode] = useState<'left' | 'right' | null>(null);

  const beamRotation = useSharedValue(0);
  const leftPanY = useSharedValue(0);
  const rightPanY = useSharedValue(0);

  const updateBalance = (left: number, right: number) => {
    const diff = right - left;
    // 1 degree per gram difference, max ±25 degrees
    const rotation = Math.max(-25, Math.min(25, diff * 0.5));

    beamRotation.value = withSpring(rotation, {
      damping: 8,
      stiffness: 100,
    });

    // Pan positions
    const panOffset = rotation * 0.8;
    leftPanY.value = withSpring(-panOffset);
    rightPanY.value = withSpring(panOffset);

    onMassChange?.(left, right);
  };

  const updateMass = (side: 'left' | 'right', change: number) => {
    if (side === 'left') {
      const newMass = Math.max(0, Math.min(maxMass, leftMass + change));
      setLeftMass(newMass);
      updateBalance(newMass, rightMass);
    } else {
      const newMass = Math.max(0, Math.min(maxMass, rightMass + change));
      setRightMass(newMass);
      updateBalance(leftMass, newMass);
    }
  };

  const leftPanResponder = PanResponder.create({
    onStartShouldSetPanResponder: () => true,
    onPanResponderGrant: () => setDragMode('left'),
    onPanResponderMove: (evt, gesture) => {
      updateMass('left', gesture.dy / -10);
    },
    onPanResponderRelease: () => setDragMode(null),
  });

  const rightPanResponder = PanResponder.create({
    onStartShouldSetPanResponder: () => true,
    onPanResponderGrant: () => setDragMode('right'),
    onPanResponderMove: (evt, gesture) => {
      updateMass('right', gesture.dy / -10);
    },
    onPanResponderRelease: () => setDragMode(null),
  });

  const beamProps = useAnimatedProps(() => ({
    transform: [
      {
        rotate: `${beamRotation.value}deg`,
      }
    ],
    transformOrigin: `${width / 2} ${height * 0.4}`
  }));

  const leftPanProps = useAnimatedProps(() => ({
    transform: [{ translateY: leftPanY.value }]
  }));

  const rightPanProps = useAnimatedProps(() => ({
    transform: [{ translateY: rightPanY.value }]
  }));

  const centerX = width / 2;
  const beamY = height * 0.4;
  const panDistance = width * 0.3;

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <LinearGradient id="metalGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#e0e0e0" />
            <Stop offset="0.5" stopColor="#c0c0c0" />
            <Stop offset="1" stopColor="#a0a0a0" />
          </LinearGradient>

          <LinearGradient id="panGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#f0f0f0" />
            <Stop offset="1" stopColor="#d0d0d0" />
          </LinearGradient>
        </Defs>

        {/* Stand base */}
        <Rect
          x={centerX - 40}
          y={height * 0.8}
          width="80"
          height="15"
          rx="7"
          fill="url(#metalGradient)"
        />

        {/* Stand post */}
        <Rect
          x={centerX - 5}
          y={beamY}
          width="10"
          height={height * 0.4}
          fill="url(#metalGradient)"
        />

        {/* Fulcrum */}
        <Circle
          cx={centerX}
          cy={beamY}
          r="12"
          fill="url(#metalGradient)"
          stroke="#888"
          strokeWidth="1"
        />

        {/* Balance beam */}
        <AnimatedG animatedProps={beamProps}>
          <Line
            x1={centerX - panDistance}
            y1={beamY}
            x2={centerX + panDistance}
            y2={beamY}
            stroke="#777"
            strokeWidth="6"
            strokeLinecap="round"
          />

          {/* Balance point indicator */}
          <Circle
            cx={centerX}
            cy={beamY - 3}
            r="3"
            fill="#ff0000"
          />
        </AnimatedG>

        {/* Left pan */}
        <AnimatedG animatedProps={leftPanProps}>
          <G {...leftPanResponder.panHandlers}>
            {/* Pan chains */}
            <Line
              x1={centerX - panDistance}
              y1={beamY}
              x2={centerX - panDistance}
              y2={beamY + 50}
              stroke="#666"
              strokeWidth="2"
            />

            {/* Pan */}
            <Path
              d={`M${centerX - panDistance - 25} ${beamY + 50}
                  L${centerX - panDistance + 25} ${beamY + 50}
                  L${centerX - panDistance + 22} ${beamY + 60}
                  L${centerX - panDistance - 22} ${beamY + 60} Z`}
              fill="url(#panGradient)"
              stroke="#aaa"
              strokeWidth="1"
            />

            {/* Mass visualization */}
            {leftMass > 0 && (
              <Rect
                x={centerX - panDistance - 10}
                y={beamY + 40}
                width="20"
                height={Math.min(20, leftMass / 5)}
                fill="#8B4513"
                rx="2"
              />
            )}
          </G>
        </AnimatedG>

        {/* Right pan */}
        <AnimatedG animatedProps={rightPanProps}>
          <G {...rightPanResponder.panHandlers}>
            {/* Pan chains */}
            <Line
              x1={centerX + panDistance}
              y1={beamY}
              x2={centerX + panDistance}
              y2={beamY + 50}
              stroke="#666"
              strokeWidth="2"
            />

            {/* Pan */}
            <Path
              d={`M${centerX + panDistance - 25} ${beamY + 50}
                  L${centerX + panDistance + 25} ${beamY + 50}
                  L${centerX + panDistance + 22} ${beamY + 60}
                  L${centerX + panDistance - 22} ${beamY + 60} Z`}
              fill="url(#panGradient)"
              stroke="#aaa"
              strokeWidth="1"
            />

            {/* Mass visualization */}
            {rightMass > 0 && (
              <Rect
                x={centerX + panDistance - 10}
                y={beamY + 40}
                width="20"
                height={Math.min(20, rightMass / 5)}
                fill="#8B4513"
                rx="2"
              />
            )}
          </G>
        </AnimatedG>

        {/* Mass readings */}
        <Text
          x={centerX - panDistance}
          y={beamY + 90}
          textAnchor="middle"
          fill="#333"
          fontSize="12"
          fontWeight="bold"
        >
          {leftMass.toFixed(1)}g
        </Text>

        <Text
          x={centerX + panDistance}
          y={beamY + 90}
          textAnchor="middle"
          fill="#333"
          fontSize="12"
          fontWeight="bold"
        >
          {rightMass.toFixed(1)}g
        </Text>

        {/* Balance status */}
        <Text
          x={centerX}
          y={height * 0.15}
          textAnchor="middle"
          fill="#333"
          fontSize="14"
          fontWeight="bold"
        >
          {Math.abs(leftMass - rightMass) < 0.1 ? "BALANCED" :
           leftMass > rightMass ? "LEFT HEAVY" : "RIGHT HEAVY"}
        </Text>

        {/* Drag indicators */}
        {dragMode === 'left' && (
          <Circle
            cx={centerX - panDistance}
            cy={beamY + 55}
            r="30"
            fill="none"
            stroke="#0080ff"
            strokeWidth="2"
            strokeDasharray="5,5"
          />
        )}

        {dragMode === 'right' && (
          <Circle
            cx={centerX + panDistance}
            cy={beamY + 55}
            r="30"
            fill="none"
            stroke="#0080ff"
            strokeWidth="2"
            strokeDasharray="5,5"
          />
        )}

        {/* Instructions */}
        <Text
          x={width / 2}
          y={height - 10}
          textAnchor="middle"
          fill="#666"
          fontSize="10"
        >
          Drag pans up/down to add mass
        </Text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: LitmusPaper.tsx ===
Path: lab\assets\measurement\LitmusPaper.tsx
---- File Content Start ----
// src/data/animations/lab/assets/measurement/LitmusPaper.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect, Path, Text } from 'react-native-svg';
import Animated, { useSharedValue, withTiming } from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);

interface LitmusPaperProps {
  width?: number;
  height?: number;
}

export const LitmusPaper: React.FC<LitmusPaperProps> = ({ width = 150, height = 200 }) => {
  const [isAcid, setIsAcid] = useState(false);
  const color = useSharedValue('#0000ff'); // blue for base

  const testSolution = () => {
    setIsAcid(prev => {
      const newIsAcid = !prev;
      color.value = withTiming(newIsAcid ? '#ff0000' : '#0000ff', { duration: 1000 });
      return newIsAcid;
    });
  };

  const paperProps = useSharedValue(() => ({ fill: color.value }));

  return (
    <Pressable onPress={testSolution}>
      <Svg width={width} height={height}>
        {/* Beaker */}
        <Path d="M50 50 L100 50 L110 150 L40 150 Z" fill="#aaccff55" stroke="#555" />

        {/* Liquid */}
        <Path d="M50 100 L100 100 L110 150 L40 150 Z"
              fill={isAcid ? "#ff000055" : "#0000ff55"} />

        {/* Litmus paper */}
        <Rect x="70" y="40" width="10" height="80" fill="#f0f0f0" rx="2" />

        {/* Tested part (bottom of paper) */}
        <AnimatedRect
          x="70"
          y="100"
          width="10"
          height="20"
          rx="2"
          animatedProps={paperProps}
        />

        {/* Label */}
        <Text x="75" y="25" textAnchor="middle" fontSize="12" fill="#333">
          {isAcid ? "ACID" : "BASE"}
        </Text>
        <Text x="75" y={height - 10} textAnchor="middle" fontSize="10" fill="#666">
          Tap to test
        </Text>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: MeasuringSpoons.tsx ===
Path: lab\assets\measurement\MeasuringSpoons.tsx
---- File Content Start ----
// src/data/animations/lab/assets/measurement/MeasuringSpoons.tsx
import React, { useState } from 'react';
import { PanResponder, View } from 'react-native';
import Svg, { Path, G, Defs, LinearGradient, Stop, Rect, Text, Line } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);

interface MeasuringSpoonsProps {
  width?: number;
  height?: number;
  maxCapacity?: number;
}

export const MeasuringSpoons: React.FC<MeasuringSpoonsProps> = ({
  width = 200,
  height = 200,
  maxCapacity = 15
}) => {
  const [fillLevel, setFillLevel] = useState(0); // 0-100%
  const liquidHeight = useSharedValue(0);

  const updateFill = (level: number) => {
    level = Math.min(100, Math.max(0, level));
    liquidHeight.value = withTiming(level, { duration: 500 });
    setFillLevel(level);
  };

  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updateFill(fillLevel + gesture.dy / -2);
    }
  });

  const liquidProps = useAnimatedProps(() => {
    const height = 80 * (liquidHeight.value / 100);
    return {
      d: `M100 150 L80 ${150 - height} L120 ${150 - height} Z`
    };
  });

  return (
    <View {...panResponder.panHandlers}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="liquid" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#2a9df4" stopOpacity="0.8"/>
            <Stop offset="1" stopColor="#1167b1" stopOpacity="0.9"/>
          </LinearGradient>
        </Defs>

        {/* Spoon outline */}
        <Path
          d="M100 150 L60 100 C70 70, 130 70, 140 100 L100 150 Z"
          fill="#e0e0e0"
          stroke="#aaa"
        />

        {/* Liquid fill */}
        <AnimatedPath animatedProps={liquidProps} fill="url(#liquid)" />

        {/* Handle */}
        <Rect x="98" y="50" width="4" height="100" fill="#ccc" rx="2" />

        {/* Measurement markers */}
        <Line x1="85" y1="110" x2="115" y2="110" stroke="#555" strokeWidth="1" />
        <Text x="75" y="110" fill="#333" fontSize="10">5g</Text>

        <Line x1="85" y1="130" x2="115" y2="130" stroke="#555" strokeWidth="1" />
        <Text x="75" y="130" fill="#333" fontSize="10">10g</Text>

        <Line x1="85" y1="150" x2="115" y2="150" stroke="#555" strokeWidth="1" />
        <Text x="75" y="150" fill="#333" fontSize="10">15g</Text>

        {/* Current measurement */}
        <Text x="100" y="30" textAnchor="middle" fontSize="12" fill="#333" fontWeight="bold">
          {((fillLevel / 100) * maxCapacity).toFixed(1)}g
        </Text>

        {/* Instructions */}
        <Text x="100" y={height - 10} textAnchor="middle" fontSize="8" fill="#666">
          Drag vertically to fill
        </Text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: PHMeter.tsx ===
Path: lab\assets\measurement\PHMeter.tsx
---- File Content Start ----
// src/data/animations/lab/assets/measurement/PHMeter.tsx

import React, { useState } from 'react';
import { View, PanResponder } from 'react-native';
import Svg, {
  Rect,
  Path,
  Circle,
  Text,
  Defs,
  LinearGradient,
  Stop,
  G
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  interpolateColor
} from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);

interface PHMeterProps {
  width?: number;
  height?: number;
  onPHChange?: (pH: number) => void;
}

const pHColors = [
  '#8B0000', // 0: dark red (very acidic)
  '#DC143C', // 1: red
  '#FF4500', // 2: orange red
  '#FF6347', // 3: tomato
  '#FFA500', // 4: orange
  '#FFD700', // 5: gold
  '#FFFF00', // 6: yellow
  '#ADFF2F', // 7: green yellow (neutral)
  '#32CD32', // 8: lime green
  '#00FF00', // 9: green
  '#00CED1', // 10: dark turquoise
  '#0000FF', // 11: blue
  '#4169E1', // 12: royal blue
  '#8A2BE2', // 13: blue violet
  '#4B0082', // 14: indigo (very basic)
];

const pHLabels = [
  'Battery Acid', 'Lemon Juice', 'Vinegar', 'Orange Juice', 'Tomato',
  'Coffee', 'Milk', 'Pure Water', 'Baking Soda', 'Soap',
  'Ammonia', 'Household Bleach', 'Lime Water', 'Lye', 'Liquid Drain Cleaner'
];

export const PHMeter: React.FC<PHMeterProps> = ({
  width = 200,
  height = 300,
  onPHChange
}) => {
  const [pH, setPH] = useState(7);
  const [isCalibrating, setIsCalibrating] = useState(false);

  const stripColor = useSharedValue(pHColors[7]);
  const probeDepth = useSharedValue(0);

  const updatePH = (newPH: number) => {
    newPH = Math.min(14, Math.max(0, newPH));
    const colorIndex = Math.round(newPH);
    stripColor.value = withTiming(pHColors[colorIndex], { duration: 500 });
    setPH(newPH);
    onPHChange?.(newPH);
  };

  const calibrate = () => {
    setIsCalibrating(true);
    // Simulate calibration sequence
    setTimeout(() => {
      updatePH(7); // Reset to neutral
      setIsCalibrating(false);
    }, 2000);
  };

  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updatePH(pH + gesture.dx / 30);
      // Simulate probe movement
      probeDepth.value = withTiming(Math.max(0, Math.min(20, gesture.dy / 5)));
    },
    onPanResponderRelease: () => {
      probeDepth.value = withTiming(0, { duration: 300 });
    }
  });

  const stripProps = useAnimatedProps(() => ({
    fill: stripColor.value
  }));

  const probeProps = useAnimatedProps(() => ({
    transform: [{ translateY: probeDepth.value }]
  }));

  const getAcidityLevel = (pH: number) => {
    if (pH < 3) return 'Very Acidic';
    if (pH < 6) return 'Acidic';
    if (pH < 8) return 'Neutral';
    if (pH < 11) return 'Basic';
    return 'Very Basic';
  };

  const centerX = width / 2;

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <LinearGradient id="meterBody" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#f0f0f0" />
            <Stop offset="0.1" stopColor="#e8e8e8" />
            <Stop offset="0.9" stopColor="#d0d0d0" />
            <Stop offset="1" stopColor="#c0c0c0" />
          </LinearGradient>

          <LinearGradient id="display" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#001100" />
            <Stop offset="1" stopColor="#002200" />
          </LinearGradient>

          <LinearGradient id="probe" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#c0c0c0" />
            <Stop offset="0.8" stopColor="#888888" />
            <Stop offset="1" stopColor="#666666" />
          </LinearGradient>
        </Defs>

        {/* Meter body */}
        <Rect
          x={centerX - 40}
          y={height * 0.05}
          width="80"
          height={height * 0.6}
          rx="8"
          fill="url(#meterBody)"
          stroke="#999"
          strokeWidth="2"
        />

        {/* Brand/Model label */}
        <Rect
          x={centerX - 35}
          y={height * 0.08}
          width="70"
          height="15"
          fill="#333"
        />
        <Text
          x={centerX}
          y={height * 0.092}
          fontSize="8"
          fill="white"
          textAnchor="middle"
          fontWeight="bold"
        >
          pH METER PRO
        </Text>

        {/* Digital display */}
        <Rect
          x={centerX - 30}
          y={height * 0.12}
          width="60"
          height="30"
          rx="3"
          fill="url(#display)"
          stroke="#555"
        />

        {/* pH value display */}
        <Text
          x={centerX}
          y={height * 0.145}
          fontSize="16"
          fill="#00ff00"
          textAnchor="middle"
          fontFamily="monospace"
          fontWeight="bold"
        >
          {pH.toFixed(2)}
        </Text>

        {/* Units */}
        <Text
          x={centerX + 20}
          y={height * 0.135}
          fontSize="8"
          fill="#00aa00"
          textAnchor="middle"
        >
          pH
        </Text>

        {/* Temperature display */}
        <Text
          x={centerX}
          y={height * 0.158}
          fontSize="8"
          fill="#ffaa00"
          textAnchor="middle"
          fontFamily="monospace"
        >
          25.0°C
        </Text>

        {/* pH strip indicator */}
        <Rect
          x={centerX - 25}
          y={height * 0.2}
          width="50"
          height="80"
          rx="3"
          fill="#444"
          stroke="#666"
        />

        {/* Actual pH strip */}
        <AnimatedRect
          x={centerX - 22}
          y={height * 0.205}
          width="44"
          height="70"
          rx="2"
          animatedProps={stripProps}
        />

        {/* pH scale markings */}
        <G>
          {Array.from({ length: 15 }, (_, i) => (
            <G key={i}>
              <Text
                x={centerX - 35}
                y={height * 0.205 + (i * 4.67) + 3}
                fontSize="6"
                fill="#333"
                textAnchor="end"
              >
                {14 - i}
              </Text>
              <Rect
                x={centerX - 28}
                y={height * 0.205 + (i * 4.67)}
                width="6"
                height="1"
                fill="#333"
              />
            </G>
          ))}
        </G>

        {/* pH level indicator */}
        <Text
          x={centerX}
          y={height * 0.32}
          fontSize="10"
          fill="#333"
          textAnchor="middle"
          fontWeight="bold"
        >
          {getAcidityLevel(pH)}
        </Text>

        {/* Sample type indicator */}
        <Text
          x={centerX}
          y={height * 0.35}
          fontSize="8"
          fill="#666"
          textAnchor="middle"
        >
          {pHLabels[Math.round(pH)]}
        </Text>

        {/* Control buttons */}
        <G>
          {/* Calibrate button */}
          <Rect
            x={centerX - 35}
            y={height * 0.4}
            width="25"
            height="15"
            rx="2"
            fill={isCalibrating ? "#ff6600" : "#4CAF50"}
            stroke="#333"
            onPress={calibrate}
          />
          <Text
            x={centerX - 22.5}
            y={height * 0.41}
            fontSize="6"
            fill="white"
            textAnchor="middle"
          >
            CAL
          </Text>

          {/* Mode button */}
          <Rect
            x={centerX + 10}
            y={height * 0.4}
            width="25"
            height="15"
            rx="2"
            fill="#2196F3"
            stroke="#333"
          />
          <Text
            x={centerX + 22.5}
            y={height * 0.41}
            fontSize="6"
            fill="white"
            textAnchor="middle"
          >
            MODE
          </Text>
        </G>

        {/* Probe cable */}
        <Path
          d={`M${centerX} ${height * 0.65}
              Q${centerX + 15} ${height * 0.7}, ${centerX + 10} ${height * 0.8}
              Q${centerX + 5} ${height * 0.85}, ${centerX} ${height * 0.9}`}
          stroke="#333"
          strokeWidth="3"
          fill="none"
        />

        {/* Probe */}
        <Animated.G animatedProps={probeProps} {...panResponder.panHandlers}>
          <Rect
            x={centerX - 3}
            y={height * 0.9}
            width="6"
            height="40"
            fill="url(#probe)"
            stroke="#555"
            rx="3"
          />

          {/* Probe tip */}
          <Path
            d={`M${centerX - 3} ${height * 0.93}
                L${centerX + 3} ${height * 0.93}
                L${centerX + 1} ${height * 0.95}
                L${centerX - 1} ${height * 0.95} Z`}
            fill="#444"
          />

          {/* Glass bulb */}
          <Circle
            cx={centerX}
            cy={height * 0.92}
            r="4"
            fill="#e0f0ff"
            stroke="#99ccff"
            strokeWidth="0.5"
          />
        </Animated.G>

        {/* Status indicators */}
        <Circle
          cx={centerX + 25}
          cy={height * 0.1}
          r="3"
          fill={isCalibrating ? "#ff6600" : "#00ff00"}
        />
        <Text
          x={centerX + 32}
          y={height * 0.105}
          fontSize="6"
          fill="#333"
        >
          {isCalibrating ? "CAL" : "RDY"}
        </Text>

        {/* Instructions */}
        <Text
          x={centerX}
          y={height - 5}
          fontSize="8"
          fill="#666"
          textAnchor="middle"
        >
          Drag horizontally to change pH
        </Text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: EmergencyShower.tsx ===
Path: lab\assets\safety\EmergencyShower.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/EmergencyShower.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect, Circle, Path, G, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming, withRepeat, withSequence } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

interface EmergencyShowerProps {
  width?: number;
  height?: number;
}

export const EmergencyShower: React.FC<EmergencyShowerProps> = ({ width = 200, height = 300 }) => {
  const [active, setActive] = useState(false);
  const waterFlow = useSharedValue(0);

  const activateShower = () => {
    setActive(true);
    waterFlow.value = withSequence(
      withTiming(1, { duration: 500 }),
      withRepeat(withTiming(0.5, { duration: 1000 }), -1, true)
    );

    setTimeout(() => {
      setActive(false);
      waterFlow.value = withTiming(0, { duration: 500 });
    }, 5000);
  };

  const showerProps = useAnimatedProps(() => ({
    opacity: waterFlow.value
  }));

  const eyewashProps = useAnimatedProps(() => ({
    opacity: waterFlow.value * 0.8
  }));

  return (
    <Pressable onPress={activateShower}>
      <Svg width={width} height={height}>
        {/* Shower head */}
        <Circle cx="100" cy="50" r="20" fill="#333" />
        <Circle cx="100" cy="50" r="15" fill="#555" />

        {/* Shower arm */}
        <Rect x="98" y="50" width="4" height="100" fill="#444" />

        {/* Shower water */}
        <AnimatedG animatedProps={showerProps}>
          <Path
            d="M80 70 Q90 120, 100 150 Q110 120, 120 70"
            stroke="#2a9df4"
            strokeWidth="15"
            fill="none"
            strokeLinecap="round"
          />
          <Path
            d="M70 90 Q85 140, 100 170 Q115 140, 130 90"
            stroke="#2a9df4"
            strokeWidth="10"
            fill="none"
            strokeLinecap="round"
          />
        </AnimatedG>

        {/* Eyewash nozzles */}
        <Rect x="85" y="180" width="30" height="20" rx="5" fill="#555" />
        <Circle cx="90" cy="190" r="3" fill="#333" />
        <Circle cx="110" cy="190" r="3" fill="#333" />

        {/* Eyewash streams */}
        <AnimatedG animatedProps={eyewashProps}>
          <Path d="M90 190 Q90 230, 85 250" stroke="#2a9df4" strokeWidth="3" />
          <Path d="M110 190 Q110 230, 115 250" stroke="#2a9df4" strokeWidth="3" />
        </AnimatedG>

        {/* Activation handle */}
        <Path d="M120 200 L150 180 L150 220 Z" fill={active ? "#ff0000" : "#00ff00"} />
        <Text x="160" y="200" fill="black" fontSize="12">PULL</Text>

        {/* Drain */}
        <Rect x="70" y="270" width="60" height="5" rx="2" fill="#666" />
        <Path d="M70 270 L50 290 L130 290 L110 270 Z" fill="#aaa" />
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: FireExtinguisher.tsx ===
Path: lab\assets\safety\FireExtinguisher.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/FireExtinguisher.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect, Path, Circle, G } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withSequence, withTiming, withRepeat } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

interface FireExtinguisherProps {
  width?: number;
  height?: number;
}

export const FireExtinguisher: React.FC<FireExtinguisherProps> = ({ width = 150, height = 250 }) => {
  const [active, setActive] = useState(false);
  const sprayOpacity = useSharedValue(0);
  const pressure = useSharedValue(100);

  const activateExtinguisher = () => {
    if (!active) {
      setActive(true);

      sprayOpacity.value = withSequence(
        withTiming(1, { duration: 200 }),
        withRepeat(
          withSequence(
            withTiming(0.8, { duration: 300 }),
            withTiming(1, { duration: 300 })
          ), 5, true
        ),
        withTiming(0, { duration: 500 })
      );

      pressure.value = withSequence(
        withTiming(0, { duration: 2000 }),
        withTiming(100, { duration: 1000 })
      );

      setTimeout(() => setActive(false), 4000);
    }
  };

  const sprayProps = useAnimatedProps(() => ({
    opacity: sprayOpacity.value
  }));

  const gaugeProps = useAnimatedProps(() => ({
    strokeDashoffset: 100 - pressure.value
  }));

  return (
    <Pressable onPress={activateExtinguisher}>
      <Svg width={width} height={height}>
        {/* Body */}
        <Rect x="50" y="50" width="50" height="150" rx="5" fill="#ff0000" />

        {/* Handle */}
        <Path d="M70 30 L70 50 L80 50 L80 30 Z" fill="#444" />
        <Circle cx="75" cy="40" r="10" fill="#444" />

        {/* Hose */}
        <Path
          d="M100 100 Q120 80, 140 100 Q160 120, 180 110"
          stroke="#333"
          strokeWidth="5"
          fill="none"
        />

        {/* Nozzle */}
        <Rect x="175" y="105" width="15" height="10" rx="3" fill="#555" />

        {/* Spray */}
        <AnimatedG animatedProps={sprayProps}>
          <Path
            d="M190 100 Q200 90, 210 100 Q220 110, 230 100"
            stroke="#ffcc00"
            strokeWidth="5"
            fill="none"
          />
          <Circle cx="220" cy="95" r="8" fill="#ff9900" opacity="0.7" />
          <Circle cx="240" cy="105" r="10" fill="#ff5500" opacity="0.6" />
        </AnimatedG>

        {/* Pressure gauge */}
        <Circle cx="100" cy="80" r="15" fill="#000" stroke="#fff" strokeWidth="2" />
        <AnimatedPath
          d="M100 65 L100 75"
          stroke="#0f0"
          strokeWidth="3"
          strokeDasharray="100"
          strokeDashoffset="100"
          animatedProps={gaugeProps}
          transform="rotate(-90 100 80)"
        />

        {/* Safety pin */}
        {!active && (
          <Path d="M65 40 L85 40" stroke="#ff0" strokeWidth="3" />
        )}
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: FumeHood.tsx ===
Path: lab\assets\safety\FumeHood.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/FumeHood.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect, Path, G, Defs, ClipPath, Circle } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedRect = Animated.createAnimatedComponent(Rect);
const AnimatedG = Animated.createAnimatedComponent(G);

interface FumeHoodProps {
  width?: number;
  height?: number;
}

export const FumeHood: React.FC<FumeHoodProps> = ({ width = 250, height = 250 }) => {
  const [open, setOpen] = useState(false);
  const doorPosition = useSharedValue(0);
  const vaporOpacity = useSharedValue(0);

  const toggleDoor = () => {
    setOpen(!open);
    doorPosition.value = withTiming(open ? 0 : -100, { duration: 1000 });
    vaporOpacity.value = withTiming(open ? 0 : 0.8, { duration: 2000 });
  };

  const doorProps = useAnimatedProps(() => ({
    transform: [{ translateX: doorPosition.value }]
  }));

  const vaporProps = useAnimatedProps(() => ({
    opacity: vaporOpacity.value
  }));

  return (
    <Pressable onPress={toggleDoor}>
      <Svg width={width} height={height}>
        <Defs>
          <ClipPath id="hoodClip">
            <Rect x="50" y="50" width="150" height="150" rx="5" />
          </ClipPath>
        </Defs>

        {/* Hood structure */}
        <Rect x="40" y="40" width="170" height="170" fill="#ddd" rx="5" />

        {/* Interior */}
        <Rect x="50" y="50" width="150" height="150" fill="#333" rx="5" />

        {/* Vapor effect */}
        <AnimatedG animatedProps={vaporProps} clipPath="url(#hoodClip)">
          <Path
            d="M60 100 Q80 80, 100 100 Q120 120, 140 100 Q160 80, 180 100"
            stroke="#a0a0ff"
            strokeWidth="3"
            fill="none"
          />
          <Path
            d="M70 130 Q90 110, 110 130 Q130 150, 150 130 Q170 110, 190 130"
            stroke="#a0a0ff"
            strokeWidth="3"
            fill="none"
          />
          <Circle cx="100" cy="120" r="10" fill="#a0a0ff55" />
          <Circle cx="150" cy="90" r="15" fill="#a0a0ff55" />
        </AnimatedG>

        {/* Sliding door */}
        <AnimatedRect
          x="150"
          y="50"
          width="100"
          height="150"
          fill="#a0a0a0"
          opacity="0.8"
          rx="5"
          animatedProps={doorProps}
        />

        {/* Door handle */}
        <Circle cx="160" cy="125" r="5" fill="#666" />

        {/* Status indicator */}
        <Circle cx="220" cy="30" r="10" fill={open ? "#f00" : "#0f0"} />
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: SafetyGloves.tsx ===
Path: lab\assets\safety\SafetyGloves.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/SafetyGloves.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Path, G } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedG = Animated.createAnimatedComponent(G);

interface SafetyGlovesProps {
  width?: number;
  height?: number;
}

export const SafetyGloves: React.FC<SafetyGlovesProps> = ({ width = 200, height = 200 }) => {
  const [gloved, setGloved] = useState(false);
  const handPosition = useSharedValue(100);

  const toggleGloves = () => {
    setGloved(!gloved);
    handPosition.value = withTiming(gloved ? 100 : 0, { duration: 500 });
  };

  const handProps = useAnimatedProps(() => ({
    transform: [{ translateY: handPosition.value }]
  }));

  return (
    <Pressable onPress={toggleGloves}>
      <Svg width={width} height={height}>
        {/* Left glove */}
        <Path
          d="M50 50 Q40 80, 50 110 Q70 130, 90 120 Q100 90, 80 70 Q70 50, 50 50 Z"
          fill={gloved ? "#00aaff" : "#f0f0f0"}
          stroke="#666"
        />

        {/* Right glove */}
        <Path
          d="M150 50 Q160 80, 150 110 Q130 130, 110 120 Q100 90, 120 70 Q130 50, 150 50 Z"
          fill={gloved ? "#00aaff" : "#f0f0f0"}
          stroke="#666"
        />

        {/* Hands (animated insertion) */}
        <AnimatedG animatedProps={handProps}>
          {/* Left hand */}
          <Path
            d="M70 80 Q65 100, 70 120 Q85 140, 95 130 Q100 110, 90 95 Q80 85, 70 80 Z"
            fill="#ffcc99"
          />

          {/* Right hand */}
          <Path
            d="M130 80 Q135 100, 130 120 Q115 140, 105 130 Q100 110, 110 95 Q120 85, 130 80 Z"
            fill="#ffcc99"
          />
        </AnimatedG>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: SafetyGoggles.tsx ===
Path: lab\assets\safety\SafetyGoggles.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/SafetyGoggles.tsx

import React, { useEffect } from 'react';
import { View } from 'react-native';
import Svg, {
  Path,
  G,
  Defs,
  RadialGradient,
  Stop,
  LinearGradient,
  Ellipse
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  Easing
} from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedEllipse = Animated.createAnimatedComponent(Ellipse);

interface SafetyGogglesProps {
  width?: number;
  height?: number;
  lensColor?: string;
  isWorn?: boolean;
}

export const SafetyGoggles: React.FC<SafetyGogglesProps> = ({
  width = 200,
  height = 100,
  lensColor = '#a0d0ff',
  isWorn = false
}) => {
  const reflectionPos = useSharedValue(0);
  const blinkOpacity = useSharedValue(1);

  useEffect(() => {
    // Reflection animation
    reflectionPos.value = withRepeat(
      withTiming(1, { duration: 4000, easing: Easing.linear }),
      -1,
      true
    );

    // Occasional blink effect when worn
    if (isWorn) {
      blinkOpacity.value = withRepeat(
        withTiming(0.3, { duration: 150 }),
        -1,
        true
      );
    }
  }, [isWorn]);

  const leftReflectionProps = useAnimatedProps(() => ({
    transform: [{ translateX: reflectionPos.value * 30 - 15 }]
  }));

  const rightReflectionProps = useAnimatedProps(() => ({
    transform: [{ translateX: reflectionPos.value * 30 - 15 }]
  }));

  const lensOpacityProps = useAnimatedProps(() => ({
    opacity: isWorn ? blinkOpacity.value : 1
  }));

  const centerX = width / 2;
  const centerY = height / 2;
  const lensWidth = width * 0.25;
  const lensHeight = height * 0.6;

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <RadialGradient id="goggleLens" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor={lensColor} stopOpacity="0.7" />
            <Stop offset="70%" stopColor={lensColor} stopOpacity="0.8" />
            <Stop offset="100%" stopColor="#5aa0e0" stopOpacity="0.9" />
          </RadialGradient>

          <LinearGradient id="goggleFrame" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0%" stopColor="#f0f0f0" />
            <Stop offset="50%" stopColor="#e0e0e0" />
            <Stop offset="100%" stopColor="#c0c0c0" />
          </LinearGradient>

          <LinearGradient id="reflection" x1="0" y1="0" x2="1" y2="1">
            <Stop offset="0%" stopColor="#ffffff" stopOpacity="0.8" />
            <Stop offset="100%" stopColor="#ffffff" stopOpacity="0.2" />
          </LinearGradient>

          <RadialGradient id="strap" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#333333" />
            <Stop offset="100%" stopColor="#1a1a1a" />
          </RadialGradient>
        </Defs>

        {/* Elastic strap */}
        <Path
          d={`M${width * 0.1} ${centerY}
              Q${width * 0.05} ${centerY - 15}, ${width * 0.15} ${centerY - 10}
              Q${width * 0.25} ${centerY - 8}, ${width * 0.35} ${centerY - 5}`}
          stroke="url(#strap)"
          strokeWidth="8"
          fill="none"
          strokeLinecap="round"
        />
        <Path
          d={`M${width * 0.65} ${centerY - 5}
              Q${width * 0.75} ${centerY - 8}, ${width * 0.85} ${centerY - 10}
              Q${width * 0.95} ${centerY - 15}, ${width * 0.9} ${centerY}`}
          stroke="url(#strap)"
          strokeWidth="8"
          fill="none"
          strokeLinecap="round"
        />

        {/* Frame outer border */}
        <Path
          d={`M${centerX - lensWidth * 1.8} ${centerY - lensHeight * 0.7}
              Q${centerX - lensWidth * 1.5} ${centerY - lensHeight * 1.1},
              ${centerX - lensWidth * 0.8} ${centerY - lensHeight * 0.9}
              Q${centerX - lensWidth * 0.3} ${centerY - lensHeight * 0.8},
              ${centerX} ${centerY - lensHeight * 0.7}
              Q${centerX + lensWidth * 0.3} ${centerY - lensHeight * 0.8},
              ${centerX + lensWidth * 0.8} ${centerY - lensHeight * 0.9}
              Q${centerX + lensWidth * 1.5} ${centerY - lensHeight * 1.1},
              ${centerX + lensWidth * 1.8} ${centerY - lensHeight * 0.7}
              Q${centerX + lensWidth * 1.9} ${centerY + lensHeight * 0.8},
              ${centerX + lensWidth * 1.5} ${centerY + lensHeight * 1.2}
              Q${centerX} ${centerY + lensHeight * 1.4},
              ${centerX - lensWidth * 1.5} ${centerY + lensHeight * 1.2}
              Q${centerX - lensWidth * 1.9} ${centerY + lensHeight * 0.8},
              ${centerX - lensWidth * 1.8} ${centerY - lensHeight * 0.7} Z`}
          fill="url(#goggleFrame)"
          stroke="#999"
          strokeWidth="2"
        />

        {/* Left lens */}
        <AnimatedEllipse
          cx={centerX - lensWidth}
          cy={centerY}
          rx={lensWidth * 0.8}
          ry={lensHeight}
          fill="url(#goggleLens)"
          stroke="#666"
          strokeWidth="2"
          animatedProps={lensOpacityProps}
        />

        {/* Right lens */}
        <AnimatedEllipse
          cx={centerX + lensWidth}
          cy={centerY}
          rx={lensWidth * 0.8}
          ry={lensHeight}
          fill="url(#goggleLens)"
          stroke="#666"
          strokeWidth="2"
          animatedProps={lensOpacityProps}
        />

        {/* Bridge/nose piece */}
        <Path
          d={`M${centerX - lensWidth * 0.2} ${centerY}
              L${centerX - lensWidth * 0.1} ${centerY - 8}
              L${centerX + lensWidth * 0.1} ${centerY - 8}
              L${centerX + lensWidth * 0.2} ${centerY}
              L${centerX + lensWidth * 0.1} ${centerY + 8}
              L${centerX - lensWidth * 0.1} ${centerY + 8} Z`}
          fill="#ddd"
          stroke="#aaa"
          strokeWidth="1"
        />

        {/* Ventilation holes */}
        <G>
          {Array.from({ length: 4 }, (_, i) => (
            <React.Fragment key={i}>
              <circle
                cx={centerX - lensWidth - 10 + i * 5}
                cy={centerY + lensHeight + 15}
                r="2"
                fill="#999"
              />
              <circle
                cx={centerX + lensWidth - 10 + i * 5}
                cy={centerY + lensHeight + 15}
                r="2"
                fill="#999"
              />
            </React.Fragment>
          ))}
        </G>

        {/* Moving reflections */}
        <AnimatedPath
          d={`M${centerX - lensWidth - 8} ${centerY - 8}
              Q${centerX - lensWidth} ${centerY - 15},
              ${centerX - lensWidth + 8} ${centerY - 8}
              Q${centerX - lensWidth} ${centerY + 5},
              ${centerX - lensWidth - 8} ${centerY - 8} Z`}
          fill="url(#reflection)"
          animatedProps={leftReflectionProps}
        />

        <AnimatedPath
          d={`M${centerX + lensWidth - 8} ${centerY - 8}
              Q${centerX + lensWidth} ${centerY - 15},
              ${centerX + lensWidth + 8} ${centerY - 8}
              Q${centerX + lensWidth} ${centerY + 5},
              ${centerX + lensWidth - 8} ${centerY - 8} Z`}
          fill="url(#reflection)"
          animatedProps={rightReflectionProps}
        />

        {/* Adjustment straps */}
        <Ellipse
          cx={centerX - lensWidth * 1.6}
          cy={centerY}
          rx="4"
          ry="8"
          fill="#666"
        />
        <Ellipse
          cx={centerX + lensWidth * 1.6}
          cy={centerY}
          rx="4"
          ry="8"
          fill="#666"
        />

        {/* Safety certification mark */}
        <G>
          <circle cx={width - 15} cy={15} r="8" fill="#ffffff" stroke="#666" strokeWidth="1" />
          <text x={width - 15} y={18} textAnchor="middle" fontSize="8" fill="#333" fontWeight="bold">CE</text>
        </G>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: SafetyPerson.tsx ===
Path: lab\assets\safety\SafetyPerson.tsx
---- File Content Start ----
// src/data/animations/lab/assets/safety/SafetyPerson.tsx

import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import Svg, { G, Path, Circle, Rect, Defs, ClipPath } from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  withSpring,
  withSequence,
  Easing,
} from 'react-native-reanimated';

const AnimatedG = Animated.createAnimatedComponent(G);
const AnimatedPath = Animated.createAnimatedComponent(Path);

interface SafetyPersonProps {
  width?: number;
  height?: number;
  onSafetyStatusChange?: (isFullyProtected: boolean) => void;
  requiredEquipment?: Array<'goggles' | 'gloves' | 'labCoat' | 'faceShield'>;
  experimentType?: 'basic' | 'acid' | 'heat' | 'biological';
}

interface EquipmentState {
  goggles: boolean;
  gloves: boolean;
  labCoat: boolean;
  faceShield: boolean;
}

export const SafetyPerson: React.FC<SafetyPersonProps> = ({
  width = 300,
  height = 400,
  onSafetyStatusChange,
  requiredEquipment = ['goggles', 'labCoat', 'gloves'],
  experimentType = 'basic'
}) => {
  const [equipment, setEquipment] = useState<EquipmentState>({
    goggles: false,
    gloves: false,
    labCoat: false,
    faceShield: false
  });

  // Animation values
  const gogglesScale = useSharedValue(0);
  const glovesLeftPos = useSharedValue(-20);
  const glovesRightPos = useSharedValue(-20);
  const labCoatOpacity = useSharedValue(0);
  const faceShieldPos = useSharedValue(-30);

  // Equipment presets for different experiment types
  const experimentRequirements = {
    basic: ['goggles', 'labCoat', 'gloves'],
    acid: ['goggles', 'labCoat', 'gloves', 'faceShield'],
    heat: ['goggles', 'labCoat', 'gloves'],
    biological: ['labCoat', 'gloves']
  };

  const toggleEquipment = (item: keyof EquipmentState) => {
    const newValue = !equipment[item];
    setEquipment(prev => ({...prev, [item]: newValue}));

    // Animate based on equipment type
    switch(item) {
      case 'goggles':
        gogglesScale.value = withTiming(newValue ? 1 : 0, {
          duration: 500,
          easing: Easing.elastic(1)
        });
        break;
      case 'gloves':
        glovesLeftPos.value = withSpring(newValue ? 0 : -20);
        glovesRightPos.value = withSpring(newValue ? 0 : -20);
        break;
      case 'labCoat':
        labCoatOpacity.value = withTiming(newValue ? 1 : 0, {duration: 300});
        break;
      case 'faceShield':
        faceShieldPos.value = withSpring(newValue ? 0 : -30);
        break;
    }
  };

  const setExperimentPreset = (type: keyof typeof experimentRequirements) => {
    const required = experimentRequirements[type];

    // Reset all equipment first
    Object.keys(equipment).forEach(item => {
      if (equipment[item as keyof EquipmentState]) {
        toggleEquipment(item as keyof EquipmentState);
      }
    });

    // Activate required items with delay for visual effect
    required.forEach((item, index) => {
      setTimeout(() => {
        if (!equipment[item as keyof EquipmentState]) {
          toggleEquipment(item as keyof EquipmentState);
        }
      }, index * 300);
    });
  };

  const checkSafety = (): boolean => {
    return requiredEquipment.every(item => equipment[item]);
  };

  useEffect(() => {
    const isFullyProtected = checkSafety();
    onSafetyStatusChange?.(isFullyProtected);
  }, [equipment, requiredEquipment]);

  // Animated props
  const gogglesProps = useAnimatedProps(() => ({
    transform: [{ scale: gogglesScale.value }]
  }));

  const leftGloveProps = useAnimatedProps(() => ({
    transform: [{ translateX: glovesLeftPos.value }]
  }));

  const rightGloveProps = useAnimatedProps(() => ({
    transform: [{ translateX: glovesRightPos.value }]
  }));

  const labCoatProps = useAnimatedProps(() => ({
    opacity: labCoatOpacity.value
  }));

  const faceShieldProps = useAnimatedProps(() => ({
    transform: [{ translateY: faceShieldPos.value }]
  }));

  const centerX = width / 2;
  const centerY = height / 2;

  return (
    <View style={[styles.container, { width, height }]}>
      {/* Scientist Figure */}
      <Svg width={width} height={height}>
        <Defs>
          <ClipPath id="personClip">
            <Rect x={centerX - 60} y={centerY - 100} width="120" height="200" />
          </ClipPath>
        </Defs>

        {/* Head */}
        <Circle cx={centerX} cy={centerY - 50} r="30" fill="#FFDBAC" />

        {/* Eyes (hidden when goggles are on) */}
        {!equipment.goggles && (
          <>
            <Path d={`M${centerX - 15} ${centerY - 60} Q${centerX - 5} ${centerY - 65} M${centerX + 5} ${centerY - 60}`}
                  fill="none" stroke="#000" strokeWidth="2" />
            <Path d={`M${centerX + 5} ${centerY - 60} Q${centerX + 15} ${centerY - 65} M${centerX + 25} ${centerY - 60}`}
                  fill="none" stroke="#000" strokeWidth="2" />
          </>
        )}

        {/* Safety Goggles */}
        <AnimatedG animatedProps={gogglesProps}>
          <Path
            d={`M${centerX - 25} ${centerY - 60} Q${centerX} ${centerY - 75} Q${centerX + 25} ${centerY - 60}
                Q${centerX + 20} ${centerY - 40} Q${centerX} ${centerY - 35} Q${centerX - 20} ${centerY - 40} Z`}
            fill="#A0D0FF"
            opacity="0.7"
            stroke="#555"
          />
          <Path d={`M${centerX} ${centerY - 50} L${centerX} ${centerY - 45}`} stroke="#555" strokeWidth="2" />
        </AnimatedG>

        {/* Face Shield */}
        <AnimatedG animatedProps={faceShieldProps}>
          <Path
            d={`M${centerX - 35} ${centerY - 80} Q${centerX} ${centerY - 90} Q${centerX + 35} ${centerY - 80}
                Q${centerX + 40} ${centerY - 20} Q${centerX} ${centerY - 10} Q${centerX - 40} ${centerY - 20} Z`}
            fill="#FFFFFF"
            opacity="0.4"
            stroke="#CCC"
          />
        </AnimatedG>

        {/* Body */}
        <Path d={`M${centerX - 20} ${centerY - 20} L${centerX + 20} ${centerY - 20}
                  L${centerX + 15} ${centerY + 80} L${centerX - 15} ${centerY + 80} Z`}
              fill="#4A7CFF" />

        {/* Lab Coat */}
        <AnimatedPath
          animatedProps={labCoatProps}
          d={`M${centerX - 25} ${centerY - 20} L${centerX + 25} ${centerY - 20}
              L${centerX + 20} ${centerY + 80} L${centerX - 20} ${centerY + 80} Z`}
          fill="white"
          stroke="#EEE"
          strokeWidth="2"
        />

        {/* Arms */}
        <Path d={`M${centerX + 20} ${centerY - 10} L${centerX + 50} ${centerY - 20}
                  L${centerX + 45} ${centerY + 10} L${centerX + 20} ${centerY + 20} Z`}
              fill="#FFDBAC" />
        <Path d={`M${centerX - 20} ${centerY - 10} L${centerX - 50} ${centerY - 20}
                  L${centerX - 45} ${centerY + 10} L${centerX - 20} ${centerY + 20} Z`}
              fill="#FFDBAC" />

        {/* Left Glove */}
        <AnimatedG animatedProps={leftGloveProps}>
          <Path
            d={`M${centerX - 60} ${centerY - 30} L${centerX - 40} ${centerY - 20}
                L${centerX - 45} ${centerY + 10} L${centerX - 65} ${centerY} Z`}
            fill={equipment.gloves ? "#00AAFF" : "#FFDBAC"}
          />
        </AnimatedG>

        {/* Right Glove */}
        <AnimatedG animatedProps={rightGloveProps}>
          <Path
            d={`M${centerX + 60} ${centerY - 30} L${centerX + 40} ${centerY - 20}
                L${centerX + 45} ${centerY + 10} L${centerX + 65} ${centerY} Z`}
            fill={equipment.gloves ? "#00AAFF" : "#FFDBAC"}
          />
        </AnimatedG>

        {/* Legs */}
        <Rect x={centerX - 15} y={centerY + 80} width="30" height="60" fill="#333" />
        <Rect x={centerX - 20} y={centerY + 135} width="40" height="15" rx="7" fill="#444" />
      </Svg>

      {/* Equipment Controls */}
      <View style={styles.controlsContainer}>
        <View style={styles.buttonRow}>
          <TouchableOpacity
            style={[styles.button, equipment.goggles && styles.activeButton]}
            onPress={() => toggleEquipment('goggles')}
          >
            <Text style={styles.buttonText}>🥽 Goggles</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.button, equipment.gloves && styles.activeButton]}
            onPress={() => toggleEquipment('gloves')}
          >
            <Text style={styles.buttonText}>🧤 Gloves</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.buttonRow}>
          <TouchableOpacity
            style={[styles.button, equipment.labCoat && styles.activeButton]}
            onPress={() => toggleEquipment('labCoat')}
          >
            <Text style={styles.buttonText}>🥼 Lab Coat</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.button, equipment.faceShield && styles.activeButton]}
            onPress={() => toggleEquipment('faceShield')}
          >
            <Text style={styles.buttonText}>🛡️ Face Shield</Text>
          </TouchableOpacity>
        </View>

        {/* Experiment Presets */}
        <View style={styles.presetContainer}>
          <Text style={styles.presetTitle}>Quick Setup:</Text>
          <View style={styles.presetButtons}>
            {Object.keys(experimentRequirements).map((type) => (
              <TouchableOpacity
                key={type}
                style={[styles.presetButton, experimentType === type && styles.activePreset]}
                onPress={() => setExperimentPreset(type as keyof typeof experimentRequirements)}
              >
                <Text style={styles.presetText}>{type.toUpperCase()}</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Safety Status */}
        <View style={styles.statusContainer}>
          <Text style={[styles.statusText, { color: checkSafety() ? '#4CAF50' : '#F44336' }]}>
            {checkSafety() ? "✅ Fully Protected" : "⚠️ Missing Safety Gear"}
          </Text>

          {!checkSafety() && (
            <Text style={styles.missingText}>
              Missing: {requiredEquipment.filter(item => !equipment[item]).join(', ')}
            </Text>
          )}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  controlsContainer: {
    position: 'absolute',
    bottom: 20,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  buttonRow: {
    flexDirection: 'row',
    marginBottom: 10,
    gap: 10,
  },
  button: {
    padding: 10,
    backgroundColor: '#EEE',
    borderRadius: 8,
    minWidth: 100,
    alignItems: 'center',
  },
  activeButton: {
    backgroundColor: '#A0FFA0',
  },
  buttonText: {
    fontSize: 12,
    fontWeight: '600',
  },
  presetContainer: {
    marginTop: 15,
    alignItems: 'center',
  },
  presetTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  presetButtons: {
    flexDirection: 'row',
    gap: 8,
  },
  presetButton: {
    padding: 8,
    backgroundColor: '#DDD',
    borderRadius: 6,
    minWidth: 60,
    alignItems: 'center',
  },
  activePreset: {
    backgroundColor: '#FFB74D',
  },
  presetText: {
    fontSize: 10,
    fontWeight: '600',
  },
  statusContainer: {
    marginTop: 15,
    alignItems: 'center',
  },
  statusText: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  missingText: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
});

export default SafetyPerson;

---- File Content End ----


=== File: Condenser.tsx ===
Path: lab\assets\specialized\Condenser.tsx
---- File Content Start ----
// src/data/animations/lab/assets/specialized/Condenser.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Rect, Path, Defs, LinearGradient, Stop, Circle, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming, withRepeat } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);

interface CondenserProps {
  width?: number;
  height?: number;
}

export const Condenser: React.FC<CondenserProps> = ({ width = 200, height = 200 }) => {
  const [active, setActive] = useState(false);
  const waterFlow = useSharedValue(0);

  const toggleFlow = () => {
    setActive(!active);
    waterFlow.value = active ?
      withTiming(0, { duration: 500 }) :
      withRepeat(withTiming(1, { duration: 2000 }), -1, true);
  };

  const waterProps = useAnimatedProps(() => ({
    strokeDashoffset: waterFlow.value * 100
  }));

  return (
    <Pressable onPress={toggleFlow}>
      <Svg width={width} height={height}>
        <Defs>
          <LinearGradient id="glass" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#ffffff" stopOpacity="0.2"/>
            <Stop offset="1" stopColor="#f0f0f0" stopOpacity="0.1"/>
          </LinearGradient>
        </Defs>

        {/* Outer tube */}
        <Path
          d="M50 50 L150 50 L160 150 L40 150 Z"
          fill="url(#glass)"
          stroke="#aaa"
        />

        {/* Inner tube */}
        <Path
          d="M70 70 L130 70 L120 130 L80 130 Z"
          fill="none"
          stroke="#555"
          strokeWidth="2"
        />

        {/* Water inlet/outlet */}
        <Rect x="30" y="80" width="20" height="5" rx="2" fill="#555" />
        <Rect x="150" y="110" width="20" height="5" rx="2" fill="#555" />

        {/* Water flow animation */}
        <AnimatedPath
          d="M40 85 L60 85 L70 75 L130 75 L140 85 L160 85"
          stroke="#2a9df4"
          strokeWidth="3"
          strokeDasharray="10,5"
          fill="none"
          animatedProps={waterProps}
        />

        {/* Status indicator */}
        <Circle cx="180" cy="30" r="10" fill={active ? "#0f0" : "#f00"} />
        <Text x="180" y="50" textAnchor="middle" fill="black" fontSize="10">
          {active ? "ON" : "OFF"}
        </Text>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: Microscope.tsx ===
Path: lab\assets\specialized\Microscope.tsx
---- File Content Start ----
// src/data/animations/lab/assets/specialized/Microscope.tsx

import React, { useState } from 'react';
import { PanResponder, View } from 'react-native';
import Svg, {
  Rect,
  Circle,
  Path,
  G,
  Text,
  Defs,
  RadialGradient,
  LinearGradient,
  Stop,
  ClipPath
} from 'react-native-svg';
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withTiming,
  interpolate,
  withSpring
} from 'react-native-reanimated';

const AnimatedG = Animated.createAnimatedComponent(G);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

interface MicroscopeProps {
  width?: number;
  height?: number;
  onFocusChange?: (focus: number) => void;
  magnification?: number;
}

export const Microscope: React.FC<MicroscopeProps> = ({
  width = 250,
  height = 300,
  onFocusChange,
  magnification = 400
}) => {
  const [focus, setFocus] = useState(50);
  const [selectedObjective, setSelectedObjective] = useState(1); // 0: 4x, 1: 10x, 2: 40x, 3: 100x

  const focusPosition = useSharedValue(50);
  const objectiveRotation = useSharedValue(0);
  const sampleOpacity = useSharedValue(0.8);
  const sampleScale = useSharedValue(1);

  const objectives = [
    { mag: '4x', color: '#ff0000' },
    { mag: '10x', color: '#00ff00' },
    { mag: '40x', color: '#0000ff' },
    { mag: '100x', color: '#ffff00' }
  ];

  const updateFocus = (newFocus: number) => {
    newFocus = Math.min(100, Math.max(0, newFocus));
    focusPosition.value = withTiming(newFocus, { duration: 300 });

    // Calculate clarity and scale based on focus
    const clarity = 1 - Math.abs(50 - newFocus) / 50;
    sampleOpacity.value = withTiming(0.4 + clarity * 0.6, { duration: 300 });
    sampleScale.value = withTiming(0.8 + clarity * 0.4, { duration: 300 });

    setFocus(newFocus);
    onFocusChange?.(newFocus);
  };

  const rotateObjective = () => {
    const nextObjective = (selectedObjective + 1) % 4;
    setSelectedObjective(nextObjective);
    objectiveRotation.value = withSpring(nextObjective * 90, {
      damping: 10,
      stiffness: 100,
    });
  };

  const focusPanResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updateFocus(focus + gesture.dy / -2);
    }
  });

  const focusKnobProps = useAnimatedProps(() => ({
    transform: [{ rotate: `${focusPosition.value * 3.6}deg` }]
  }));

  const objectiveProps = useAnimatedProps(() => ({
    transform: [{ rotate: `${objectiveRotation.value}deg` }]
  }));

  const sampleProps = useAnimatedProps(() => ({
    opacity: sampleOpacity.value,
    transform: [{ scale: sampleScale.value }]
  }));

  const baseWidth = width * 0.7;
  const centerX = width / 2;

  return (
    <View style={{ width, height }}>
      <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
        <Defs>
          <LinearGradient id="metalGradient" x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor="#e8e8e8" />
            <Stop offset="0.5" stopColor="#d0d0d0" />
            <Stop offset="1" stopColor="#b0b0b0" />
          </LinearGradient>

          <RadialGradient id="lensGradient" cx="50%" cy="50%" r="50%">
            <Stop offset="0" stopColor="#ffffff" stopOpacity="0.8" />
            <Stop offset="70" stopColor="#e0e0e0" stopOpacity="0.6" />
            <Stop offset="100" stopColor="#000000" stopOpacity="0.3" />
          </RadialGradient>

          <LinearGradient id="armGradient" x1="0" y1="0" x2="1" y2="0">
            <Stop offset="0" stopColor="#c0c0c0" />
            <Stop offset="0.5" stopColor="#a0a0a0" />
            <Stop offset="1" stopColor="#808080" />
          </LinearGradient>

          <ClipPath id="stageClip">
            <Rect x={centerX - 30} y={height * 0.55} width="60" height="30" />
          </ClipPath>
        </Defs>

        {/* Base */}
        <Path
          d={`M${centerX - baseWidth/2} ${height * 0.9}
              L${centerX + baseWidth/2} ${height * 0.9}
              L${centerX + baseWidth/2 - 10} ${height * 0.95}
              L${centerX - baseWidth/2 + 10} ${height * 0.95} Z`}
          fill="url(#metalGradient)"
          stroke="#999"
          strokeWidth="1"
        />

        {/* Pillar */}
        <Rect
          x={centerX - 8}
          y={height * 0.25}
          width="16"
          height={height * 0.65}
          fill="url(#metalGradient)"
          stroke="#999"
        />

        {/* Arm */}
        <Path
          d={`M${centerX} ${height * 0.25}
              Q${centerX + 20} ${height * 0.22}, ${centerX + 40} ${height * 0.25}
              L${centerX + 40} ${height * 0.45}
              Q${centerX + 35} ${height * 0.47}, ${centerX + 30} ${height * 0.45}
              L${centerX + 30} ${height * 0.27}
              L${centerX} ${height * 0.3} Z`}
          fill="url(#armGradient)"
          stroke="#777"
          strokeWidth="1"
        />

        {/* Stage */}
        <Rect
          x={centerX - 40}
          y={height * 0.55}
          width="80"
          height="8"
          fill="url(#metalGradient)"
          stroke="#999"
          rx="2"
        />

        {/* Stage clips */}
        <Rect x={centerX - 35} y={height * 0.52} width="8" height="15" fill="#666" rx="2" />
        <Rect x={centerX + 27} y={height * 0.52} width="8" height="15" fill="#666" rx="2" />

        {/* Slide */}
        <Rect
          x={centerX - 25}
          y={height * 0.51}
          width="50"
          height="3"
          fill="#f0f0f0"
          stroke="#ccc"
          rx="1"
        />

        {/* Sample on slide */}
        <AnimatedG animatedProps={sampleProps} clipPath="url(#stageClip)">
          <Circle cx={centerX - 5} cy={height * 0.525} r="3" fill="#ff6b6b" opacity="0.7" />
          <Circle cx={centerX + 5} cy={height * 0.525} r="2" fill="#4ecdc4" opacity="0.7" />
          <Circle cx={centerX} cy={height * 0.535} r="2.5" fill="#45b7d1" opacity="0.7" />
          <Circle cx={centerX - 8} cy={height * 0.535} r="1.5" fill="#96ceb4" opacity="0.7" />
          <Circle cx={centerX + 8} cy={height * 0.518} r="1.8" fill="#feca57" opacity="0.7" />
        </AnimatedG>

        {/* Objective turret */}
        <AnimatedG
          animatedProps={objectiveProps}
          style={{ transformOrigin: `${centerX + 30}px ${height * 0.47}px` }}
        >
          <Circle
            cx={centerX + 30}
            cy={height * 0.47}
            r="25"
            fill="url(#metalGradient)"
            stroke="#777"
            strokeWidth="2"
          />

          {/* Objective lenses */}
          {objectives.map((obj, index) => {
            const angle = (index * 90) * (Math.PI / 180);
            const objX = centerX + 30 + 18 * Math.cos(angle);
            const objY = height * 0.47 + 18 * Math.sin(angle);

            return (
              <G key={index}>
                <Circle
                  cx={objX}
                  cy={objY}
                  r="8"
                  fill={obj.color}
                  stroke="#333"
                  strokeWidth="1"
                />
                <Text
                  x={objX}
                  y={objY + 2}
                  fontSize="6"
                  fill="white"
                  textAnchor="middle"
                  fontWeight="bold"
                >
                  {obj.mag}
                </Text>
              </G>
            );
          })}
        </AnimatedG>

        {/* Current objective lens (active) */}
        <Circle
          cx={centerX + 30}
          cy={height * 0.47 + 18}
          r="12"
          fill={objectives[selectedObjective].color}
          stroke="#333"
          strokeWidth="2"
        />
        <Circle
          cx={centerX + 30}
          cy={height * 0.47 + 18}
          r="8"
          fill="url(#lensGradient)"
        />

        {/* Eyepiece */}
        <Rect
          x={centerX - 12}
          y={height * 0.1}
          width="24"
          height="40"
          fill="url(#metalGradient)"
          stroke="#777"
          rx="3"
        />
        <Circle
          cx={centerX}
          cy={height * 0.08}
          r="12"
          fill="#333"
          stroke="#555"
          strokeWidth="2"
        />
        <Circle
          cx={centerX}
          cy={height * 0.08}
          r="8"
          fill="#000"
        />

        {/* Focus knobs */}
        <G {...focusPanResponder.panHandlers}>
          <AnimatedCircle
            cx={centerX - 25}
            cy={height * 0.65}
            r="12"
            fill="url(#metalGradient)"
            stroke="#777"
            strokeWidth="2"
            animatedProps={focusKnobProps}
          />
          <AnimatedCircle
            cx={centerX - 25}
            cy={height * 0.65}
            r="8"
            fill="#999"
            animatedProps={focusKnobProps}
          />
          <AnimatedG animatedProps={focusKnobProps}>
            <Rect
              x={centerX - 26}
              y={height * 0.65 - 8}
              width="2"
              height="6"
              fill="#ddd"
            />
          </AnimatedG>
        </G>

        {/* Fine focus knob */}
        <Circle
          cx={centerX - 40}
          cy={height * 0.65}
          r="8"
          fill="url(#metalGradient)"
          stroke="#777"
          strokeWidth="1"
        />

        {/* Illumination control */}
        <Circle
          cx={centerX + 50}
          cy={height * 0.7}
          r="10"
          fill="#ffdd44"
          stroke="#cc9900"
          strokeWidth="2"
        />
        <Text
          x={centerX + 50}
          y={height * 0.73}
          fontSize="8"
          fill="#333"
          textAnchor="middle"
        >
          ☀
        </Text>

        {/* Info display */}
        <Rect
          x={width * 0.02}
          y={height * 0.02}
          width={width * 0.35}
          height={height * 0.2}
          fill="#000"
          stroke="#555"
          rx="3"
        />

        <Text x={width * 0.04} y={height * 0.06} fontSize="10" fill="#0f0" fontFamily="monospace">
          Magnification: {objectives[selectedObjective].mag}
        </Text>
        <Text x={width * 0.04} y={height * 0.09} fontSize="10" fill="#0f0" fontFamily="monospace">
          Focus: {focus.toFixed(1)}%
        </Text>
        <Text x={width * 0.04} y={height * 0.12} fontSize="10" fill="#0f0" fontFamily="monospace">
          Clarity: {((1 - Math.abs(50 - focus) / 50) * 100).toFixed(0)}%
        </Text>

        {/* Instructions */}
        <Text
          x={centerX}
          y={height - 5}
          fontSize="10"
          fill="#666"
          textAnchor="middle"
        >
          Drag focus knob | Tap objective turret
        </Text>

        {/* Objective turret click area */}
        <Circle
          cx={centerX + 30}
          cy={height * 0.47}
          r="25"
          fill="transparent"
          onPress={rotateObjective}
        />
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: MortarAndPestle.tsx ===
Path: lab\assets\specialized\MortarAndPestle.tsx
---- File Content Start ----
// src/data/animations/lab/assets/specialized/MortarAndPestle.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Path, G, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withRepeat, withTiming, Easing } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);
const AnimatedG = Animated.createAnimatedComponent(G);

interface MortarAndPestleProps {
  width?: number;
  height?: number;
}

export const MortarAndPestle: React.FC<MortarAndPestleProps> = ({ width = 200, height = 200 }) => {
  const [grinding, setGrinding] = useState(false);
  const rotation = useSharedValue(0);
  const particleY = useSharedValue(0);

  const startGrinding = () => {
    setGrinding(true);
    rotation.value = withRepeat(
      withTiming(360, { duration: 1000, easing: Easing.inOut(Easing.quad) }),
      -1, false
    );
    particleY.value = withRepeat(withTiming(10, { duration: 500 }), -1, true);

    setTimeout(() => {
      setGrinding(false);
      rotation.value = withTiming(0);
      particleY.value = 0;
    }, 3000);
  };

  const pestleProps = useAnimatedProps(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
    transformOrigin: '100 50'
  }));

  const particleProps = useAnimatedProps(() => ({
    transform: [{ translateY: particleY.value }]
  }));

  return (
    <Pressable onPress={startGrinding}>
      <Svg width={width} height={height}>
        {/* Mortar */}
        <Path
          d="M50 100 Q100 150, 150 100 L150 180 L50 180 Z"
          fill="#a0a0a0"
          stroke="#666"
        />

        {/* Pestle */}
        <AnimatedG animatedProps={pestleProps}>
          <Path
            d="M90 30 L110 30 L105 180 L95 180 Z"
            fill="#888"
            stroke="#555"
          />
          <Circle cx="100" cy="30" r="10" fill="#777" />
        </AnimatedG>

        {/* Particles */}
        {grinding && (
          <AnimatedG animatedProps={particleProps}>
            <Circle cx="80" cy="120" r="3" fill="#fff" opacity="0.7" />
            <Circle cx="120" cy="130" r="2" fill="#fff" opacity="0.5" />
            <Circle cx="100" cy="125" r="4" fill="#fff" opacity="0.9" />
          </AnimatedG>
        )}

        {/* Ground material */}
        <Path
          d="M60 150 Q100 130, 140 150 L140 170 L60 170 Z"
          fill="#d4a76a"
          opacity="0.7"
        />

        {/* Status text */}
        <Text x="100" y="30" textAnchor="middle" fill="black">
          {grinding ? "Grinding..." : "Press to Grind"}
        </Text>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: RingStand.tsx ===
Path: lab\assets\specialized\RingStand.tsx
---- File Content Start ----
// src/data/animations/lab/assets/specialized/RingStand.tsx
import React, { useState } from 'react';
import { PanResponder, View } from 'react-native';
import Svg, { Rect, Circle, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedG = Animated.createAnimatedComponent(G);

interface RingStandProps {
  width?: number;
  height?: number;
}

export const RingStand: React.FC<RingStandProps> = ({ width = 200, height = 250 }) => {
  const [height_pos, setHeight] = useState(50);
  const clampPosition = useSharedValue(100);

  const updateHeight = (newHeight: number) => {
    newHeight = Math.min(150, Math.max(50, newHeight));
    clampPosition.value = withTiming(newHeight, { duration: 300 });
    setHeight(newHeight);
  };

  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderMove: (evt, gesture) => {
      updateHeight(height_pos + gesture.dy / -2);
    }
  });

  const clampProps = useAnimatedProps(() => ({
    transform: [{ translateY: clampPosition.value }]
  }));

  return (
    <View {...panResponder.panHandlers}>
      <Svg width={width} height={height}>
        {/* Base */}
        <Rect x="50" y="220" width="100" height="20" rx="5" fill="#555" />

        {/* Rod */}
        <Rect x="95" y="50" width="10" height="170" fill="#777" />

        {/* Clamp */}
        <AnimatedG animatedProps={clampProps}>
          <Rect x="80" y="0" width="40" height="15" fill="#888" rx="3" />
          <Rect x="85" y="15" width="30" height="10" fill="#666" />
          <Circle cx="100" cy="5" r="5" fill="#aaa" />
        </AnimatedG>

        {/* Ring */}
        <Circle cx="100" cy={height_pos + 50} r="30" fill="none" stroke="#666" strokeWidth="5" />

        {/* Height indicator */}
        <Text x="150" y={height_pos + 50} fill="black" fontSize="12">
          {height_pos}mm
        </Text>
      </Svg>
    </View>
  );
};

---- File Content End ----


=== File: Tongs.tsx ===
Path: lab\assets\specialized\Tongs.tsx
---- File Content Start ----
// src/data/animations/lab/assets/specialized/Tongs.tsx
import React, { useState } from 'react';
import { Pressable, View } from 'react-native';
import Svg, { Path, Circle, Text } from 'react-native-svg';
import Animated, { useSharedValue, useAnimatedProps, withTiming } from 'react-native-reanimated';

const AnimatedPath = Animated.createAnimatedComponent(Path);

interface TongsProps {
  width?: number;
  height?: number;
}

export const Tongs: React.FC<TongsProps> = ({ width = 200, height = 150 }) => {
  const [gripping, setGripping] = useState(false);
  const gripRotation = useSharedValue(0);

  const toggleGrip = () => {
    setGripping(!gripping);
    gripRotation.value = withTiming(gripping ? 0 : 15, { duration: 300 });
  };

  const leftArmProps = useAnimatedProps(() => ({
    transform: [{ rotate: `${-gripRotation.value}deg` }],
    transformOrigin: '100 50'
  }));

  const rightArmProps = useAnimatedProps(() => ({
    transform: [{ rotate: `${gripRotation.value}deg` }],
    transformOrigin: '100 50'
  }));

  return (
    <Pressable onPress={toggleGrip}>
      <Svg width={width} height={height}>
        {/* Handle */}
        <Path d="M90 30 L110 30 L110 50 L90 50 Z" fill="#666" />

        {/* Arms */}
        <AnimatedPath
          d="M90 50 L70 100 L80 110 L100 60 Z"
          fill="#888"
          stroke="#555"
          animatedProps={leftArmProps}
        />
        <AnimatedPath
          d="M110 50 L130 100 L120 110 L100 60 Z"
          fill="#888"
          stroke="#555"
          animatedProps={rightArmProps}
        />

        {/* Gripping object */}
        {gripping && (
          <Circle cx="100" cy="120" r="10" fill="#ff0000" />
        )}

        {/* Status text */}
        <Text x="100" y="30" textAnchor="middle" fill="black">
          {gripping ? "Gripping" : "Open"}
        </Text>
      </Svg>
    </Pressable>
  );
};

---- File Content End ----


=== File: InteractiveEquipment.tsx ===
Path: lab\components\InteractiveEquipment.tsx
---- File Content Start ----
// src/data/animations/lab/components/InteractiveEquipment.tsx - UPDATED

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { BunsenBurnerEnhanced, BeakerEnhanced, FlaskEnhanced } from '../assets/enhanced';
import { ThermometerSVG } from '../assets'; // Keep existing until replaced
import { useLabAnimation } from '../LabAnimationProvider';

interface InteractiveEquipmentProps {
  type: 'bunsenBurner' | 'beaker' | 'thermometer' | 'flask';
  x: number;
  y: number;
  width: number;
  height: number;
  // Remove onInteraction - no more direct touch heating
  autoHeat?: boolean; // For demo purposes
  heatCycle?: number; // Automatic heating cycle in seconds
  liquidLevel?: number; // For beaker/flask
  liquidColor?: string; // For beaker/flask
}

export const InteractiveEquipment: React.FC<InteractiveEquipmentProps> = ({
  type,
  x,
  y,
  width,
  height,
  autoHeat = false,
  heatCycle = 10,
  liquidLevel = 60,
  liquidColor
}) => {
  const labAnimation = useLabAnimation();
  const [heatSourceId, setHeatSourceId] = useState<string | null>(null);
  const [localTemp, setLocalTemp] = useState(25);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isHeating, setIsHeating] = useState(false);
  const [heatIntensity, setHeatIntensity] = useState(0);

  // Safely initialize equipment
  useEffect(() => {
    try {
      if (!labAnimation || isInitialized) return;

      if (type === 'bunsenBurner') {
        // Create heat source that will be controlled by physics, not touch
        const id = labAnimation.addHeatSource({
          x: x + width / 2,
          y: y - 10,
          radius: 60,
          intensity: 0,
          temperature: 0,
          isActive: false
        });
        setHeatSourceId(id);
      } else if (type === 'beaker') {
        // Create container boundary
        labAnimation.addBoundary({
          type: 'container',
          shape: 'rectangle',
          x: x + 8,
          y: y + height * 0.3,
          width: width - 16,
          height: height * 0.6,
          restitution: 0.3,
          friction: 0.1
        });

        // Add water particles
        for (let i = 0; i < 15; i++) {
          labAnimation.addParticle({
            x: x + 15 + Math.random() * (width - 30),
            y: y + height * 0.4 + Math.random() * (height * 0.4),
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: 2 + Math.random() * 2,
            mass: 1,
            color: '#4A90E2',
            maxSpeed: 1,
            vibrationIntensity: 0.1,
            temperature: 25,
            elementType: 'H2O'
          });
        }
      }

      setIsInitialized(true);
    } catch (error) {
      console.error('Failed to initialize equipment:', error);
    }
  }, [type, x, y, width, height, labAnimation, isInitialized]);

  // Auto-heating cycle for demonstration
  useEffect(() => {
    if (!autoHeat || type !== 'bunsenBurner' || !heatSourceId || !labAnimation) return;

    const interval = setInterval(() => {
      setIsHeating(prev => {
        const newHeating = !prev;

        try {
          if (newHeating) {
            // Start heating cycle
            labAnimation.updateHeatSource(heatSourceId, {
              intensity: 0.8,
              temperature: 75,
              isActive: true
            });
            setHeatIntensity(80);
          } else {
            // Stop heating cycle
            labAnimation.updateHeatSource(heatSourceId, {
              intensity: 0,
              temperature: 0,
              isActive: false
            });
            setHeatIntensity(0);
          }
        } catch (error) {
          console.error('Failed to update heat source:', error);
        }

        return newHeating;
      });
    }, heatCycle * 1000);

    return () => clearInterval(interval);
  }, [autoHeat, heatCycle, type, heatSourceId, labAnimation]);

  // Update local temperature for thermometer
  useEffect(() => {
    if (type === 'thermometer' && labAnimation && isInitialized) {
      const interval = setInterval(() => {
        try {
          const temp = labAnimation.getTemperatureAt(x + width / 2, y + height / 2);
          setLocalTemp(temp);
        } catch (error) {
          console.error('Failed to get temperature:', error);
        }
      }, 500);
      return () => clearInterval(interval);
    }
  }, [type, x, y, width, height, labAnimation, isInitialized]);

  // Render equipment based on type
  const renderEquipment = () => {
    try {
      switch (type) {
        case 'bunsenBurner':
          return (
            <BunsenBurnerEnhanced
              width={width}
              height={height}
              isActive={isHeating}
              intensity={heatIntensity}
              temperature={localTemp}
            />
          );

        case 'beaker':
          return (
            <BeakerEnhanced
              size={Math.min(width, height)}
              liquidLevel={liquidLevel}
              liquidColor={liquidColor}
              hasBubbles={localTemp > 80}
              temperature={localTemp}
            />
          );

        case 'flask':
          return (
            <FlaskEnhanced
              size={Math.min(width, height)}
              liquidLevel={liquidLevel}
              liquidColor={liquidColor || '#81C784'}
              isHeating={isHeating}
              hasBubbles={localTemp > 70}
              temperature={localTemp}
            />
          );

        case 'thermometer':
          return (
            <ThermometerSVG
              width={width}
              height={height}
              temperature={localTemp}
            />
          );

        default:
          return (
            <View style={{
              width,
              height,
              backgroundColor: '#ddd',
              justifyContent: 'center',
              alignItems: 'center'
            }}>
              <Text style={{ fontSize: 12, color: '#666' }}>{type}</Text>
            </View>
          );
      }
    } catch (error) {
      console.error('Failed to render equipment:', error);
      return (
        <View style={{
          width,
          height,
          backgroundColor: '#f00',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <Text style={{ fontSize: 10, color: '#fff' }}>Error</Text>
        </View>
      );
    }
  };

  const getLabel = () => {
    switch (type) {
      case 'bunsenBurner':
        return `Bunsen Burner ${isHeating ? '(Heating)' : '(Off)'}`;
      case 'beaker':
        return `Beaker (${Math.round(localTemp)}°C)`;
      case 'flask':
        return `Flask (${Math.round(localTemp)}°C)`;
      case 'thermometer':
        return `${Math.round(localTemp)}°C`;
      default:
        return '';
    }
  };

  // Don't render until initialized
  if (!isInitialized && type === 'bunsenBurner') {
    return (
      <View style={[styles.container, { left: x, top: y, width, height }]}>
        <View style={{
          width,
          height,
          backgroundColor: '#ddd',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <Text style={{ fontSize: 10, color: '#666' }}>Loading...</Text>
        </View>
      </View>
    );
  }

  return (
    <View
      style={[
        styles.container,
        {
          left: x,
          top: y,
          width,
          height,
        },
        isHeating && styles.activeContainer
      ]}
    >
      {renderEquipment()}

      <View style={styles.label}>
        <Text style={styles.labelText}>{getLabel()}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
  },
  activeContainer: {
    // Visual feedback for active state
    shadowColor: '#FF6B35',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.6,
    shadowRadius: 8,
    elevation: 8,
  },
  label: {
    position: 'absolute',
    bottom: -25,
    left: '50%',
    transform: [{ translateX: -50 }],
    backgroundColor: 'rgba(255,255,255,0.9)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 3,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  labelText: {
    fontSize: 10,
    color: '#4a5568',
    fontWeight: 'bold',
    textAlign: 'center',
  },
});

---- File Content End ----


=== File: LabCanvas.tsx ===
Path: lab\components\LabCanvas.tsx
---- File Content Start ----

import React from 'react';
import { View } from 'react-native';
import Svg, { Circle, G } from 'react-native-svg';
import { useLabAnimation } from '../LabAnimationProvider';

interface LabCanvasProps {
  width: number;
  height: number;
  showTemperatureField?: boolean;
  children?: React.ReactNode;
}

export const LabCanvas: React.FC<LabCanvasProps> = ({
  width,
  height,
  showTemperatureField = false,
  children
}) => {
  const { particles, heatSources } = useLabAnimation();

  return (
    <View style={{ width, height, position: 'relative' }}>
      {/* Temperature Field Visualization (Optional) */}
      {showTemperatureField && (
        <View style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none' }}>
          <Svg width={width} height={height} style={{ position: 'absolute' }}>
            {heatSources.map(heatSource => (
              heatSource.isActive && (
                <Circle
                  key={heatSource.id}
                  cx={heatSource.x}
                  cy={heatSource.y}
                  r={heatSource.radius}
                  fill="#ff6b6b"
                  opacity={0.1 + heatSource.intensity * 0.15}
                />
              )
            ))}
          </Svg>
        </View>
      )}

      {/* Particles Canvas */}
      <View style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}>
        <Svg width={width} height={height}>
          <G>
            {particles.map(particle => (
              <Circle
                key={particle.id}
                cx={particle.x}
                cy={particle.y}
                r={particle.radius}
                fill={particle.color}
                opacity="0.8"
              />
            ))}
          </G>
        </Svg>
      </View>

      {/* Children (UI overlays) */}
      {children && (
        <View style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}>
          {children}
        </View>
      )}
    </View>
  );
};

---- File Content End ----


=== File: LabEquipment.tsx ===
Path: lab\components\LabEquipment.tsx
---- File Content Start ----
// ===========================================
// 11. src/data/animations/lab/components/LabExperiment.tsx
// ===========================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LabCanvas } from './LabCanvas';
import { InteractiveEquipment } from './InteractiveEquipment';

interface LabHeatingExperimentProps {
  width?: number;
  height?: number;
  showControls?: boolean;
}

export const LabHeatingExperiment: React.FC<LabHeatingExperimentProps> = ({
  width = 350,
  height = 300,
  showControls = true
}) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Chemistry Lab Experiment</Text>

      <LabCanvas width={width} height={height} showTemperatureField={true}>
        <InteractiveEquipment
          type="bunsenBurner"
          x={80}
          y={250}
          width={60}
          height={80}
        />

        <InteractiveEquipment
          type="beaker"
          x={60}
          y={120}
          width={100}
          height={140}
        />

        <InteractiveEquipment
          type="thermometer"
          x={180}
          y={140}
          width={25}
          height={120}
        />
      </LabCanvas>

      {showControls && (
        <Text style={styles.instructions}>
          Touch and hold the Bunsen burner to heat the water!
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#f8f9fa',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2d3748',
    marginBottom: 16,
    textAlign: 'center',
  },
  instructions: {
    fontSize: 14,
    color: '#4a5568',
    textAlign: 'center',
    marginTop: 12,
  },
});

---- File Content End ----


=== File: LabExperiments.tsx ===
Path: lab\components\LabExperiments.tsx
---- File Content Start ----
// ===========================================
// 3. src/data/animations/lab/components/LabExperiment.tsx - SAFER VERSION
// ===========================================

import React, { useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { LabCanvas } from './LabCanvas';
import { InteractiveEquipment } from './InteractiveEquipment';

interface LabHeatingExperimentProps {
  width?: number;
  height?: number;
  showControls?: boolean;
}

export const LabHeatingExperiment: React.FC<LabHeatingExperimentProps> = ({
  width = 350,
  height = 300,
  showControls = true
}) => {
  const [error, setError] = useState<string | null>(null);

  if (error) {
    return (
      <View style={styles.container}>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Lab Error: {error}</Text>
          <Text style={styles.errorSubtext}>Please try reloading the app</Text>
        </View>
      </View>
    );
  }

  try {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>Chemistry Lab Experiment</Text>

        <LabCanvas width={width} height={height} showTemperatureField={true}>
          <InteractiveEquipment
            type="bunsenBurner"
            x={80}
            y={250}
            width={60}
            height={80}
            onInteraction={(action) => {
              console.log('Bunsen burner interaction:', action);
            }}
          />

          <InteractiveEquipment
            type="beaker"
            x={60}
            y={120}
            width={100}
            height={140}
          />

          <InteractiveEquipment
            type="thermometer"
            x={180}
            y={140}
            width={25}
            height={120}
          />
        </LabCanvas>

        {showControls && (
          <Text style={styles.instructions}>
            Touch and hold the Bunsen burner to heat the water!
          </Text>
        )}
      </View>
    );
  } catch (error) {
    setError(error instanceof Error ? error.message : 'Unknown error');
    return null;
  }
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#f8f9fa',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#2d3748',
    marginBottom: 16,
    textAlign: 'center',
  },
  instructions: {
    fontSize: 14,
    color: '#4a5568',
    textAlign: 'center',
    marginTop: 12,
  },
  errorContainer: {
    padding: 20,
    backgroundColor: '#fed7d7',
    borderRadius: 8,
    alignItems: 'center',
  },
  errorText: {
    fontSize: 16,
    color: '#c53030',
    fontWeight: 'bold',
    marginBottom: 8,
  },
  errorSubtext: {
    fontSize: 14,
    color: '#9c4221',
  },
});

---- File Content End ----


=== File: LabPhysicsEngine.ts ===
Path: lab\core\LabPhysicsEngine.ts
---- File Content Start ----
// ===========================================
// 2. src/data/animations/lab/core/LabPhysicsEngine.ts
// ===========================================

import type { Particle, LabBoundary, HeatSource } from './labTypes';

const LabColors = {
  temperature: {
    cold: '#4A90E2',
    warm: '#F6AD55',
    hot: '#F56565'
  }
};

export class LabPhysicsEngine {
  private particles: Map<string, Particle> = new Map();
  private boundaries: Map<string, LabBoundary> = new Map();
  private heatSources: Map<string, HeatSource> = new Map();
  private width: number;
  private height: number;
  private globalTemperature: number = 25;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  // Particle Management
  addParticle(data: Omit<Particle, 'id'> & { id?: string }): string {
    const id = data.id || `particle_${Date.now()}_${Math.random()}`;
    const particle: Particle = {
      ...data,
      id,
      temperature: data.temperature || this.globalTemperature
    };
    this.particles.set(id, particle);
    return id;
  }

  removeParticle(id: string): void {
    this.particles.delete(id);
  }

  // Lab Equipment Management
  addBoundary(boundary: Omit<LabBoundary, 'id'>): string {
    const id = `boundary_${Date.now()}_${Math.random()}`;
    this.boundaries.set(id, { ...boundary, id });
    return id;
  }

  addHeatSource(heatSource: Omit<HeatSource, 'id'>): string {
    const id = `heat_${Date.now()}_${Math.random()}`;
    this.heatSources.set(id, { ...heatSource, id });
    return id;
  }

  updateHeatSource(id: string, updates: Partial<HeatSource>): void {
    const heatSource = this.heatSources.get(id);
    if (heatSource) {
      Object.assign(heatSource, updates);
    }
  }

  // Physics Update
  update(deltaTime: number): void {
    this.applyHeatEffects();
    this.updateParticles(deltaTime);
    this.applyBoundaryConstraints();
  }

  private applyHeatEffects(): void {
    this.particles.forEach(particle => {
      let maxTemp = this.globalTemperature;

      // Check heat sources
      this.heatSources.forEach(heatSource => {
        if (!heatSource.isActive) return;

        const dx = particle.x - heatSource.x;
        const dy = particle.y - heatSource.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < heatSource.radius) {
          const heatFactor = Math.max(0, 1 - distance / heatSource.radius);
          const heatContribution = heatSource.temperature * heatSource.intensity * heatFactor;
          maxTemp = Math.max(maxTemp, this.globalTemperature + heatContribution);
        }
      });

      // Gradually adjust particle temperature
      const tempDiff = maxTemp - particle.temperature;
      particle.temperature += tempDiff * 0.02; // Gradual heating/cooling

      // Update particle properties based on temperature
      this.updateParticleFromTemperature(particle);
    });
  }

  private updateParticleFromTemperature(particle: Particle): void {
    const tempFactor = (particle.temperature - 25) / 75; // 0-1 scale

    // Color changes with temperature
    if (particle.temperature < 40) {
      particle.color = LabColors.temperature.cold;
    } else if (particle.temperature < 70) {
      particle.color = LabColors.temperature.warm;
    } else {
      particle.color = LabColors.temperature.hot;
    }

    // Speed increases with temperature
    particle.maxSpeed = 0.5 + tempFactor * 2.0;

    // Add thermal motion
    const thermalForce = Math.max(0, tempFactor) * 0.3;
    particle.vx += (Math.random() - 0.5) * thermalForce;
    particle.vy += (Math.random() - 0.5) * thermalForce;
  }

  private updateParticles(deltaTime: number): void {
    this.particles.forEach(particle => {
      // Apply friction
      particle.vx *= 0.99;
      particle.vy *= 0.99;

      // Limit speed
      const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
      if (speed > particle.maxSpeed) {
        particle.vx = (particle.vx / speed) * particle.maxSpeed;
        particle.vy = (particle.vy / speed) * particle.maxSpeed;
      }

      // Update position
      particle.x += particle.vx * deltaTime * 20;
      particle.y += particle.vy * deltaTime * 20;

      // Boundary walls
      if (particle.x - particle.radius < 0) {
        particle.x = particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.x + particle.radius > this.width) {
        particle.x = this.width - particle.radius;
        particle.vx *= -0.8;
      }
      if (particle.y - particle.radius < 0) {
        particle.y = particle.radius;
        particle.vy *= -0.8;
      }
      if (particle.y + particle.radius > this.height) {
        particle.y = this.height - particle.radius;
        particle.vy *= -0.8;
      }
    });
  }

  private applyBoundaryConstraints(): void {
    this.particles.forEach(particle => {
      this.boundaries.forEach(boundary => {
        const collision = this.checkCollision(particle, boundary);
        if (collision.hasCollision && collision.normal) {
          // Move particle out
          particle.x -= collision.normal.x * collision.penetration;
          particle.y -= collision.normal.y * collision.penetration;

          // Reflect velocity
          const dot = particle.vx * collision.normal.x + particle.vy * collision.normal.y;
          particle.vx -= 2 * dot * collision.normal.x * boundary.restitution;
          particle.vy -= 2 * dot * collision.normal.y * boundary.restitution;

          // Apply friction
          particle.vx *= (1 - boundary.friction);
          particle.vy *= (1 - boundary.friction);
        }
      });
    });
  }

  private checkCollision(particle: Particle, boundary: LabBoundary): {
    hasCollision: boolean;
    normal?: { x: number; y: number };
    penetration: number;
  } {
    if (boundary.shape === 'rectangle' && boundary.width && boundary.height) {
      const left = boundary.x;
      const right = boundary.x + boundary.width;
      const top = boundary.y;
      const bottom = boundary.y + boundary.height;

      // Check if inside container
      if (particle.x + particle.radius > left &&
          particle.x - particle.radius < right &&
          particle.y + particle.radius > top &&
          particle.y - particle.radius < bottom) {

        // Find closest wall
        const distLeft = particle.x - left;
        const distRight = right - particle.x;
        const distTop = particle.y - top;
        const distBottom = bottom - particle.y;

        const minDist = Math.min(distLeft, distRight, distTop, distBottom);
        let normal: { x: number; y: number };

        if (minDist === distLeft) normal = { x: -1, y: 0 };
        else if (minDist === distRight) normal = { x: 1, y: 0 };
        else if (minDist === distTop) normal = { x: 0, y: -1 };
        else normal = { x: 0, y: 1 };

        return {
          hasCollision: true,
          normal,
          penetration: particle.radius - minDist
        };
      }
    }

    return { hasCollision: false, penetration: 0 };
  }

  // Getters
  getParticles(): Particle[] {
    return Array.from(this.particles.values());
  }

  getBoundaries(): LabBoundary[] {
    return Array.from(this.boundaries.values());
  }

  getHeatSources(): HeatSource[] {
    return Array.from(this.heatSources.values());
  }

  getTemperatureAt(x: number, y: number): number {
    let maxTemp = this.globalTemperature;

    this.heatSources.forEach(heatSource => {
      if (!heatSource.isActive) return;
      const distance = Math.sqrt((x - heatSource.x) ** 2 + (y - heatSource.y) ** 2);
      if (distance < heatSource.radius) {
        const factor = 1 - distance / heatSource.radius;
        maxTemp = Math.max(maxTemp, this.globalTemperature + heatSource.temperature * factor);
      }
    });

    return maxTemp;
  }

  reset(): void {
    this.particles.clear();
    this.boundaries.clear();
    this.heatSources.clear();
  }
}

---- File Content End ----


=== File: LabSceneBuilder.ts ===
Path: lab\core\LabSceneBuilder.ts
---- File Content Start ----
// src/data/animations/lab/LabSceneBuilder.ts - UPDATED WITH ALL EQUIPMENT

import React from 'react';
import { View } from 'react-native';

// Import all lab equipment
import {
  // Basic Equipment
  GraduatedCylinder,
  Pipette,
  Funnel,
  StirringRod,
  WatchGlass,
  PetriDish,

  // Heating & Temperature
  HotPlate,
  ThermometerStand,
  HeatingMantle,
  IceBath,

  // Measurement & Analysis
  BalanceScale,
  PHMeter,
  LitmusPaper,
  MeasuringSpoons,

  // Safety Equipment
  SafetyGoggles,
  SafetyGloves,
  FumeHood,
  FireExtinguisher,
  EmergencyShower,

  // Specialized Equipment
  Microscope,
  MortarAndPestle,
  Tongs,
  RingStand,
  Condenser,

  // Enhanced Equipment
  BunsenBurnerFromRepassets,
  BeakerFromRepassets,
  FlaskEnhanced,
  TestTubeRackEnhanced,
} from './assets';

// Import safety person
import { SafetyPerson } from './assets/safety/SafetyPerson';

export type EquipmentType =
  // Basic
  | 'graduated-cylinder' | 'pipette' | 'funnel' | 'stirring-rod' | 'watch-glass' | 'petri-dish'
  // Heating
  | 'hot-plate' | 'thermometer-stand' | 'heating-mantle' | 'ice-bath'
  // Measurement
  | 'balance-scale' | 'ph-meter' | 'litmus-paper' | 'measuring-spoons'
  // Safety
  | 'safety-goggles' | 'safety-gloves' | 'fume-hood' | 'fire-extinguisher' | 'emergency-shower' | 'safety-person'
  // Specialized
  | 'microscope' | 'mortar-pestle' | 'tongs' | 'ring-stand' | 'condenser'
  // Enhanced
  | 'bunsen-burner' | 'beaker' | 'flask' | 'test-tube-rack';

export interface EquipmentPosition {
  x: number;
  y: number;
  scale?: number;
  rotation?: number;
}

export interface LabEquipment {
  type: EquipmentType;
  id: string;
  position: EquipmentPosition;
  props?: Record<string, any>;
  interactions?: {
    draggable?: boolean;
    rotatable?: boolean;
    scalable?: boolean;
  };
}

export interface LabScene {
  id: string;
  name: string;
  description: string;
  equipment: LabEquipment[];
  background?: string;
  safetyLevel: 'low' | 'medium' | 'high' | 'critical';
  requiredSafetyEquipment?: Array<'goggles' | 'gloves' | 'labCoat' | 'faceShield'>;
  instructions?: string[];
}

export interface ExperimentScenario {
  id: string;
  title: string;
  scenes: LabScene[];
  learningObjectives: string[];
  estimatedTime: number; // minutes
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export class LabSceneBuilder {
  private scenes: Map<string, LabScene> = new Map();
  private equipment: Map<string, LabEquipment> = new Map();

  // Equipment registry with component mapping
  private equipmentRegistry = {
    // Basic Equipment
    'graduated-cylinder': GraduatedCylinder,
    'pipette': Pipette,
    'funnel': Funnel,
    'stirring-rod': StirringRod,
    'watch-glass': WatchGlass,
    'petri-dish': PetriDish,

    // Heating & Temperature
    'hot-plate': HotPlate,
    'thermometer-stand': ThermometerStand,
    'heating-mantle': HeatingMantle,
    'ice-bath': IceBath,

    // Measurement & Analysis
    'balance-scale': BalanceScale,
    'ph-meter': PHMeter,
    'litmus-paper': LitmusPaper,
    'measuring-spoons': MeasuringSpoons,

    // Safety Equipment
    'safety-goggles': SafetyGoggles,
    'safety-gloves': SafetyGloves,
    'fume-hood': FumeHood,
    'fire-extinguisher': FireExtinguisher,
    'emergency-shower': EmergencyShower,
    'safety-person': SafetyPerson,

    // Specialized Equipment
    'microscope': Microscope,
    'mortar-pestle': MortarAndPestle,
    'tongs': Tongs,
    'ring-stand': RingStand,
    'condenser': Condenser,

    // Enhanced Equipment
    'bunsen-burner': BunsenBurnerFromRepassets,
    'beaker': BeakerFromRepassets,
    'flask': FlaskEnhanced,
    'test-tube-rack': TestTubeRackEnhanced,
  };

  /**
   * Create a new lab scene
   */
  createScene(config: Omit<LabScene, 'equipment'> & { equipment?: LabEquipment[] }): LabScene {
    const scene: LabScene = {
      equipment: [],
      ...config,
    };

    this.scenes.set(scene.id, scene);
    return scene;
  }

  /**
   * Add equipment to a scene
   */
  addEquipment(sceneId: string, equipment: Omit<LabEquipment, 'id'>): LabEquipment {
    const scene = this.scenes.get(sceneId);
    if (!scene) {
      throw new Error(`Scene ${sceneId} not found`);
    }

    const equipmentItem: LabEquipment = {
      id: `${equipment.type}-${Date.now()}`,
      ...equipment,
    };

    scene.equipment.push(equipmentItem);
    this.equipment.set(equipmentItem.id, equipmentItem);

    return equipmentItem;
  }

  /**
   * Render a lab scene
   */
  renderScene(sceneId: string, containerWidth: number, containerHeight: number): React.ReactElement {
    const scene = this.scenes.get(sceneId);
    if (!scene) {
      throw new Error(`Scene ${sceneId} not found`);
    }

    return React.createElement(View, {
      style: {
        width: containerWidth,
        height: containerHeight,
        position: 'relative',
        backgroundColor: scene.background || '#f0f8ff',
      }
    }, scene.equipment.map(equipment => this.renderEquipment(equipment, containerWidth, containerHeight)));
  }

  /**
   * Render individual equipment
   */
  private renderEquipment(equipment: LabEquipment, containerWidth: number, containerHeight: number): React.ReactElement {
    const Component = this.equipmentRegistry[equipment.type];
    if (!Component) {
      throw new Error(`Equipment type ${equipment.type} not found in registry`);
    }

    const style = {
      position: 'absolute' as const,
      left: equipment.position.x,
      top: equipment.position.y,
      transform: [
        ...(equipment.position.scale ? [{ scale: equipment.position.scale }] : []),
        ...(equipment.position.rotation ? [{ rotate: `${equipment.position.rotation}deg` }] : []),
      ],
    };

    return React.createElement(View, {
      key: equipment.id,
      style,
    }, React.createElement(Component, {
      ...equipment.props,
      onInteraction: (type: string, data: any) => this.handleEquipmentInteraction(equipment.id, type, data),
    }));
  }

  /**
   * Handle equipment interactions
   */
  private handleEquipmentInteraction(equipmentId: string, interactionType: string, data: any): void {
    const equipment = this.equipment.get(equipmentId);
    if (!equipment) return;

    // Dispatch interaction events
    console.log(`Equipment ${equipmentId} interaction:`, interactionType, data);

    // You can add specific interaction logic here
    // For example, safety checks, measurement logging, etc.
  }

  /**
   * Create predefined experiment scenarios
   */
  createExperimentScenarios(): ExperimentScenario[] {
    return [
      this.createBasicChemistryExperiment(),
      this.createpHTestingExperiment(),
      this.createSafetyTrainingScenario(),
      this.createMicroscopyExperiment(),
      this.createHeatTransferExperiment(),
    ];
  }

  /**
   * Basic Chemistry Experiment
   */
  private createBasicChemistryExperiment(): ExperimentScenario {
    const setupScene = this.createScene({
      id: 'basic-chem-setup',
      name: 'Basic Chemistry Setup',
      description: 'Set up basic chemistry equipment',
      safetyLevel: 'medium',
      requiredSafetyEquipment: ['goggles', 'labCoat', 'gloves'],
    });

    // Add equipment to the scene
    this.addEquipment(setupScene.id, {
      type: 'safety-person',
      position: { x: 50, y: 50 },
      props: {
        requiredEquipment: ['goggles', 'labCoat', 'gloves'],
        experimentType: 'basic'
      }
    });

    this.addEquipment(setupScene.id, {
      type: 'beaker',
      position: { x: 200, y: 150 },
      props: { size: 200, liquidLevel: 0.5, liquidColor: '#4FC3F7' }
    });

    this.addEquipment(setupScene.id, {
      type: 'bunsen-burner',
      position: { x: 180, y: 250 },
      props: { size: 100 }
    });

    this.addEquipment(setupScene.id, {
      type: 'graduated-cylinder',
      position: { x: 350, y: 100 },
      props: { maxVolume: 100 }
    });

    this.addEquipment(setupScene.id, {
      type: 'stirring-rod',
      position: { x: 300, y: 200 },
    });

    return {
      id: 'basic-chemistry',
      title: 'Basic Chemistry Experiment',
      scenes: [setupScene],
      learningObjectives: [
        'Identify basic lab equipment',
        'Practice safety procedures',
        'Understand measurement tools'
      ],
      estimatedTime: 15,
      difficulty: 'beginner'
    };
  }

  /**
   * pH Testing Experiment
   */
  private createpHTestingExperiment(): ExperimentScenario {
    const scene = this.createScene({
      id: 'ph-testing',
      name: 'pH Testing Lab',
      description: 'Learn to measure pH using different methods',
      safetyLevel: 'medium',
      requiredSafetyEquipment: ['goggles', 'gloves'],
    });

    this.addEquipment(scene.id, {
      type: 'safety-person',
      position: { x: 150, y: 50 },
      props: {
        requiredEquipment: ['goggles', 'labCoat', 'gloves', 'faceShield'],
        experimentType: 'acid'
      }
    });

    this.addEquipment(scene.id, {
      type: 'fume-hood',
      position: { x: 50, y: 200 },
    });

    this.addEquipment(scene.id, {
      type: 'fire-extinguisher',
      position: { x: 300, y: 180 },
    });

    this.addEquipment(scene.id, {
      type: 'emergency-shower',
      position: { x: 350, y: 50 },
    });

    return {
      id: 'safety-training',
      title: 'Laboratory Safety Training',
      scenes: [scene],
      learningObjectives: [
        'Identify safety equipment',
        'Practice emergency procedures',
        'Understand hazard levels'
      ],
      estimatedTime: 25,
      difficulty: 'beginner'
    };
  }

  /**
   * Microscopy Experiment
   */
  private createMicroscopyExperiment(): ExperimentScenario {
    const scene = this.createScene({
      id: 'microscopy',
      name: 'Microscopy Lab',
      description: 'Learn to use microscope for sample analysis',
      safetyLevel: 'low',
      requiredSafetyEquipment: ['gloves'],
    });

    this.addEquipment(scene.id, {
      type: 'microscope',
      position: { x: 150, y: 100 },
      props: {
        magnification: 400,
        onFocusChange: (focus: number) => console.log('Focus:', focus)
      }
    });

    this.addEquipment(scene.id, {
      type: 'petri-dish',
      position: { x: 50, y: 200 },
    });

    this.addEquipment(scene.id, {
      type: 'pipette',
      position: { x: 300, y: 150 },
      props: { capacity: 5 }
    });

    return {
      id: 'microscopy',
      title: 'Microscopy and Sample Analysis',
      scenes: [scene],
      learningObjectives: [
        'Use microscope correctly',
        'Prepare samples',
        'Understand magnification'
      ],
      estimatedTime: 30,
      difficulty: 'intermediate'
    };
  }

  /**
   * Heat Transfer Experiment
   */
  private createHeatTransferExperiment(): ExperimentScenario {
    const scene = this.createScene({
      id: 'heat-transfer',
      name: 'Heat Transfer Lab',
      description: 'Study heat transfer using various heating methods',
      safetyLevel: 'high',
      requiredSafetyEquipment: ['goggles', 'labCoat', 'gloves'],
    });

    this.addEquipment(scene.id, {
      type: 'hot-plate',
      position: { x: 100, y: 150 },
      props: {
        maxTemperature: 300,
        onTemperatureChange: (temp: number) => console.log('Temperature:', temp)
      }
    });

    this.addEquipment(scene.id, {
      type: 'heating-mantle',
      position: { x: 250, y: 150 },
    });

    this.addEquipment(scene.id, {
      type: 'thermometer-stand',
      position: { x: 175, y: 100 },
      props: { temperature: 25 }
    });

    this.addEquipment(scene.id, {
      type: 'ice-bath',
      position: { x: 350, y: 120 },
    });

    this.addEquipment(scene.id, {
      type: 'beaker',
      position: { x: 120, y: 100 },
      props: {
        size: 150,
        liquidLevel: 0.7,
        liquidColor: '#4FC3F7',
        temperature: 25
      }
    });

    return {
      id: 'heat-transfer',
      title: 'Heat Transfer Methods',
      scenes: [scene],
      learningObjectives: [
        'Compare heating methods',
        'Measure temperature changes',
        'Understand thermal dynamics'
      ],
      estimatedTime: 35,
      difficulty: 'advanced'
    };
  }

  /**
   * Get equipment by category
   */
  getEquipmentByCategory(): Record<string, EquipmentType[]> {
    return {
      basic: [
        'graduated-cylinder', 'pipette', 'funnel',
        'stirring-rod', 'watch-glass', 'petri-dish'
      ],
      heating: [
        'hot-plate', 'thermometer-stand', 'heating-mantle', 'ice-bath'
      ],
      measurement: [
        'balance-scale', 'ph-meter', 'litmus-paper', 'measuring-spoons'
      ],
      safety: [
        'safety-goggles', 'safety-gloves', 'fume-hood',
        'fire-extinguisher', 'emergency-shower', 'safety-person'
      ],
      specialized: [
        'microscope', 'mortar-pestle', 'tongs', 'ring-stand', 'condenser'
      ],
      enhanced: [
        'bunsen-burner', 'beaker', 'flask', 'test-tube-rack'
      ]
    };
  }

  /**
   * Get equipment info
   */
  getEquipmentInfo(type: EquipmentType): any {
    const infoMap = {
      'graduated-cylinder': {
        name: 'Graduated Cylinder',
        description: 'Precise volume measurement',
        difficulty: 'beginner',
        category: 'basic'
      },
      'ph-meter': {
        name: 'pH Meter',
        description: 'Digital pH measurement',
        difficulty: 'intermediate',
        category: 'measurement'
      },
      'safety-person': {
        name: 'Safety Training',
        description: 'Interactive safety equipment training',
        difficulty: 'beginner',
        category: 'safety'
      },
      'microscope': {
        name: 'Microscope',
        description: 'Sample magnification and analysis',
        difficulty: 'advanced',
        category: 'specialized'
      },
      // Add more as needed...
    };

    return infoMap[type] || {
      name: type,
      description: 'Lab equipment',
      difficulty: 'beginner',
      category: 'basic'
    };
  }

  /**
   * Get all scenes
   */
  getAllScenes(): LabScene[] {
    return Array.from(this.scenes.values());
  }

  /**
   * Get scene by ID
   */
  getScene(sceneId: string): LabScene | undefined {
    return this.scenes.get(sceneId);
  }

  /**
   * Remove equipment from scene
   */
  removeEquipment(sceneId: string, equipmentId: string): boolean {
    const scene = this.scenes.get(sceneId);
    if (!scene) return false;

    const index = scene.equipment.findIndex(eq => eq.id === equipmentId);
    if (index === -1) return false;

    scene.equipment.splice(index, 1);
    this.equipment.delete(equipmentId);
    return true;
  }

  /**
   * Update equipment position
   */
  updateEquipmentPosition(equipmentId: string, position: Partial<EquipmentPosition>): boolean {
    const equipment = this.equipment.get(equipmentId);
    if (!equipment) return false;

    equipment.position = { ...equipment.position, ...position };
    return true;
  }

  /**
   * Clone scene
   */
  cloneScene(sceneId: string, newSceneId: string): LabScene | null {
    const originalScene = this.scenes.get(sceneId);
    if (!originalScene) return null;

    const clonedScene: LabScene = {
      ...originalScene,
      id: newSceneId,
      name: `${originalScene.name} (Copy)`,
      equipment: originalScene.equipment.map(eq => ({
        ...eq,
        id: `${eq.type}-${Date.now()}-${Math.random()}`
      }))
    };

    this.scenes.set(newSceneId, clonedScene);

    // Register cloned equipment
    clonedScene.equipment.forEach(eq => {
      this.equipment.set(eq.id, eq);
    });

    return clonedScene;
  }
}

// Export singleton instance
export const labSceneBuilder = new LabSceneBuilder();.id, {
      type: 'ph-meter',
      position: { x: 100, y: 100 },
      props: { onPHChange: (pH: number) => console.log('pH:', pH) }
    });

    this.addEquipment(scene.id, {
      type: 'litmus-paper',
      position: { x: 300, y: 100 },
    });

    this.addEquipment(scene.id, {
      type: 'beaker',
      position: { x: 200, y: 200 },
      props: { liquidColor: '#ff6b6b' }
    });

    return {
      id: 'ph-testing',
      title: 'pH Testing Methods',
      scenes: [scene],
      learningObjectives: [
        'Understand pH scale',
        'Use pH meter correctly',
        'Compare different pH indicators'
      ],
      estimatedTime: 20,
      difficulty: 'intermediate'
    };
  }

  /**
   * Safety Training Scenario
   */
  private createSafetyTrainingScenario(): ExperimentScenario {
    const scene = this.createScene({
      id: 'safety-training',
      name: 'Lab Safety Training',
      description: 'Learn proper safety equipment usage',
      safetyLevel: 'critical',
      requiredSafetyEquipment: ['goggles', 'labCoat', 'gloves', 'faceShield'],
    });

    this.addEquipment(scene.id, {
      type: 'safety-goggles',
      position: { x: 100, y: 100 },
    });

    this.addEquipment(scene.id, {
      type: 'safety-gloves',
      position: { x: 300, y: 100 },
    });

    this.addEquipment(scene.id, {
      type: 'lab-coat',
      position: { x: 200, y: 200 },
    });

    this.addEquipment(scene.id, {
      type: 'face-shield',
      position: { x: 400, y: 200 },
    });

    return {
      id: 'safety-training',
      title: 'Lab Safety Training',
      scenes: [scene],
      learningObjectives: [
        'Identify safety equipment',
        'Demonstrate proper usage',
        'Respond to safety incidents'
      ],
      estimatedTime: 30,
      difficulty: 'beginner'
    };
  }

---- File Content End ----


=== File: labTypes.ts ===
Path: lab\core\labTypes.ts
---- File Content Start ----
//src/data/animations/lab/core/labTypes.ts
export interface Particle {
  id: string;
  x: number;
  y: number;
  vx: number;
  vy: number;
  radius: number;
  mass: number;
  color: string;
  maxSpeed: number;
  vibrationIntensity: number;
  temperature: number;
  elementType?: string;
}

export interface LabBoundary {
  id: string;
  type: 'container' | 'heater' | 'solid';
  shape: 'rectangle' | 'circle';
  x: number;
  y: number;
  width?: number;
  height?: number;
  radius?: number;
  restitution: number;
  friction: number;
}

export interface HeatSource {
  id: string;
  x: number;
  y: number;
  radius: number;
  intensity: number;
  temperature: number;
  isActive: boolean;
}

---- File Content End ----


=== File: LabAnimationPlugin.ts ===
Path: plugins\LabAnimationPlugin.ts
---- File Content Start ----
// src/data/animations/plugins/LabAnimationPlugin.ts

import { AnimationPlugin, AnimationRegistry } from '../core/AnimationRegistry';
import { labSceneBuilder, EquipmentType } from '../lab/LabSceneBuilder';

export class LabAnimationPlugin implements AnimationPlugin {
  id = 'lab-equipment-core';
  name = 'Lab Equipment Animations';
  version = '1.0.0';

  register(registry: AnimationRegistry): void {
    console.log('🧪 Registering Lab Equipment Animations...');

    // Register predefined experiment scenarios
    this.registerExperimentScenarios(registry);

    // Register individual equipment demonstrations
    this.registerEquipmentDemos(registry);

    // Register safety training modules
    this.registerSafetyTraining(registry);

    // Register interactive lab builder
    this.registerLabBuilder(registry);
  }

  /**
   * Register complete experiment scenarios
   */
  private registerExperimentScenarios(registry: AnimationRegistry): void {
    const scenarios = labSceneBuilder.createExperimentScenarios();

    scenarios.forEach(scenario => {
      registry.registerAnimation({
        id: `lab-experiment-${scenario.id}`,
        name: scenario.title,
        description: `${scenario.difficulty} level experiment: ${scenario.learningObjectives.join(', ')}`,
        templateId: 'direct-html',
        category: 'laboratory',
        tags: ['lab', 'experiment', scenario.difficulty, ...scenario.learningObjectives],
        config: {
          height: 600,
          autoPlay: false,
          loop: false,
          fullscreen: true,
          directHtml: this.generateScenarioHTML(scenario),
          estimatedTime: scenario.estimatedTime,
          difficulty: scenario.difficulty,
          learningObjectives: scenario.learningObjectives
        }
      });
    });
  }

  /**
   * Register individual equipment demonstrations
   */
  private registerEquipmentDemos(registry: AnimationRegistry): void {
    const equipmentCategories = labSceneBuilder.getEquipmentByCategory();

    Object.entries(equipmentCategories).forEach(([category, equipment]) => {
      equipment.forEach(equipmentType => {
        const info = labSceneBuilder.getEquipmentInfo(equipmentType);

        registry.registerAnimation({
          id: `lab-equipment-${equipmentType}`,
          name: `${info.name} Demo`,
          description: `Interactive demonstration of ${info.name}: ${info.description}`,
          templateId: 'direct-html',
          category: 'lab-equipment',
          tags: ['lab', 'equipment', category, info.difficulty],
          config: {
            height: 400,
            autoPlay: false,
            loop: false,
            directHtml: this.generateEquipmentDemoHTML(equipmentType, info),
            difficulty: info.difficulty
          }
        });
      });
    });
  }

  /**
   * Register safety training modules
   */
  private registerSafetyTraining(registry: AnimationRegistry): void {
    const safetyLevels = ['basic', 'acid', 'heat', 'biological'];

    safetyLevels.forEach(level => {
      registry.registerAnimation({
        id: `lab-safety-${level}`,
        name: `Safety Training: ${level.toUpperCase()}`,
        description: `Interactive safety equipment training for ${level} experiments`,
        templateId: 'direct-html',
        category: 'safety-training',
        tags: ['lab', 'safety', level, 'interactive'],
        config: {
          height: 500,
          autoPlay: false,
          loop: false,
          directHtml: this.generateSafetyTrainingHTML(level),
          experimentType: level
        }
      });
    });
  }

  /**
   * Register interactive lab builder
   */
  private registerLabBuilder(registry: AnimationRegistry): void {
    registry.registerAnimation({
      id: 'lab-builder-interactive',
      name: 'Interactive Lab Builder',
      description: 'Build and customize your own laboratory setup with drag-and-drop equipment',
      templateId: 'direct-html',
      category: 'interactive-tools',
      tags: ['lab', 'builder', 'interactive', 'drag-drop'],
      config: {
        height: 700,
        autoPlay: false,
        loop: false,
        fullscreen: true,
        directHtml: this.generateLabBuilderHTML()
      }
    });
  }

  /**
   * Generate HTML for experiment scenarios
   */
  private generateScenarioHTML(scenario: any): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #333;
        }
        .lab-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .experiment-header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 20px;
        }
        .experiment-title {
            font-size: 2.5rem;
            color: #2E7D32;
            margin-bottom: 10px;
        }
        .experiment-meta {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }
        .meta-item {
            background: #E8F5E8;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #2E7D32;
            font-weight: 600;
        }
        .objectives-section {
            margin: 30px 0;
            background: #F3E5F5;
            padding: 20px;
            border-radius: 10px;
        }
        .objectives-title {
            font-size: 1.3rem;
            color: #7B1FA2;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .objectives-list {
            list-style: none;
            padding: 0;
        }
        .objectives-list li {
            padding: 8px 0;
            border-bottom: 1px solid #E1BEE7;
            position: relative;
            padding-left: 25px;
        }
        .objectives-list li:before {
            content: "🎯";
            position: absolute;
            left: 0;
        }
        .scene-viewer {
            border: 2px solid #ddd;
            border-radius: 10px;
            height: 400px;
            background: #fafafa;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        .start-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        .equipment-preview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .equipment-item {
            background: #fff;
            border: 2px solid #E0E0E0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .equipment-item:hover {
            border-color: #4CAF50;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .equipment-name {
            font-weight: 600;
            color: #333;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="lab-container">
        <div class="experiment-header">
            <h1 class="experiment-title">${scenario.title}</h1>
            <div class="experiment-meta">
                <span class="meta-item">⏱️ ${scenario.estimatedTime} minutes</span>
                <span class="meta-item">📊 ${scenario.difficulty}</span>
                <span class="meta-item">🔬 ${scenario.scenes.length} scenes</span>
            </div>
        </div>

        <div class="objectives-section">
            <h3 class="objectives-title">Learning Objectives</h3>
            <ul class="objectives-list">
                ${scenario.learningObjectives.map((obj: string) => `<li>${obj}</li>`).join('')}
            </ul>
        </div>

        <div class="scene-viewer">
            <button class="start-button" onclick="startExperiment()">
                🚀 Start Experiment
            </button>
        </div>

        <div class="equipment-preview">
            ${scenario.scenes[0]?.equipment.map((eq: any) => `
                <div class="equipment-item">
                    <div style="font-size: 2rem;">${this.getEquipmentEmoji(eq.type)}</div>
                    <div class="equipment-name">${this.getEquipmentDisplayName(eq.type)}</div>
                </div>
            `).join('') || ''}
        </div>
    </div>

    <script>
        function startExperiment() {
            alert('🧪 Experiment started! Follow the on-screen instructions.');
            // Here you would implement the actual experiment flow
        }

        window.addEventListener('load', function() {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'ready',
                    experimentId: '${scenario.id}'
                }));
            }
        });
    </script>
</body>
</html>`;
  }

  /**
   * Generate HTML for equipment demonstrations
   */
  private generateEquipmentDemoHTML(equipmentType: EquipmentType, info: any): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: white;
            text-align: center;
        }
        .demo-container {
            max-width: 400px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .equipment-title {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .equipment-description {
            font-size: 1.1rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }
        .equipment-display {
            height: 250px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            border: 2px dashed rgba(255,255,255,0.3);
        }
        .equipment-icon {
            font-size: 4rem;
            opacity: 0.8;
        }
        .interaction-hint {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1 class="equipment-title">${info.name}</h1>
        <p class="equipment-description">${info.description}</p>

        <div class="equipment-display">
            <div class="equipment-icon">${this.getEquipmentEmoji(equipmentType)}</div>
        </div>

        <div class="interaction-hint">
            💡 Tap and interact with the equipment above to see how it works!
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'ready',
                    equipmentType: '${equipmentType}'
                }));
            }
        });
    </script>
</body>
</html>`;
  }

  /**
   * Generate HTML for safety training
   */
  private generateSafetyTrainingHTML(level: string): string {
    const requirements = {
      basic: ['goggles', 'labCoat', 'gloves'],
      acid: ['goggles', 'labCoat', 'gloves', 'faceShield'],
      heat: ['goggles', 'labCoat', 'gloves'],
      biological: ['labCoat', 'gloves']
    };

    return `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #333;
        }
        .safety-container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }
        .safety-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .safety-title {
            font-size: 2.5rem;
            color: #D32F2F;
            margin-bottom: 10px;
        }
        .safety-level {
            background: linear-gradient(45deg, #F44336, #E57373);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            font-weight: bold;
            text-transform: uppercase;
        }
        .requirements-list {
            background: #FFF3E0;
            border-left: 5px solid #FF9800;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }
        .requirements-title {
            font-size: 1.3rem;
            color: #E65100;
            margin-bottom: 15px;
            font-weight: bold;
        }
        .requirement-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #FFE0B2;
        }
        .requirement-item:last-child {
            border-bottom: none;
        }
        .requirement-icon {
            font-size: 1.5rem;
            margin-right: 15px;
        }
        .interactive-person {
            height: 300px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .interactive-person:hover {
            border-color: #4CAF50;
            background: #E8F5E8;
        }
    </style>
</head>
<body>
    <div class="safety-container">
        <div class="safety-header">
            <h1 class="safety-title">⚠️ Safety Training</h1>
            <div class="safety-level">${level} Level</div>
        </div>

        <div class="requirements-list">
            <h3 class="requirements-title">Required Safety Equipment:</h3>
            ${(requirements[level as keyof typeof requirements] || []).map(req => `
                <div class="requirement-item">
                    <span class="requirement-icon">${this.getSafetyEquipmentEmoji(req)}</span>
                    <span>${this.getSafetyEquipmentName(req)}</span>
                </div>
            `).join('')}
        </div>

        <div class="interactive-person" onclick="startSafetyTraining()">
            <div style="text-align: center;">
                <div style="font-size: 3rem; margin-bottom: 10px;">👨‍🔬</div>
                <div style="font-size: 1.2rem; color: #666;">Click to practice safety procedures</div>
            </div>
        </div>
    </div>

    <script>
        function startSafetyTraining() {
            alert('🛡️ Safety training started! Practice putting on the required equipment.');
        }

        window.addEventListener('load', function() {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'ready',
                    safetyLevel: '${level}'
                }));
            }
        });
    </script>
</body>
</html>`;
  }

  /**
   * Generate HTML for lab builder
   */
  private generateLabBuilderHTML(): string {
    return `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        .builder-container {
            display: flex;
            height: 100vh;
        }
        .equipment-palette {
            width: 250px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255,255,255,0.2);
            padding: 20px;
            overflow-y: auto;
        }
        .palette-title {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }
        .equipment-category {
            margin-bottom: 20px;
        }
        .category-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #FFD700;
        }
        .equipment-item {
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            text-align: center;
        }
        .equipment-item:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        .lab-workspace {
            flex: 1;
            background: rgba(255,255,255,0.05);
            position: relative;
            overflow: hidden;
        }
        .workspace-header {
            background: rgba(0,0,0,0.2);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .workspace-title {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .controls {
            display: flex;
            gap: 10px;
        }
        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;

---- File Content End ----


=== File: ChemistryPresets.ts ===
Path: presets\ChemistryPresets.ts
---- File Content Start ----

---- File Content End ----


=== File: PhysicsPresets.ts ===
Path: presets\PhysicsPresets.ts
---- File Content Start ----

---- File Content End ----


=== File: ReactionPresets.ts ===
Path: presets\ReactionPresets.ts
---- File Content Start ----

---- File Content End ----


=== File: animationUtils.ts ===
Path: utils\animationUtils.ts
---- File Content Start ----
// src/utils/animationUtils.ts

/**
 * Parses a hex color string (#RRGGBB or #RGB) into an RGBA object.
 * @param hex The hex color string.
 * @returns An object with r, g, b, a properties (0-255 for RGB, 0-1 for a).
 */
function hexToRgba(hex: string): { r: number; g: number; b: number; a: number } {
  let c: any = hex.substring(1).split('');
  if (c.length === 3) {
    c = [c[0], c[0], c[1], c[1], c[2], c[2]];
  }
  c = '0x' + c.join('');
  return {
    r: (c >> 16) & 255,
    g: (c >> 8) & 255,
    b: c & 255,
    a: 1, // Default alpha
  };
}

/**
 * Linearly interpolates between two colors.
 * @param color1 The starting color in hex format.
 * @param color2 The ending color in hex format.
 * @param t The interpolation factor (0.0 to 1.0).
 * @returns The interpolated color as an 'rgb(r, g, b)' string.
 */
export function lerpColor(color1: string, color2: string, t: number): string {
  const c1 = hexToRgba(color1);
  const c2 = hexToRgba(color2);

  const r = Math.round(c1.r * (1 - t) + c2.r * t);
  const g = Math.round(c1.g * (1 - t) + c2.g * t);
  const b = Math.round(c1.b * (1 - t) + c2.b * t);

  return `rgb(${r}, ${g}, ${b})`;
}

---- File Content End ----


=== File: layoutCalculators.ts ===
Path: utils\layoutCalculators.ts
---- File Content Start ----

---- File Content End ----


=== File: UniqueID.ts ===
Path: utils\UniqueID.ts
---- File Content Start ----
// src/utils/UniqueID.ts

let counter = 0;

export class UniqueID {
  public static generate(prefix: string = 'id_'): string {
    counter++;
    return `${prefix}${Date.now()}_${counter}`;
  }

  public static resetCounter(): void { // Optional: for testing or specific reset scenarios
    counter = 0;
  }
}

---- File Content End ----

