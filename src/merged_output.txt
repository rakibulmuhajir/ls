
=== File: BottomNavigationBar.tsx ===
Path: components\BottomNavigationBar.tsx
---- File Content Start ----
import React from 'react';
import { View, Text, TouchableOpacity, ScrollView, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import {
  brandColors,
  typography,
  spacing,
  layout,
  createShadow
} from '@/lib/designSystem';

interface Topic {
  topic_pk: number;
  title: string;
}

interface Props {
  topicId: number;
  chapterId: number;
  bookId: number;
  topics: Topic[];
}

export default function BottomNavigationBar({ topicId, chapterId, bookId, topics }: Props) {
  const navigation = useNavigation<any>();

  if (!topics || topics.length === 0) {
    return null;
  }

  const topicIndex = topics.findIndex((t) => t.topic_pk === topicId);
  const previousTopic = topics[topicIndex - 1];
  const nextTopic = topics[topicIndex + 1];

  const goToTopic = (targetTopicId: number) => {
    navigation.replace('Content', {
      topicId: targetTopicId,
      chapterId,
      bookId,
      topics,
    });
  };

  //console.log('BottomNavigationBar rendered', { topicId, chapterId, bookId, topics });

  return (
    <View style={styles.navigationBar}>
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        {/* Previous Button */}
        <TouchableOpacity
          style={[
            styles.navButton,
            !previousTopic && styles.disabledButton,
            previousTopic && styles.enabledButton
          ]}
          onPress={() => previousTopic && goToTopic(previousTopic.topic_pk)}
          disabled={!previousTopic}
          activeOpacity={0.7}
        >
          <MaterialCommunityIcons
            name="arrow-left"
            size={18}
            color={!previousTopic ? brandColors.neutral.light : brandColors.primary.main}
          />
          <Text style={[
            styles.navText,
            !previousTopic && styles.disabledText,
            previousTopic && styles.enabledText
          ]}>
            Previous
          </Text>
        </TouchableOpacity>

        {/* Next Button */}
        <TouchableOpacity
          style={[
            styles.navButton,
            !nextTopic && styles.disabledButton,
            nextTopic && styles.enabledButton
          ]}
          onPress={() => nextTopic && goToTopic(nextTopic.topic_pk)}
          disabled={!nextTopic}
          activeOpacity={0.7}
        >
          <Text style={[
            styles.navText,
            !nextTopic && styles.disabledText,
            nextTopic && styles.enabledText
          ]}>
            Next
          </Text>
          <MaterialCommunityIcons
            name="arrow-right"
            size={18}
            color={!nextTopic ? brandColors.neutral.light : brandColors.primary.main}
          />
        </TouchableOpacity>

        {/* Topics Button */}
        <TouchableOpacity
          style={[styles.navButton, styles.enabledButton]}
          onPress={() => navigation.navigate('Topics', { chapterId, bookId })}
          activeOpacity={0.7}
        >
          <MaterialCommunityIcons
            name="format-list-bulleted"
            size={18}
            color={brandColors.accent.main}
          />
          <Text style={[styles.navText, { color: brandColors.accent.main }]}>Topics</Text>
        </TouchableOpacity>

        {/* Chapters Button */}
        <TouchableOpacity
          style={[styles.navButton, styles.enabledButton]}
          onPress={() => navigation.navigate('Chapters', { bookId })}
          activeOpacity={0.7}
        >
          <MaterialCommunityIcons
            name="view-list"
            size={18}
            color={brandColors.secondary.main}
          />
          <Text style={[styles.navText, { color: brandColors.secondary.main }]}>Chapters</Text>
        </TouchableOpacity>

        {/* Books Button */}
        <TouchableOpacity
          style={[styles.navButton, styles.enabledButton]}
          onPress={() => navigation.navigate('Books')}
          activeOpacity={0.7}
        >
          <MaterialCommunityIcons
            name="book-open-page-variant"
            size={18}
            color={brandColors.primary.main}
          />
          <Text style={[styles.navText, { color: brandColors.primary.main }]}>Books</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  navigationBar: {
    borderTopWidth: 1,
    borderColor: brandColors.neutral.lighter,
    paddingVertical: spacing.sm,
    paddingHorizontal: spacing.sm,
    backgroundColor: '#ffffff',
    ...createShadow(4),
  },
  scrollContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
  },
  navButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
    marginHorizontal: spacing.xs / 2,
    borderRadius: layout.borderRadius.lg,
    minHeight: 36,
  },
  enabledButton: {
    backgroundColor: brandColors.neutral.lightest,
    borderWidth: 1,
    borderColor: brandColors.neutral.lighter,
  },
  disabledButton: {
    backgroundColor: brandColors.neutral.lighter,
    opacity: 0.5,
  },
  navText: {
    fontSize: typography.fontSize.sm,
    fontWeight: typography.fontWeight.medium,
    marginHorizontal: spacing.xs / 2,
  },
  enabledText: {
    color: brandColors.neutral.dark,
  },
  disabledText: {
    color: brandColors.neutral.light,
  },
});

---- File Content End ----


=== File: Loader.tsx ===
Path: components\Loader.tsx
---- File Content Start ----
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Pressable, Animated } from 'react-native';

interface LoaderProps {
  loading: boolean;
  error?: string | null;
  onRetry?: () => void;
}

const Loader: React.FC<LoaderProps> = ({ loading, error, onRetry }) => {
  const dot1 = useRef(new Animated.Value(0)).current;
  const dot2 = useRef(new Animated.Value(0)).current;
  const dot3 = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (loading) {
      const animateDot = (dot: Animated.Value, delay: number) => {
        return Animated.loop(
          Animated.sequence([
            Animated.delay(delay),
            Animated.timing(dot, {
              toValue: 1,
              duration: 300,
              useNativeDriver: true,
            }),
            Animated.timing(dot, {
              toValue: 0,
              duration: 300,
              useNativeDriver: true,
            }),
          ])
        );
      };

      const animation1 = animateDot(dot1, 0);
      const animation2 = animateDot(dot2, 200);
      const animation3 = animateDot(dot3, 400);

      animation1.start();
      animation2.start();
      animation3.start();

      return () => {
        animation1.stop();
        animation2.stop();
        animation3.stop();
      };
    }
  }, [loading, dot1, dot2, dot3]);

  if (!loading && !error) return null;

  const dotStyle = (animatedValue: Animated.Value) => ({
    opacity: animatedValue.interpolate({
      inputRange: [0, 1],
      outputRange: [0.3, 1],
    }),
    transform: [
      {
        scale: animatedValue.interpolate({
          inputRange: [0, 1],
          outputRange: [1, 1.3],
        }),
      },
    ],
  });

  return (
    <View style={styles.container}>
      {loading && (
        <View style={styles.loadingContainer}>
          <View style={styles.dotsContainer}>
            <Animated.View style={[styles.dot, dotStyle(dot1)]} />
            <Animated.View style={[styles.dot, dotStyle(dot2)]} />
            <Animated.View style={[styles.dot, dotStyle(dot3)]} />
          </View>
          <Text style={styles.loadingText}>Loading...</Text>
        </View>
      )}
      {error && (
        <View style={styles.errorBox}>
          <Text style={styles.errorText}>{error}</Text>
          {onRetry && (
            <Pressable onPress={onRetry} style={styles.retryButton}>
              <Text style={styles.retryText}>Retry</Text>
            </Pressable>
          )}
        </View>
      )}
    </View>
  );
};

export default Loader;

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
    zIndex: 10,
  },
  loadingContainer: {
    alignItems: 'center',
  },
  dotsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  dot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#7C3AED',
    marginHorizontal: 4,
  },
  loadingText: {
    fontSize: 16,
    color: '#6B7280',
    fontWeight: '500',
  },
  errorBox: {
    alignItems: 'center',
    padding: 16,
  },
  errorText: {
    fontSize: 16,
    color: 'red',
    textAlign: 'center',
    marginBottom: 12,
  },
  retryButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    backgroundColor: '#7C3AED',
    borderRadius: 10,
  },
  retryText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

---- File Content End ----


=== File: SectionCard.js ===
Path: components\SectionCard.js
---- File Content Start ----
import React from 'react';
import { View, Text } from 'react-native';
import Animated from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';
import { getSectionStyles } from '@/styles/designSystem';

type SectionCardProps = {
  title: string;
  children: React.ReactNode;
  style?: any;
};

const SectionCard: React.FC<SectionCardProps> = ({ title, children, style }) => {
  const normalizedKey = title.toUpperCase().replace(/\s+/g, '_');
  const sectionStyles = getSectionStyles(normalizedKey);

  return (
    <Animated.View className="mb-4 rounded-2xl shadow-md overflow-hidden" style={style}>
      <LinearGradient
        colors={sectionStyles.cardBgGradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
        className="flex-row items-center px-4 py-6"
      >
        <Text className="text-[24px]">{sectionStyles.iconEmoji}</Text>
        <Text
          className="text-[20px] font-bold ml-2"
          style={{ color: sectionStyles.headerTextColor }}
        >
          {title}
        </Text>
      </LinearGradient>

      <View className="bg-white/95 px-6 py-6">
        {children}
      </View>
    </Animated.View>
  );
};

export default SectionCard;

---- File Content End ----


=== File: AnimationDebugTool.tsx ===
Path: data\animations\AnimationDebugTool.tsx
---- File Content Start ----
// AnimationDebugTool.tsx - Standalone animation tester
import React, { useState, useRef } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Platform } from 'react-native';
import { WebView } from 'react-native-webview';

const AnimationDebugTool = () => {
  const [currentTest, setCurrentTest] = useState<string>('basic');
  const [logs, setLogs] = useState<string[]>([]);
  const webViewRef = useRef<WebView>(null);

  const addLog = (message: string) => {
    setLogs(prev => [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
    console.log(message);
  };
// First, let's test with your EXACT chemistry-definition HTML
const testChemistryDefinitionHTML = () => {
  // This is your exact HTML from chemistryDefinition.ts
  const baseAnimationTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: box-shadow 0.3s ease;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        console.log('Base template script executed');
        // Your animation state setup
        let animationState = {
            temperature: 20,
            zoom: 1,
            speed: 1,
            showBefore: true,
            rotation3D: true,
            particleCount: 50,
            pressure: 1,
            concentration: 0.5,
            isPlaying: true,
            safetyStatus: { isSafe: true, warnings: [] }
        };

        console.log('Animation state initialized:', animationState);
    </script>
</body>
</html>
`;

  // Your chemistry definition specific content
  const chemistryDefinitionContent = `
    <style>
      #animation-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        position: relative;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }

      .title-section {
        text-align: center;
        margin-bottom: 30px;
        opacity: 0;
        transform: translateY(-20px);
        animation: fadeInDown 1s forwards;
      }

      .main-title {
        font-size: 28px;
        font-weight: bold;
        color: white;
        margin-bottom: 10px;
      }

      .definition-text {
        font-size: 16px;
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.5;
        max-width: 500px;
        margin: 0 auto;
      }

      @keyframes fadeInDown {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>

    <div id="animation-container">
      <div class="title-section">
        <h1 class="main-title">What is Chemistry?</h1>
        <p class="definition-text">
          Chemistry is the branch of science that deals with the properties, composition, and structure of substances.
        </p>
      </div>
    </div>

    <script>
      console.log('Chemistry definition script started');

      window.addEventListener('load', () => {
        console.log('Window loaded - chemistry definition');

        const container = document.getElementById('animation-container');
        if (container) {
          console.log('Animation container found!');
          console.log('Container style:', window.getComputedStyle(container).background);
        } else {
          console.error('Animation container NOT found!');
        }

        // Test if content is visible
        const titleSection = document.querySelector('.title-section');
        if (titleSection) {
          console.log('Title section found');
          setTimeout(() => {
            console.log('Title section opacity after animation:', window.getComputedStyle(titleSection).opacity);
          }, 2000);
        } else {
          console.error('Title section NOT found!');
        }

        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage('Chemistry definition loaded successfully!');
        }
      });
    </script>
  `;

  // Combine them the way your system does
  return baseAnimationTemplate.replace(
    '<div id="canvas-container"></div>',
    '<div id="canvas-container"><div id="animation-container-placeholder"></div></div>'
  ) + chemistryDefinitionContent;
};

// Debug version - let's check each step
const debugChemistryStep1 = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="background: red; color: white; padding: 20px;">
    <h1>STEP 1: Basic HTML Structure Test</h1>
    <p>If you see this red background, HTML is loading.</p>
    <div id="canvas-container" style="background: blue; height: 200px; margin: 10px 0;">
        <p style="color: white; padding: 10px;">Canvas container (blue)</p>
        <div id="animation-container" style="background: green; height: 100px; margin: 10px;">
            <p style="color: white; padding: 10px;">Animation container (green)</p>
        </div>
    </div>
    <script>
        console.log('Step 1 script executed');
        if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage('Step 1: HTML structure loaded');
        }
    </script>
</body>
</html>
`;

const debugChemistryStep2 = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: orange;
        }
        #animation-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="animation-container">
            <h1>STEP 2: CSS Styling Test</h1>
        </div>
    </div>
    <script>
        console.log('Step 2 script executed');
        if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage('Step 2: CSS styling loaded');
        }
    </script>
</body>
</html>
`;

const debugChemistryStep3 = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #animation-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        .title-section {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(-20px);
            animation: fadeInDown 1s forwards;
        }
        .main-title {
            font-size: 28px;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
        }
        .definition-text {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
            max-width: 500px;
            margin: 0 auto;
        }
        @keyframes fadeInDown {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="animation-container">
            <div class="title-section">
                <h1 class="main-title">What is Chemistry?</h1>
                <p class="definition-text">
                    Chemistry is the branch of science that deals with the properties, composition, and structure of substances.
                </p>
            </div>
        </div>
    </div>
    <script>
        console.log('Step 3 script executed');

        setTimeout(() => {
            const titleSection = document.querySelector('.title-section');
            if (titleSection) {
                console.log('Animation completed, opacity:', window.getComputedStyle(titleSection).opacity);
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage('Step 3: Animation completed successfully');
                }
            }
        }, 2000);
    </script>
</body>
</html>
`;
  // Test 1: Basic HTML
  const basicHTML = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                margin: 0;
                padding: 20px;
                background: red;
                color: white;
                font-family: Arial, sans-serif;
                font-size: 18px;
            }
        </style>
    </head>
    <body>
        <h1>Basic Test - RED BACKGROUND</h1>
        <p>If you can see this, WebView is working!</p>
        <script>
            console.log('Basic HTML loaded');
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage('Basic test loaded successfully!');
            }
        </script>
    </body>
    </html>
  `;

  // Test 2: With CSS Animation
  const animatedHTML = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                font-family: Arial, sans-serif;
                height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            .title {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 20px;
                animation: fadeIn 2s ease-in-out;
            }
            .content {
                font-size: 16px;
                text-align: center;
                animation: slideUp 1s ease-out 0.5s both;
            }
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes slideUp {
                from { opacity: 0; transform: translateY(30px); }
                to { opacity: 1; transform: translateY(0); }
            }
        </style>
    </head>
    <body>
        <div class="title">Animated Test</div>
        <div class="content">
            This should fade in and slide up!<br>
            Background should be a gradient.
        </div>

        <script>
            console.log('Animated HTML loaded');
            let counter = 0;

            setInterval(() => {
                counter++;
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(\`Animation running: \${counter}\`);
                }
            }, 1000);
        </script>
    </body>
    </html>
  `;

  // Test 3: Your Base Template
  const baseTemplateHTML = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                background: orange;
            }
            #canvas-container {
                width: 100vw;
                height: 100vh;
                position: relative;
                background: blue;
            }
            #animation-container {
                width: 100%;
                height: 100%;
                background: green;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 20px;
            }
        </style>
    </head>
    <body>
        <div id="canvas-container">
            <div id="animation-container">
                BASE TEMPLATE TEST - GREEN BACKGROUND
            </div>
        </div>
        <script>
            console.log('Base template loaded');
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage('Base template test loaded!');
            }
        </script>
    </body>
    </html>
  `;

  // Test 4: Simplified Chemistry Definition
  const chemistryHTML = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                min-height: 100vh;
            }
            .title {
                font-size: 28px;
                font-weight: bold;
                text-align: center;
                margin-bottom: 20px;
                animation: fadeIn 1s ease-in;
            }
            .card {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                margin: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                text-align: center;
            }
            .card:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: translateY(-2px);
            }
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
        </style>
    </head>
    <body>
        <div class="title">What is Chemistry?</div>

        <div class="card" onclick="showMessage('Properties')">
            <h3>🔬 Properties</h3>
            <p>What substances are like</p>
        </div>

        <div class="card" onclick="showMessage('Composition')">
            <h3>⚛️ Composition</h3>
            <p>What substances are made of</p>
        </div>

        <div class="card" onclick="showMessage('Structure')">
            <h3>🧬 Structure</h3>
            <p>How atoms are arranged</p>
        </div>

        <script>
            console.log('Chemistry animation loaded');

            function showMessage(topic) {
                console.log('Clicked:', topic);
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(\`Clicked: \${topic}\`);
                }
            }

            // Test if JavaScript is working
            setTimeout(() => {
                document.body.style.border = '3px solid yellow';
                console.log('JavaScript executed - yellow border added');
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage('JavaScript execution test complete');
                }
            }, 2000);
        </script>
    </body>
    </html>
  `;

  const tests = {
    basic: { name: 'Basic HTML', html: basicHTML },
    animated: { name: 'CSS Animations', html: animatedHTML },
    template: { name: 'Base Template', html: baseTemplateHTML },
    chemistry: { name: 'Simple Chemistry', html: chemistryHTML },
    step1: { name: 'Step 1: HTML Structure', html: debugChemistryStep1 },
  step2: { name: 'Step 2: CSS Styling', html: debugChemistryStep2 },
  step3: { name: 'Step 3: Full Animation', html: debugChemistryStep3 },
  actual: { name: 'Actual Chemistry Config', html: testChemistryDefinitionHTML() }
  };

  const handleMessage = (event: any) => {
    try {
      const message = event.nativeEvent.data;
      addLog(`WebView Message: ${message}`);
    } catch (e) {
      addLog(`Error parsing message: ${e}`);
    }
  };

  const renderWebView = () => {
    if (Platform.OS === 'web') {
      return (
        <div
          style={{
            width: '100%',
            height: 400,
            border: '2px solid #ddd',
            borderRadius: 8,
            overflow: 'hidden'
          }}
          dangerouslySetInnerHTML={{ __html: tests[currentTest].html }}
        />
      );
    }

    return (
      <WebView
        ref={webViewRef}
        source={{ html: tests[currentTest].html }}
        style={styles.webview}
        onMessage={handleMessage}
        onError={(error) => addLog(`WebView Error: ${JSON.stringify(error)}`)}
        onLoadEnd={() => addLog('WebView loaded successfully')}
        onLoadStart={() => addLog('WebView loading started')}
        onHttpError={(error) => addLog(`HTTP Error: ${JSON.stringify(error)}`)}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        cacheEnabled={false}
        allowsInlineMediaPlayback={true}
        mixedContentMode="compatibility"
        originWhitelist={['*']}
      />
    );
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.header}>Animation Debug Tool</Text>

      {/* Test Selection */}
      <View style={styles.testSelector}>
        {Object.entries(tests).map(([key, test]) => (
          <TouchableOpacity
            key={key}
            style={[
              styles.testButton,
              currentTest === key && styles.testButtonActive
            ]}
            onPress={() => {
              setCurrentTest(key);
              setLogs([]);
              addLog(`Switched to test: ${test.name}`);
            }}
          >
            <Text style={[
              styles.testButtonText,
              currentTest === key && styles.testButtonTextActive
            ]}>
              {test.name}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      {/* WebView Container */}
      <View style={styles.webviewContainer}>
        <Text style={styles.sectionTitle}>
          Current Test: {tests[currentTest].name}
        </Text>
        {renderWebView()}
      </View>

      {/* Debug Info */}
      <View style={styles.debugSection}>
        <Text style={styles.sectionTitle}>Debug Information</Text>
        <Text style={styles.debugText}>Platform: {Platform.OS}</Text>
        <Text style={styles.debugText}>Current Test: {currentTest}</Text>
        <Text style={styles.debugText}>Expected: Different colored backgrounds and text</Text>
      </View>

      {/* Console Logs */}
      <View style={styles.logsSection}>
        <Text style={styles.sectionTitle}>Console Logs</Text>
        <TouchableOpacity
          style={styles.clearButton}
          onPress={() => setLogs([])}
        >
          <Text style={styles.clearButtonText}>Clear Logs</Text>
        </TouchableOpacity>

        <ScrollView style={styles.logsContainer} nestedScrollEnabled>
          {logs.map((log, index) => (
            <Text key={index} style={styles.logText}>
              {log}
            </Text>
          ))}
          {logs.length === 0 && (
            <Text style={styles.noLogsText}>No logs yet...</Text>
          )}
        </ScrollView>
      </View>

      {/* Instructions */}
      <View style={styles.instructionsSection}>
        <Text style={styles.sectionTitle}>What to Look For</Text>
        <Text style={styles.instructionText}>
          • Basic HTML: Red background with white text{'\n'}
          • CSS Animations: Blue gradient with fade-in text{'\n'}
          • Base Template: Green background (testing your template){'\n'}
          • Simple Chemistry: Purple gradient with clickable cards{'\n'}
          {'\n'}
          If you see grey/empty area, check logs for errors.
        </Text>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    margin: 20,
    color: '#333',
  },
  testSelector: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    paddingHorizontal: 15,
    marginBottom: 20,
  },
  testButton: {
    backgroundColor: '#e0e0e0',
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 20,
    margin: 5,
  },
  testButtonActive: {
    backgroundColor: '#007AFF',
  },
  testButtonText: {
    color: '#333',
    fontSize: 14,
  },
  testButtonTextActive: {
    color: 'white',
  },
  webviewContainer: {
    margin: 15,
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  webview: {
    height: 400,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  debugSection: {
    margin: 15,
    padding: 15,
    backgroundColor: 'white',
    borderRadius: 8,
  },
  debugText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 5,
  },
  logsSection: {
    margin: 15,
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 15,
  },
  clearButton: {
    alignSelf: 'flex-end',
    backgroundColor: '#ff4444',
    paddingHorizontal: 15,
    paddingVertical: 5,
    borderRadius: 15,
    marginBottom: 10,
  },
  clearButtonText: {
    color: 'white',
    fontSize: 12,
  },
  logsContainer: {
    maxHeight: 200,
    backgroundColor: '#f8f8f8',
    borderRadius: 5,
    padding: 10,
  },
  logText: {
    fontSize: 12,
    color: '#333',
    marginBottom: 3,
    fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace',
  },
  noLogsText: {
    fontSize: 14,
    color: '#999',
    fontStyle: 'italic',
    textAlign: 'center',
  },
  instructionsSection: {
    margin: 15,
    padding: 15,
    backgroundColor: 'white',
    borderRadius: 8,
    marginBottom: 50,
  },
  instructionText: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },
});

export default AnimationDebugTool;

---- File Content End ----


=== File: AnimationFactory.ts ===
Path: data\animations\AnimationFactory.ts
---- File Content Start ----
// src/data/animations/AnimationFactory.ts
import { ReactionAnimationTemplate } from './templates/ReactionTemplate';
import { StateChangeAnimationTemplate } from './templates/StateChangeTemplate';
import { DissolutionAnimationTemplate } from './templates/DissolutionTemplate';

export type AnimationType =
  | 'reaction'
  | 'state-change'
  | 'dissolution'
  | 'bonding'
  | 'equilibrium';

export interface AnimationConfig {
  type: AnimationType;
  containerId: string;
  params: any;
}

export class AnimationFactory {
  static create(config: AnimationConfig): ChemistryAnimationEngine {
    switch (config.type) {
      case 'reaction':
        return new ReactionAnimationTemplate(
          config.containerId,
          config.params
        );

      case 'state-change':
        return new StateChangeAnimationTemplate(
          config.containerId,
          config.params.substance,
          config.params.initialState
        );

      case 'dissolution':
        return new DissolutionAnimationTemplate(
          config.containerId,
          config.params.solute,
          config.params.solvent,
          config.params.saturationPoint
        );

      default:
        throw new Error(`Unknown animation type: ${config.type}`);
    }
  }
}

---- File Content End ----


=== File: animationRegistry.ts ===
Path: data\animations\animationRegistry.ts
---- File Content Start ----
// src/data/animations/animationRegistry.ts - Updated
import { AnimationType, AnimationConfig } from './types';
import { baseAnimationTemplate } from './library/baseAnimationTemplate';
import { chemistryDefinition } from './library/chapter1/chemistryDefinition';
import { chemistryDefinitionInteractive } from './library/chapter1/chemistryDefinitionInteractive';

// Animation builders that create configs
const animationBuilders: Record<AnimationType, () => AnimationConfig> = {
  'hydrogen-oxygen-water': () => ({
    height: 500,
    autoPlay: false,
    loop: false,
    features: {
      temperature: true,
      beforeAfter: true,
      speed: true
    },
    safety: {
      maxTemperature: 100,
      requiredEquipment: ['Safety Goggles', 'Gloves'],
      hazardousReactions: ['explosive']
    },
    template: {
      type: 'reaction',
      config: {
        reactants: [
          { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
          { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
        ],
        products: [
          { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
        ],
        activationEnergy: 100,
        reactionType: 'synthesis',
        effects: ['explosion', 'flame']
      }
    },
    html: baseAnimationTemplate + `
      <script>
        const config = ${JSON.stringify({
          reactants: [
            { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
            { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
          ],
          products: [
            { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
          ],
          activationEnergy: 100,
          reactionType: 'synthesis',
          effects: ['explosion', 'flame']
        })};

        window.initAnimation = function() {
          console.log('Animation initialized with config:', config);
        };

        window.addEventListener('load', () => {
          window.initAnimation();
        });
      </script>
    `
  }),

  'states-of-matter': () => ({
    height: 350,
    autoPlay: true,
    loop: true,
    features: {
      temperature: true,
      zoom: true,
      speed: true,
      particleCount: true
    },
    safety: {
      maxTemperature: 100,
      requiredEquipment: ['Safety Goggles']
    },
    template: {
      type: 'state-change',
      config: {
        substance: 'H2O',
        initialState: 'solid',
        particleCount: 50
      }
    },
    html: baseAnimationTemplate + `
      <script>
        const config = ${JSON.stringify({
          substance: 'H2O',
          initialState: 'solid',
          particleCount: 50
        })};

        window.initAnimation = function() {
          console.log('States of matter animation ready');
        };

        window.addEventListener('load', () => {
          window.initAnimation();
        });
      </script>
    `
  }),

  // NEW: Interactive Chemistry Definition Animation
  'chemistry-definition-interactive': () => chemistryDefinitionInteractive,

  // Keep the original static version
  'chemistry-definition': () => chemistryDefinition,
};

export const getAnimation = (type: AnimationType): AnimationConfig => {
  const builder = animationBuilders[type];
  return builder ? builder() : {
    html: '<div>Animation not found</div>',
    height: 300,
    autoPlay: true,
    loop: false
  };
};

---- File Content End ----


=== File: ChemistryAnimation.tsx ===
Path: data\animations\ChemistryAnimation.tsx
---- File Content Start ----
// src/data/animations/ChemistryAnimation.tsx
import React, { useRef, useState, useEffect } from 'react';
import { Platform } from 'react-native';
import { View, StyleSheet, Dimensions, Text, TouchableOpacity } from 'react-native';
import { WebView } from 'react-native-webview';
import Slider from '@react-native-community/slider';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { getAnimation } from './animationRegistry';
import { AnimationType } from './types';
import { brandColors } from '@/lib/designSystem';
import { SafetyService } from './services/SafetyService';
import { SafetyStatus } from './types';
import { TemplateLoader } from './core/TemplateLoader';

interface ChemistryAnimationProps {
  type: AnimationType;
  height?: number;
  style?: any;
  onStateChange?: (state: any) => void;
}

const ChemistryAnimation: React.FC<ChemistryAnimationProps> = ({
  type,
  height,
  style,
  onStateChange
}) => {
  const config = getAnimation(type);
  const finalHeight = height || config.height;
  // Web fallback - render HTML directly
  if (Platform.OS === 'web') {
    return (
      <View style={[styles.container, { height: finalHeight }, style]}>
        <div
          style={{
            width: '100%',
            height: '100%',
            borderRadius: '12px',
            overflow: 'hidden'
          }}
          dangerouslySetInnerHTML={{ __html: config.html }}
        />
      </View>
    );
  }

  const webViewRef = useRef<WebView>(null);
  const features = config.features || {};



  // Control states
  const [temperature, setTemperature] = useState(20);
  const [zoom, setZoom] = useState(1);
  const [speed, setSpeed] = useState(1);
  const [showBefore, setShowBefore] = useState(true);
  const [rotation3D, setRotation3D] = useState(true);
  const [particleCount, setParticleCount] = useState(50);
  const [pressure, setPressure] = useState(1);
  const [concentration, setConcentration] = useState(0.5);
  const [isPlaying, setIsPlaying] = useState(config.autoPlay);

  // Send control updates to WebView
  const sendControlUpdate = (controlType: string, value: any) => {
    webViewRef.current?.postMessage(JSON.stringify({
      type: 'controlUpdate',
      control: controlType,
      value: value
    }));
  };

  // Safety checks
 const [safetyStatus, setSafetyStatus] = useState<SafetyStatus>({
  isSafe: true,
  warnings: [],
  requiredEquipment: []
});

// Add safety check function
const checkSafety = () => {
  const currentState = {
    temperature,
    pressure,
    concentration,
    reactionType: config.type
  };

  const status = SafetyService.checkSafety(config.safety, currentState);
  setSafetyStatus(status);

  // Post safety status to WebView
  sendControlUpdate('safetyStatus', status);
};

// Add useEffect to run safety checks
useEffect(() => {
  checkSafety();
}, [temperature, pressure, concentration, config.safety]);

  // Handle temperature change
  const handleTemperatureChange = (value: number) => {
    setTemperature(value);
    sendControlUpdate('temperature', value);
  };

  // Handle zoom change
  const handleZoomChange = (value: number) => {
    setZoom(value);
    sendControlUpdate('zoom', value);
  };

  // Handle speed change
  const handleSpeedChange = (value: number) => {
    setSpeed(value);
    sendControlUpdate('speed', value);
  };

  // Toggle before/after
  const toggleBeforeAfter = () => {
    setShowBefore(!showBefore);
    sendControlUpdate('beforeAfter', !showBefore);
  };

  // Toggle 3D rotation
  const toggle3DRotation = () => {
    setRotation3D(!rotation3D);
    sendControlUpdate('rotation3D', !rotation3D);
  };

  // Handle particle count
  const handleParticleCountChange = (value: number) => {
    setParticleCount(value);
    sendControlUpdate('particleCount', value);
  };

  // Handle WebView messages
  const handleMessage = (event: any) => {
    const data = JSON.parse(event.nativeEvent.data);

    if (data.type === 'animationComplete' && config.loop) {
      webViewRef.current?.postMessage(JSON.stringify({ action: 'restart' }));
    }

    if (data.type === 'stateUpdate' && onStateChange) {
      onStateChange(data.state);
    }
  };
  // Play/Pause control
  const togglePlayPause = () => {
    setIsPlaying(!isPlaying);
    sendControlUpdate('playPause', !isPlaying);
  };


  // Generate control panel HTML
  const getControlPanelHTML = () => {
    return `
      <style>
        .control-panel {
          position: absolute;
          bottom: 10px;
          left: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border-radius: 12px;
          padding: 12px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .control-row {
          margin-bottom: 8px;
          display: flex;
          align-items: center;
          justify-content: space-between;
        }
        .control-label {
          font-size: 12px;
          color: #333;
          font-weight: 500;
          min-width: 80px;
        }
        .control-value {
          font-size: 12px;
          color: #666;
          min-width: 40px;
          text-align: right;
        }
      </style>
    `;
  };

  return (
    <View style={[styles.container, { height: finalHeight + (features.temperature || features.zoom || features.speed ? 120 : 0) }, style]}>
       {!safetyStatus.isSafe && (
      <View style={styles.safetyWarning}>
        <MaterialCommunityIcons name="alert-circle" size={20} color="white" />
        <Text style={styles.safetyWarningText}>
          {safetyStatus.warnings.join(' • ')}
        </Text>
      </View>
    )}

    {/* Equipment Reminder */}
    {safetyStatus.requiredEquipment.length > 0 && (
      <View style={styles.equipmentWarning}>
        <MaterialCommunityIcons name="shield-check" size={16} color={brandColors.warning.dark} />
        <Text style={styles.equipmentWarningText}>
          Safety equipment required: {safetyStatus.requiredEquipment.join(', ')}
        </Text>
      </View>
    )}
      <WebView
        ref={webViewRef}
        source={{ html: config.html + getControlPanelHTML() }}
        style={styles.webview}
        scrollEnabled={false}
        onMessage={handleMessage}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        injectedJavaScript={`
         // 1. First, inject template if specified
    ${config.template ? TemplateLoader.getTemplateCode(config.template.type) : ''}

    // 2. Set up animation features
    window.animationFeatures = ${JSON.stringify(features)};
    window.initialState = {
      temperature: ${temperature},
      zoom: ${zoom},
      speed: ${speed},
      showBefore: ${showBefore},
      rotation3D: ${rotation3D},
      particleCount: ${particleCount},
      pressure: ${pressure},
      concentration: ${concentration},
      isPlaying: ${isPlaying}
    };

  // 3. Initialize with template if available
  if (${!!config.template}) {
    const templateConfig = ${JSON.stringify(config.template?.config || {})};

    window.addEventListener('load', () => {
      switch('${config.template?.type}') {
        case 'reaction':
          window.animation = new ReactionAnimation(templateConfig);
          break;
        case 'state-change':
          window.animation = new StateChangeAnimation(templateConfig);
          break;
        case 'dissolution':
          window.animation = new DissolutionAnimation(templateConfig);
          break;
        case 'definition': // ADD THIS CASE
          window.animation = new DefinitionAnimation(templateConfig);
          break;
      }

      // Auto-play if configured
      if (window.initialState.isPlaying && window.animation && window.animation.play) {
        window.animation.play();
      }
    });
  }

  true;
`}
      />

      {/* Native Control Panel */}
      {(features.temperature || features.zoom || features.speed || features.beforeAfter) && (
        <View style={styles.controlPanel}>
          {features.temperature && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Temperature</Text>
              <Slider
                style={styles.slider}
                minimumValue={-100}
                maximumValue={200}
                value={temperature}
                onValueChange={handleTemperatureChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{Math.round(temperature)}°C</Text>
            </View>
          )}

          {features.zoom && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Zoom</Text>
              <Slider
                style={styles.slider}
                minimumValue={0.5}
                maximumValue={3}
                value={zoom}
                onValueChange={handleZoomChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{zoom.toFixed(1)}x</Text>
            </View>
          )}

          {features.speed && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Speed</Text>
              <Slider
                style={styles.slider}
                minimumValue={0.1}
                maximumValue={3}
                value={speed}
                onValueChange={handleSpeedChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{speed.toFixed(1)}x</Text>
            </View>
          )}

          {features.particleCount && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Particles</Text>
              <Slider
                style={styles.slider}
                minimumValue={10}
                maximumValue={200}
                value={particleCount}
                onValueChange={handleParticleCountChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{Math.round(particleCount)}</Text>
            </View>
          )}

          <View style={styles.buttonRow}>
            <TouchableOpacity style={styles.controlButton} onPress={togglePlayPause}>
              <MaterialCommunityIcons
                name={isPlaying ? "pause" : "play"}
                size={24}
                color={brandColors.primary.main}
              />
            </TouchableOpacity>

            {features.beforeAfter && (
              <TouchableOpacity style={styles.controlButton} onPress={toggleBeforeAfter}>
                <Text style={styles.buttonText}>{showBefore ? 'Before' : 'After'}</Text>
              </TouchableOpacity>
            )}

            {features.rotation3D && (
              <TouchableOpacity style={styles.controlButton} onPress={toggle3DRotation}>
                <MaterialCommunityIcons
                  name="rotate-3d-variant"
                  size={24}
                  color={rotation3D ? brandColors.primary.main : brandColors.neutral.light}
                />
              </TouchableOpacity>
            )}
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    marginVertical: 16,
    borderRadius: 12,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
  },
  webview: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  controlPanel: {
    backgroundColor: 'white',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: brandColors.neutral.lighter,
  },
  controlRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  controlLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: brandColors.neutral.dark,
    width: 80,
  },
  slider: {
    flex: 1,
    height: 40,
    marginHorizontal: 8,
  },
  controlValue: {
    fontSize: 14,
    color: brandColors.neutral.main,
    width: 50,
    textAlign: 'right',
  },
  buttonRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 16,
    marginTop: 8,
  },
  controlButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: brandColors.neutral.lightest,
    borderWidth: 1,
    borderColor: brandColors.neutral.lighter,
    flexDirection: 'row',
    alignItems: 'center',
  },
  buttonText: {
    fontSize: 14,
    fontWeight: '500',
    color: brandColors.primary.main,
  },
  safetyWarning: {
    backgroundColor: brandColors.danger.main,
    padding: 10,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  safetyWarningText: {
    color: 'white',
    marginLeft: 5,
    fontSize: 14,
  },
  equipmentWarning: {
    backgroundColor: brandColors.warning.lightest,
    padding: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderBottomWidth: 1,
    borderBottomColor: brandColors.warning.light,
  },
  equipmentWarningText: {
    color: brandColors.warning.dark,
    marginLeft: 5,
    fontSize: 12,
  },
});

export default ChemistryAnimation;

---- File Content End ----


=== File: index.ts ===
Path: data\animations\index.ts
---- File Content Start ----
// src/data/animations/index.ts
export { default as ChemistryAnimation } from './ChemistryAnimation';
export { getAnimation } from './animationRegistry';
export type { AnimationType } from './types';

---- File Content End ----


=== File: merged_output.txt ===
Path: data\animations\merged_output.txt
---- File Content Start ----

=== File: AnimationFactory.ts ===
Path: AnimationFactory.ts
---- File Content Start ----
// src/data/animations/AnimationFactory.ts
import { ReactionAnimationTemplate } from './templates/ReactionTemplate';
import { StateChangeAnimationTemplate } from './templates/StateChangeTemplate';
import { DissolutionAnimationTemplate } from './templates/DissolutionTemplate';

export type AnimationType =
  | 'reaction'
  | 'state-change'
  | 'dissolution'
  | 'bonding'
  | 'equilibrium';

export interface AnimationConfig {
  type: AnimationType;
  containerId: string;
  params: any;
}

export class AnimationFactory {
  static create(config: AnimationConfig): ChemistryAnimationEngine {
    switch (config.type) {
      case 'reaction':
        return new ReactionAnimationTemplate(
          config.containerId,
          config.params
        );

      case 'state-change':
        return new StateChangeAnimationTemplate(
          config.containerId,
          config.params.substance,
          config.params.initialState
        );

      case 'dissolution':
        return new DissolutionAnimationTemplate(
          config.containerId,
          config.params.solute,
          config.params.solvent,
          config.params.saturationPoint
        );

      default:
        throw new Error(`Unknown animation type: ${config.type}`);
    }
  }
}

---- File Content End ----


=== File: animationRegistry.ts ===
Path: animationRegistry.ts
---- File Content Start ----
// src/data/animations/animationRegistry.ts
import { AnimationType, AnimationConfig } from './types';
import { baseAnimationTemplate } from './library/baseAnimationTemplate';
import { chemistryDefinition } from './library/chapter1/chemistryDefinition';

// Animation builders that create configs
const animationBuilders: Record<AnimationType, () => AnimationConfig> = {
  'hydrogen-oxygen-water': () => ({
    height: 500,
    autoPlay: false,
    loop: false,
    features: {
      temperature: true,
      beforeAfter: true,
      speed: true
    },
    safety: {
      maxTemperature: 100,
      requiredEquipment: ['Safety Goggles', 'Gloves'],
      hazardousReactions: ['explosive']
    },
    template: {
      type: 'reaction',
      config: {
        reactants: [
          { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
          { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
        ],
        products: [
          { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
        ],
        activationEnergy: 100,
        reactionType: 'synthesis',
        effects: ['explosion', 'flame']
      }
    },
    html: baseAnimationTemplate + `
      <script>
        // Template will be injected here by the wrapper
        const config = ${JSON.stringify({
          reactants: [
            { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
            { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
          ],
          products: [
            { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
          ],
          activationEnergy: 100,
          reactionType: 'synthesis',
          effects: ['explosion', 'flame']
        })};

        // Initialize animation with config
        window.initAnimation = function() {
          // This will be replaced by template injection
          console.log('Animation initialized with config:', config);
        };

        // Start when ready
        window.addEventListener('load', () => {
          window.initAnimation();
        });
      </script>
    `
  }),

  'states-of-matter': () => ({
    height: 350,
    autoPlay: true,
    loop: true,
    features: {
      temperature: true,
      zoom: true,
      speed: true,
      particleCount: true
    },
    safety: {
      maxTemperature: 100,
      requiredEquipment: ['Safety Goggles']
    },
    template: {
      type: 'state-change',
      config: {
        substance: 'H2O',
        initialState: 'solid',
        particleCount: 50
      }
    },
    html: baseAnimationTemplate + `
      <script>
        // Simplified - template config injected
        const config = ${JSON.stringify({
          substance: 'H2O',
          initialState: 'solid',
          particleCount: 50
        })};

        window.initAnimation = function() {
          console.log('States of matter animation ready');
        };

        window.addEventListener('load', () => {
          window.initAnimation();
        });
      </script>
    `
  }),
  'chemistry-definition': () => chemistryDefinition,
};

export const getAnimation = (type: AnimationType): AnimationConfig => {
  const builder = animationBuilders[type];
  return builder ? builder() : {
    html: '<div>Animation not found</div>',
    height: 300,
    autoPlay: true,
    loop: false
  };
};

---- File Content End ----


=== File: ChemistryAnimation.tsx ===
Path: ChemistryAnimation.tsx
---- File Content Start ----
// src/data/animations/ChemistryAnimation.tsx
import React, { useRef, useState, useEffect } from 'react';
import { View, StyleSheet, Dimensions, Text, TouchableOpacity } from 'react-native';
import { WebView } from 'react-native-webview';
import Slider from '@react-native-community/slider';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { getAnimation } from './animationRegistry';
import { AnimationType } from './types';
import { brandColors } from '@/lib/designSystem';
import { SafetyService } from './services/SafetyService';
import { SafetyStatus } from './types';
import { TemplateLoader } from './core/TemplateLoader';

interface ChemistryAnimationProps {
  type: AnimationType;
  height?: number;
  style?: any;
  onStateChange?: (state: any) => void;
}

const ChemistryAnimation: React.FC<ChemistryAnimationProps> = ({
  type,
  height,
  style,
  onStateChange
}) => {
  const webViewRef = useRef<WebView>(null);
  const config = getAnimation(type);
  const finalHeight = height || config.height;
  const features = config.features || {};

  // Control states
  const [temperature, setTemperature] = useState(20);
  const [zoom, setZoom] = useState(1);
  const [speed, setSpeed] = useState(1);
  const [showBefore, setShowBefore] = useState(true);
  const [rotation3D, setRotation3D] = useState(true);
  const [particleCount, setParticleCount] = useState(50);
  const [pressure, setPressure] = useState(1);
  const [concentration, setConcentration] = useState(0.5);
  const [isPlaying, setIsPlaying] = useState(config.autoPlay);

  // Send control updates to WebView
  const sendControlUpdate = (controlType: string, value: any) => {
    webViewRef.current?.postMessage(JSON.stringify({
      type: 'controlUpdate',
      control: controlType,
      value: value
    }));
  };

  // Safety checks
 const [safetyStatus, setSafetyStatus] = useState<SafetyStatus>({
  isSafe: true,
  warnings: [],
  requiredEquipment: []
});

// Add safety check function
const checkSafety = () => {
  const currentState = {
    temperature,
    pressure,
    concentration,
    reactionType: config.type
  };

  const status = SafetyService.checkSafety(config.safety, currentState);
  setSafetyStatus(status);

  // Post safety status to WebView
  sendControlUpdate('safetyStatus', status);
};

// Add useEffect to run safety checks
useEffect(() => {
  checkSafety();
}, [temperature, pressure, concentration, config.safety]);

  // Handle temperature change
  const handleTemperatureChange = (value: number) => {
    setTemperature(value);
    sendControlUpdate('temperature', value);
  };

  // Handle zoom change
  const handleZoomChange = (value: number) => {
    setZoom(value);
    sendControlUpdate('zoom', value);
  };

  // Handle speed change
  const handleSpeedChange = (value: number) => {
    setSpeed(value);
    sendControlUpdate('speed', value);
  };

  // Toggle before/after
  const toggleBeforeAfter = () => {
    setShowBefore(!showBefore);
    sendControlUpdate('beforeAfter', !showBefore);
  };

  // Toggle 3D rotation
  const toggle3DRotation = () => {
    setRotation3D(!rotation3D);
    sendControlUpdate('rotation3D', !rotation3D);
  };

  // Handle particle count
  const handleParticleCountChange = (value: number) => {
    setParticleCount(value);
    sendControlUpdate('particleCount', value);
  };

  // Handle WebView messages
  const handleMessage = (event: any) => {
    const data = JSON.parse(event.nativeEvent.data);

    if (data.type === 'animationComplete' && config.loop) {
      webViewRef.current?.postMessage(JSON.stringify({ action: 'restart' }));
    }

    if (data.type === 'stateUpdate' && onStateChange) {
      onStateChange(data.state);
    }
  };
  // Play/Pause control
  const togglePlayPause = () => {
    setIsPlaying(!isPlaying);
    sendControlUpdate('playPause', !isPlaying);
  };


  // Generate control panel HTML
  const getControlPanelHTML = () => {
    return `
      <style>
        .control-panel {
          position: absolute;
          bottom: 10px;
          left: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border-radius: 12px;
          padding: 12px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .control-row {
          margin-bottom: 8px;
          display: flex;
          align-items: center;
          justify-content: space-between;
        }
        .control-label {
          font-size: 12px;
          color: #333;
          font-weight: 500;
          min-width: 80px;
        }
        .control-value {
          font-size: 12px;
          color: #666;
          min-width: 40px;
          text-align: right;
        }
      </style>
    `;
  };

  return (
    <View style={[styles.container, { height: finalHeight + (features.temperature || features.zoom || features.speed ? 120 : 0) }, style]}>
       {!safetyStatus.isSafe && (
      <View style={styles.safetyWarning}>
        <MaterialCommunityIcons name="alert-circle" size={20} color="white" />
        <Text style={styles.safetyWarningText}>
          {safetyStatus.warnings.join(' • ')}
        </Text>
      </View>
    )}

    {/* Equipment Reminder */}
    {safetyStatus.requiredEquipment.length > 0 && (
      <View style={styles.equipmentWarning}>
        <MaterialCommunityIcons name="shield-check" size={16} color={brandColors.warning.dark} />
        <Text style={styles.equipmentWarningText}>
          Safety equipment required: {safetyStatus.requiredEquipment.join(', ')}
        </Text>
      </View>
    )}
      <WebView
        ref={webViewRef}
        source={{ html: config.html + getControlPanelHTML() }}
        style={styles.webview}
        scrollEnabled={false}
        onMessage={handleMessage}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        injectedJavaScript={`
         // 1. First, inject template if specified
    ${config.template ? TemplateLoader.getTemplateCode(config.template.type) : ''}

    // 2. Set up animation features
    window.animationFeatures = ${JSON.stringify(features)};
    window.initialState = {
      temperature: ${temperature},
      zoom: ${zoom},
      speed: ${speed},
      showBefore: ${showBefore},
      rotation3D: ${rotation3D},
      particleCount: ${particleCount},
      pressure: ${pressure},
      concentration: ${concentration},
      isPlaying: ${isPlaying}
    };

    // 3. Initialize with template if available
    if (${!!config.template}) {
      const templateConfig = ${JSON.stringify(config.template?.config || {})};

      window.addEventListener('load', () => {
        switch('${config.template?.type}') {
          case 'reaction':
            window.animation = new ReactionAnimation(templateConfig);
            break;
          case 'state-change':
            window.animation = new StateChangeAnimation(templateConfig);
            break;
          case 'dissolution':
            window.animation = new DissolutionAnimation(templateConfig);
            break;
          case 'definition': // <--- ADD THIS CASE
            window.animation = new DefinitionAnimation(templateConfig);
            break;
        }

        // Auto-play if configured
        if (window.initialState.isPlaying && window.animation && window.animation.play) {
          window.animation.play();
        }
      });
    }

    true;
        `}
      />

      {/* Native Control Panel */}
      {(features.temperature || features.zoom || features.speed || features.beforeAfter) && (
        <View style={styles.controlPanel}>
          {features.temperature && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Temperature</Text>
              <Slider
                style={styles.slider}
                minimumValue={-100}
                maximumValue={200}
                value={temperature}
                onValueChange={handleTemperatureChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{Math.round(temperature)}°C</Text>
            </View>
          )}

          {features.zoom && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Zoom</Text>
              <Slider
                style={styles.slider}
                minimumValue={0.5}
                maximumValue={3}
                value={zoom}
                onValueChange={handleZoomChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{zoom.toFixed(1)}x</Text>
            </View>
          )}

          {features.speed && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Speed</Text>
              <Slider
                style={styles.slider}
                minimumValue={0.1}
                maximumValue={3}
                value={speed}
                onValueChange={handleSpeedChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{speed.toFixed(1)}x</Text>
            </View>
          )}

          {features.particleCount && (
            <View style={styles.controlRow}>
              <Text style={styles.controlLabel}>Particles</Text>
              <Slider
                style={styles.slider}
                minimumValue={10}
                maximumValue={200}
                value={particleCount}
                onValueChange={handleParticleCountChange}
                minimumTrackTintColor={brandColors.primary.main}
                maximumTrackTintColor={brandColors.neutral.light}
              />
              <Text style={styles.controlValue}>{Math.round(particleCount)}</Text>
            </View>
          )}

          <View style={styles.buttonRow}>
            <TouchableOpacity style={styles.controlButton} onPress={togglePlayPause}>
              <MaterialCommunityIcons
                name={isPlaying ? "pause" : "play"}
                size={24}
                color={brandColors.primary.main}
              />
            </TouchableOpacity>

            {features.beforeAfter && (
              <TouchableOpacity style={styles.controlButton} onPress={toggleBeforeAfter}>
                <Text style={styles.buttonText}>{showBefore ? 'Before' : 'After'}</Text>
              </TouchableOpacity>
            )}

            {features.rotation3D && (
              <TouchableOpacity style={styles.controlButton} onPress={toggle3DRotation}>
                <MaterialCommunityIcons
                  name="rotate-3d-variant"
                  size={24}
                  color={rotation3D ? brandColors.primary.main : brandColors.neutral.light}
                />
              </TouchableOpacity>
            )}
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    marginVertical: 16,
    borderRadius: 12,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
  },
  webview: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  controlPanel: {
    backgroundColor: 'white',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: brandColors.neutral.lighter,
  },
  controlRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  controlLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: brandColors.neutral.dark,
    width: 80,
  },
  slider: {
    flex: 1,
    height: 40,
    marginHorizontal: 8,
  },
  controlValue: {
    fontSize: 14,
    color: brandColors.neutral.main,
    width: 50,
    textAlign: 'right',
  },
  buttonRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 16,
    marginTop: 8,
  },
  controlButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: brandColors.neutral.lightest,
    borderWidth: 1,
    borderColor: brandColors.neutral.lighter,
    flexDirection: 'row',
    alignItems: 'center',
  },
  buttonText: {
    fontSize: 14,
    fontWeight: '500',
    color: brandColors.primary.main,
  },
  safetyWarning: {
    backgroundColor: brandColors.danger.main,
    padding: 10,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  safetyWarningText: {
    color: 'white',
    marginLeft: 5,
    fontSize: 14,
  },
  equipmentWarning: {
    backgroundColor: brandColors.warning.lightest,
    padding: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderBottomWidth: 1,
    borderBottomColor: brandColors.warning.light,
  },
  equipmentWarningText: {
    color: brandColors.warning.dark,
    marginLeft: 5,
    fontSize: 12,
  },
});

export default ChemistryAnimation;

---- File Content End ----


=== File: indx.ts ===
Path: indx.ts
---- File Content Start ----
// src/data/animations/index.ts
export { default as ChemistryAnimation } from './ChemistryAnimation';
export { getAnimation } from './animationRegistry';
export type { AnimationType } from './types';

---- File Content End ----


=== File: types.ts ===
Path: types.ts
---- File Content Start ----
// src/data/animations/types.ts
export type AnimationTemplateType = 'reaction' | 'state-change' | 'dissolution' | 'bonding' | 'equilibrium' | 'definition';

export type AnimationType =
  | 'hydrogen-oxygen-water'
  | 'states-of-matter'
  | 'phase-changes'
  | 'carbon-allotropes'
  | 'solutions-colloids'
  | 'temperature-solubility'
  | 'chemistry-definition';
export interface AnimationConfig {
  html: string;
  height: number;
  autoPlay: boolean;
  loop: boolean;
  backgroundColor?: string;
  features?: AnimationFeatures;
  safety?: SafetyConstraints;
   template?: {
    type: AnimationTemplateType;
    config: any;
  };
}

export interface AnimationFeatures {
  temperature?: boolean;      // Enable temperature slider
  zoom?: boolean;             // Enable zoom controls
  speed?: boolean;            // Enable speed controls
  beforeAfter?: boolean;      // Enable before/after toggle
  rotation3D?: boolean;       // Enable 3D rotation
  particleCount?: boolean;    // Enable particle count control
  pressure?: boolean;         // Enable pressure control
  concentration?: boolean;    // Enable concentration slider
}

// src/data/animations/types.ts - ADD these new types
export interface AnimationEngine {
  play(): Promise<void>;
  pause(): void;
  reset(): void;
  setSpeed(speed: number): void;
  setTemperature?(temp: number): void;
}

export interface ChemicalEntity {
  element: string;
  position: { x: number; y: number; z?: number };
  state?: 'solid' | 'liquid' | 'gas' | 'aqueous';
}

export interface ReactionConfig {
  reactants: ChemicalEntity[];
  products: ChemicalEntity[];
  conditions?: {
    temperature?: number;
    pressure?: number;
    catalyst?: string;
  };
}

// Add to existing types
export interface SafetyConstraints {
  maxTemperature?: number;
  maxPressure?: number;
  maxConcentration?: number;
  minDistance?: number;
  requiredEquipment?: string[];
  hazardousReactions?: string[];
}

export interface SafetyStatus {
  isSafe: boolean;
  warnings: string[];
  requiredEquipment: string[];
}


---- File Content End ----


=== File: AnimationEngine.ts ===
Path: core\AnimationEngine.ts
---- File Content Start ----
// src/data/animations/core/AnimationEngine.ts
export abstract class ChemistryAnimationEngine {
  protected container: HTMLElement;
  protected atoms: Map<string, HTMLElement> = new Map();
  protected bonds: Map<string, HTMLElement> = new Map();
  protected molecules: Map<string, HTMLElement> = new Map();
  protected animationState: 'idle' | 'playing' | 'complete' = 'idle';

  constructor(containerId: string) {
    this.container = document.getElementById(containerId)!;
  }

  // Create atom with standardized styling
  protected createAtom(
    element: string,
    x: number,
    y: number,
    id: string
  ): HTMLElement {
    const elementData = ChemicalElement.get(element);
    const atom = document.createElement('div');

    atom.className = 'atom';
    atom.id = id;
    atom.style.cssText = `
      position: absolute;
      width: ${elementData.size}px;
      height: ${elementData.size}px;
      left: ${x}px;
      top: ${y}px;
      background: radial-gradient(circle at 30% 30%,
        ${this.lightenColor(elementData.color)},
        ${elementData.color}
      );
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: ${this.getTextColor(elementData.color)};
      font-size: ${elementData.size * 0.4}px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    `;

    atom.textContent = element;
    atom.dataset.element = element;
    atom.dataset.x = x.toString();
    atom.dataset.y = y.toString();

    this.atoms.set(id, atom);
    this.container.appendChild(atom);

    // Add interactions
    this.addAtomInteractions(atom);

    return atom;
  }

  // Create bond between atoms
  protected createBond(
    atom1Id: string,
    atom2Id: string,
    type: 'single' | 'double' | 'triple' | 'ionic',
    id: string
  ): HTMLElement {
    const atom1 = this.atoms.get(atom1Id)!;
    const atom2 = this.atoms.get(atom2Id)!;

    const bond = document.createElement('div');
    bond.className = `bond bond-${type}`;
    bond.id = id;

    const styles: Record<string, string> = {
      single: 'height: 3px; background: #4ecdc4;',
      double: 'height: 6px; background: #4ecdc4; box-shadow: 0 3px 0 #4ecdc4;',
      triple: 'height: 9px; background: #4ecdc4; box-shadow: 0 3px 0 #4ecdc4, 0 6px 0 #4ecdc4;',
      ionic: 'height: 3px; background: repeating-linear-gradient(90deg, #4ecdc4 0, #4ecdc4 5px, transparent 5px, transparent 10px);'
    };

    bond.style.cssText = `
      position: absolute;
      ${styles[type]}
      transform-origin: left center;
      transition: all 0.5s ease;
    `;

    this.updateBondPosition(bond, atom1, atom2);
    this.bonds.set(id, bond);
    this.container.appendChild(bond);

    return bond;
  }

  // Update bond position based on atom positions
  protected updateBondPosition(
    bond: HTMLElement,
    atom1: HTMLElement,
    atom2: HTMLElement
  ): void {
    const rect1 = atom1.getBoundingClientRect();
    const rect2 = atom2.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();

    const x1 = rect1.left - containerRect.left + rect1.width / 2;
    const y1 = rect1.top - containerRect.top + rect1.height / 2;
    const x2 = rect2.left - containerRect.left + rect2.width / 2;
    const y2 = rect2.top - containerRect.top + rect2.height / 2;

    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

    bond.style.width = `${length}px`;
    bond.style.left = `${x1}px`;
    bond.style.top = `${y1}px`;
    bond.style.transform = `rotate(${angle}deg)`;
  }

  // Create complete molecule from template
  protected createMolecule(
    formula: string,
    x: number,
    y: number,
    id: string
  ): HTMLElement {
    const template = MoleculeTemplates.get(formula);
    const molecule = document.createElement('div');
    molecule.className = 'molecule';
    molecule.id = id;
    molecule.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
    `;

    // Create atoms within molecule
    template.atoms.forEach((atomData, index) => {
      const atomId = `${id}-atom-${index}`;
      const atom = this.createAtom(
        atomData.element,
        atomData.position.x,
        atomData.position.y,
        atomId
      );
      molecule.appendChild(atom);
    });

    // Create bonds
    template.bonds.forEach((bondData, index) => {
      const bondId = `${id}-bond-${index}`;
      const atom1Id = `${id}-atom-${bondData.from}`;
      const atom2Id = `${id}-atom-${bondData.to}`;

      setTimeout(() => {
        this.createBond(atom1Id, atom2Id, bondData.type, bondId);
      }, 100);
    });

    this.molecules.set(id, molecule);
    this.container.appendChild(molecule);

    return molecule;
  }

  // Animation utilities
  protected async animateMove(
    element: HTMLElement,
    x: number,
    y: number,
    duration: number = 1000
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `all ${duration}ms ease-in-out`;
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;

      setTimeout(resolve, duration);
    });
  }

  protected async animateScale(
    element: HTMLElement,
    scale: number,
    duration: number = 500
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `transform ${duration}ms ease-in-out`;
      element.style.transform = `scale(${scale})`;

      setTimeout(resolve, duration);
    });
  }

  protected async animateFade(
    element: HTMLElement,
    opacity: number,
    duration: number = 500
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `opacity ${duration}ms ease-in-out`;
      element.style.opacity = opacity.toString();

      setTimeout(resolve, duration);
    });
  }

  // Helper methods
  private lightenColor(color: string): string {
    // Simple color lightening
    const num = parseInt(color.slice(1), 16);
    const amt = 40;
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return `#${(0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255))
      .toString(16).slice(1)}`;
  }

  private getTextColor(bgColor: string): string {
    // Determine if text should be light or dark
    const color = bgColor.slice(1);
    const r = parseInt(color.substr(0, 2), 16);
    const g = parseInt(color.substr(2, 2), 16);
    const b = parseInt(color.substr(4, 2), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155 ? '#000000' : '#FFFFFF';
  }

  private addAtomInteractions(atom: HTMLElement): void {
    atom.addEventListener('click', () => this.showAtomProperties(atom));
    atom.addEventListener('mouseenter', () => {
      if (this.animationState !== 'playing') {
        atom.style.transform = 'scale(1.1)';
        atom.style.zIndex = '10';
      }
    });
    atom.addEventListener('mouseleave', () => {
      if (this.animationState !== 'playing') {
        atom.style.transform = 'scale(1)';
        atom.style.zIndex = '1';
      }
    });
  }

  protected abstract showAtomProperties(atom: HTMLElement): void;
  public abstract play(): Promise<void>;
  public abstract reset(): void;
}

---- File Content End ----


=== File: ChemicalElements.ts ===
Path: core\ChemicalElements.ts
---- File Content Start ----
// src/data/animations/core/ChemicalElements.ts
export class ChemicalElement {
  static readonly ELEMENTS = {
    H: {
      name: 'Hydrogen',
      symbol: 'H',
      atomicNumber: 1,
      color: '#FFFFFF',
      size: 40,
      mass: 1.008,
      valence: 1,
      properties: [
        'Lightest element',
        'Highly flammable',
        'Colorless gas',
        'Forms H₂ molecules',
        'Explosive with oxygen'
      ]
    },
    O: {
      name: 'Oxygen',
      symbol: 'O',
      atomicNumber: 8,
      color: '#FF6B6B',
      size: 60,
      mass: 15.999,
      valence: 2,
      properties: [
        'Supports combustion',
        'Colorless gas',
        'Forms O₂ molecules',
        '21% of air',
        'Essential for life'
      ]
    },
    C: {
      name: 'Carbon',
      symbol: 'C',
      atomicNumber: 6,
      color: '#333333',
      size: 55,
      mass: 12.011,
      valence: 4,
      properties: [
        'Forms 4 bonds',
        'Basis of organic chemistry',
        'Multiple allotropes',
        'Black solid (graphite)',
        'Forms chains and rings'
      ]
    },
    N: {
      name: 'Nitrogen',
      symbol: 'N',
      atomicNumber: 7,
      color: '#0066CC',
      size: 52,
      mass: 14.007,
      valence: 3,
      properties: [
        'Inert gas',
        '78% of air',
        'Forms N₂ molecules',
        'Triple bond in N₂',
        'Essential for proteins'
      ]
    },
    Na: {
      name: 'Sodium',
      symbol: 'Na',
      atomicNumber: 11,
      color: '#FFD700',
      size: 65,
      mass: 22.990,
      valence: 1,
      properties: [
        'Soft metal',
        'Highly reactive',
        'Stored in oil',
        'Forms Na+ ions',
        'Explodes in water'
      ]
    },
    Cl: {
      name: 'Chlorine',
      symbol: 'Cl',
      atomicNumber: 17,
      color: '#00FF00',
      size: 62,
      mass: 35.453,
      valence: 1,
      properties: [
        'Toxic gas',
        'Green-yellow color',
        'Forms Cl₂ molecules',
        'Strong oxidizer',
        'Used in bleach'
      ]
    }
  };

  static get(symbol: string) {
    return this.ELEMENTS[symbol];
  }
}

---- File Content End ----


=== File: MoleculeTemplates.ts ===
Path: core\MoleculeTemplates.ts
---- File Content Start ----
// src/data/animations/core/MoleculeTemplates.ts
export interface MoleculeStructure {
  atoms: Array<{
    element: string;
    position: { x: number; y: number; z?: number };
    id?: string;
  }>;
  bonds: Array<{
    from: number;
    to: number;
    type: 'single' | 'double' | 'triple' | 'ionic';
    angle?: number;
  }>;
  properties?: string[];
  state?: 'solid' | 'liquid' | 'gas' | 'aqueous';
}

export class MoleculeTemplates {
  static readonly MOLECULES: Record<string, MoleculeStructure> = {
    'H2': {
      atoms: [
        { element: 'H', position: { x: -20, y: 0 } },
        { element: 'H', position: { x: 20, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'single' }],
      state: 'gas'
    },
    'O2': {
      atoms: [
        { element: 'O', position: { x: -30, y: 0 } },
        { element: 'O', position: { x: 30, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'double' }],
      state: 'gas'
    },
    'H2O': {
      atoms: [
        { element: 'O', position: { x: 0, y: 0 } },
        { element: 'H', position: { x: -30, y: 25 }, id: 'H1' },
        { element: 'H', position: { x: 30, y: 25 }, id: 'H2' }
      ],
      bonds: [
        { from: 0, to: 1, type: 'single', angle: 104.5 },
        { from: 0, to: 2, type: 'single', angle: 104.5 }
      ],
      properties: [
        'Universal solvent',
        'Bent shape (104.5°)',
        'Polar molecule',
        'High surface tension',
        'Expands when frozen'
      ],
      state: 'liquid'
    },
    'NaCl': {
      atoms: [
        { element: 'Na', position: { x: -40, y: 0 } },
        { element: 'Cl', position: { x: 40, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'ionic' }],
      properties: [
        'Table salt',
        'Ionic compound',
        'Crystal lattice',
        'Soluble in water',
        'High melting point'
      ],
      state: 'solid'
    },
    'CO2': {
      atoms: [
        { element: 'C', position: { x: 0, y: 0 } },
        { element: 'O', position: { x: -50, y: 0 } },
        { element: 'O', position: { x: 50, y: 0 } }
      ],
      bonds: [
        { from: 0, to: 1, type: 'double' },
        { from: 0, to: 2, type: 'double' }
      ],
      properties: [
        'Linear molecule',
        'Greenhouse gas',
        'Dry ice when solid',
        'Acidic in water',
        'Fire extinguisher'
      ],
      state: 'gas'
    }
  };

  static get(formula: string): MoleculeStructure {
    return this.MOLECULES[formula];
  }
}

---- File Content End ----


=== File: TemplateLoader.ts ===
Path: core\TemplateLoader.ts
---- File Content Start ----
// src/data/animations/core/TemplateLoader.ts
import { AnimationTemplateType } from '../types';

export class TemplateLoader {
  static getTemplateCode(templateType: AnimationTemplateType): string {
    switch (templateType) {
      case 'reaction':
        return `
          class ReactionAnimation {
            constructor(config) {
              this.config = config;
              this.container = document.getElementById('animation-container');
              this.init();
            }

            init() {
              const equation = document.createElement('div');
              equation.className = 'equation-display';
              equation.innerHTML = this.buildEquation();
              this.container.appendChild(equation);
              this.createReactants();
            }

            buildEquation() {
              const reactants = this.config.reactants.map(r =>
                r.count > 1 ? \`\${r.count}\${r.formula}\` : r.formula
              ).join(' + ');

              const products = this.config.products.map(p =>
                p.count > 1 ? \`\${p.count}\${p.formula}\` : p.formula
              ).join(' + ');

              return \`\${reactants} → \${products}\`;
            }

            createReactants() {
              console.log('Creating reactants:', this.config.reactants);
            }

            play() {
              console.log('Playing reaction animation');
            }
          }
        `;

      case 'state-change':
        return `
          class StateChangeAnimation {
            constructor(config) {
              this.config = config;
              this.container = document.getElementById('animation-container');
              this.currentState = config.initialState;
              this.init();
            }

            init() {
              this.createParticles();
              this.arrangeParticles(this.currentState);
            }

            createParticles() {
              console.log('Creating particles for', this.config.substance);
            }

            arrangeParticles(state) {
              console.log('Arranging particles in', state, 'state');
            }

            transitionTo(newState) {
              this.currentState = newState;
              this.arrangeParticles(newState);
            }
          }
        `;

      case 'definition':
        return `
          class DefinitionAnimation {
            constructor() {
              this.container = document.getElementById('animation-container');
              this.init();
            }

            init() {
              const keywords = ['Properties', 'Composition', 'Structure'];

              keywords.forEach((keyword, index) => {
                const card = document.createElement('div');
                card.className = 'concept-card';
                card.textContent = keyword;
                card.style.cssText = \`
                  width: 120px;
                  height: 120px;
                  margin: 10px;
                  background: #4ecdc4;
                  color: white;
                  display: inline-flex;
                  align-items: center;
                  justify-content: center;
                  font-weight: bold;
                  font-size: 16px;
                  border-radius: 12px;
                  cursor: pointer;
                  transition: transform 0.3s ease;
                \`;

                card.addEventListener('click', () => this.showDetail(keyword));
                this.container.appendChild(card);
              });
            }

            showDetail(keyword) {
              const detail = document.createElement('div');
              detail.className = 'concept-detail';
              detail.style.cssText = \`
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                padding: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                border-radius: 12px;
                font-size: 16px;
                text-align: center;
                max-width: 300px;
              \`;

              if (keyword === 'Properties') {
                detail.innerHTML = '<strong>Oxygen (O₂)</strong><br>• Supports combustion<br>• Colorless gas<br>• Essential for life';
              } else if (keyword === 'Composition') {
                detail.innerHTML = '<strong>Water (H₂O)</strong><br>• 2 Hydrogen + 1 Oxygen<br>• Forms by chemical reaction';
              } else if (keyword === 'Structure') {
                detail.innerHTML = '<strong>Carbon dioxide (CO₂)</strong><br>• Linear molecule<br>• Double bonds between C and O';
              }

              // Remove existing detail panels
              const existing = this.container.querySelector('.concept-detail');
              if (existing) existing.remove();

              this.container.appendChild(detail);

              setTimeout(() => {
                detail.style.opacity = '0';
                setTimeout(() => detail.remove(), 2000);
              }, 3000);
            }

            play() {
              console.log('Definition animation started');
            }
          }
        `;

      default:
        return '';
    }
  }
}

---- File Content End ----


=== File: baseAnimationTemplate.ts ===
Path: library\baseAnimationTemplate.ts
---- File Content Start ----
export const baseAnimationTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: box-shadow 0.3s ease;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #safety-warning {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 90%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Animation state
        let animationState = {
            temperature: 20,
            zoom: 1,
            speed: 1,
            showBefore: true,
            rotation3D: true,
            particleCount: 50,
            pressure: 1,
            concentration: 0.5,
            isPlaying: true,
            safetyStatus: { isSafe: true, warnings: [] }
        };

        // Initialize with passed state
        if (window.initialState) {
            animationState = { ...animationState, ...window.initialState };
        }

        // Safety functions
        function handleSafetyStatus(status) {
            if (!status.isSafe) {
                document.body.style.boxShadow = 'inset 0 0 0 3px #ff3b30';
                showSafetyWarning(status.warnings);
            } else {
                document.body.style.boxShadow = 'none';
                hideSafetyWarning();
            }
        }

        function showSafetyWarning(warnings) {
            let warningEl = document.getElementById('safety-warning');
            if (!warningEl) {
                warningEl = document.createElement('div');
                warningEl.id = 'safety-warning';
                document.body.appendChild(warningEl);
            }

            // Update content
            warningEl.innerHTML = warnings.join(' ⚠️ ') +
                '<br><small>Adjust parameters to safe levels</small>';
        }

        function hideSafetyWarning() {
            const warningEl = document.getElementById('safety-warning');
            if (warningEl) warningEl.remove();
        }

        // Handle control updates from React Native
        window.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'controlUpdate') {
                    animationState[data.control] = data.value;

                    // Handle safety update
                    if (data.control === 'safetyStatus') {
                        handleSafetyStatus(data.value);
                    }

                    // Call animation-specific update handler
                    if (window.handleControlUpdate) {
                        window.handleControlUpdate(data.control, data.value);
                    }
                }

                if (data.action === 'restart' && window.resetAnimation) {
                    window.resetAnimation();
                }
            } catch (e) {
                console.error('Message handling error:', e);
            }
        });

        // Send state updates back to React Native
        function sendStateUpdate(state) {
            if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'stateUpdate',
                    state: state
                }));
            }
        }

        // Common animation utilities
        const AnimationUtils = {
            // Temperature effects
            getTemperatureColor: (temp) => {
                if (temp < 0) return 0x87CEEB; // Ice blue
                if (temp < 50) return 0x4169E1; // Royal blue
                if (temp < 100) return 0xFF8C00; // Dark orange
                return 0xFF4500; // Orange red
            },

            // Particle motion based on temperature
            getParticleSpeed: (temp) => {
                return 0.001 + (temp + 100) / 10000;
            },

            // Zoom handling
            applyZoom: (camera, zoom) => {
                camera.position.z = 15 / zoom;
                camera.updateProjectionMatrix();
            },

            // Speed time scaling
            getTimeScale: (speed) => {
                return speed;
            },

            // Particle visibility
            updateParticleCount: (particles, count) => {
                particles.forEach((p, i) => {
                    p.visible = i < count;
                });
            }
        };

        // Export for use in animations
        window.AnimationUtils = AnimationUtils;
        window.animationState = animationState;
        window.sendStateUpdate = sendStateUpdate;

        // Initialize safety status
        handleSafetyStatus(animationState.safetyStatus);
    </script>
</body>
</html>
`;

---- File Content End ----


=== File: chemistryCoreConcepts.ts ===
Path: library\chemistryCoreConcepts.ts
---- File Content Start ----
// In animationRegistry.ts or a new file like 'chemistryCoreConcepts.ts'
export const chemistryCoreConcepts: AnimationConfig = {
  height: 400, // Good height for visibility of details
  autoPlay: true,
  loop: false, // It's a narrative animation, so likely no loop or a very long one
  backgroundColor: '#1f2937', // A dark, neutral background (e.g., dark slate gray)
  features: {
    temperature: true,    // For Scene 2 (Properties/Phase Changes) & Scene 5
    zoom: true,           // Generally useful for all scenes
    speed: true,          // For controlling animation rates in all scenes
    beforeAfter: true,    // For Scene 5 (Chemical Change)
    rotation3D: true,     // For Scene 3, 4, 6 (Composition, Structure, Conclusion)
    particleCount: true,  // For Scene 2 (Properties) & Scene 3 (Composition)
    // pressure: false,   // Less critical for this core overview
    // concentration: false // Less critical for this core overview
  },
  html: `<!-- HTML structure will be baseAnimationTemplate + specific script -->`
};

---- File Content End ----


=== File: hydrogenOxygenWater.ts ===
Path: library\hydrogenOxygenWater.ts
---- File Content Start ----
// src/data/animations/library/hydrogenOxygenWater.ts
import { AnimationConfig } from '../types';
import { baseAnimationTemplate } from './baseAnimationTemplate';

export const hydrogenOxygenWater: AnimationConfig = {
  height: 500,
  autoPlay: true,
  loop: false,
  features: {
    speed: true,
    beforeAfter: true,
    rotation3D: true,
    temperature: true,
  },
    safety: {
        maxTemperature: 100,
        maxPressure: 2,
        maxConcentration: 1.0,
        minDistance: 0.5,
        requiredEquipment: ['Safety Goggles', 'Gloves'],
        hazardousReactions: ['explosive', 'toxic']
    },
  html: baseAnimationTemplate + `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        /* Add your full animation styles here */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Your full Three.js animation code here
        // Add message posting for communication with React Native

        // When animation completes:
        window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'animationComplete'
        }));

        // Listen for control messages
        window.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            if (data.action === 'restart') {
                resetAnimation();
            }
        });
    </script>
</body>
</html>
`
};

---- File Content End ----


=== File: statesOfMatter.ts ===
Path: library\statesOfMatter.ts
---- File Content Start ----
// src/data/animations/library/statesOfMatter.ts
import { AnimationConfig } from '../types';
import { baseAnimationTemplate } from './baseAnimationTemplate';

export const statesOfMatter: AnimationConfig = {
  height: 350,
  autoPlay: true,
  loop: true,
  features: {
    temperature: true,
    zoom: true,
    speed: true,
    particleCount: true
  },
 safety: {
    maxTemperature: 100,
    maxPressure: 2,
    maxConcentration: 1.0,
    minDistance: 0.5,
    requiredEquipment: ['Safety Goggles', 'Gloves'],
    hazardousReactions: ['explosive', 'toxic']
 },
  html: baseAnimationTemplate + `
    <script>
        // States of Matter specific animation code
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Create particles for each state
        const particles = [];
        const particleGeometry = new THREE.SphereGeometry(0.3, 16, 16);

        // Create particle grid
        for (let i = 0; i < 200; i++) {
            const material = new THREE.MeshPhongMaterial({
                color: 0x3498db,
                emissive: 0x2980b9,
                emissiveIntensity: 0.2
            });
            const particle = new THREE.Mesh(particleGeometry, material);
            particle.userData.basePosition = new THREE.Vector3(
                (i % 10 - 5) * 1.5,
                (Math.floor(i / 10) % 10 - 5) * 1.5,
                (Math.floor(i / 100) - 1) * 1.5
            );
            particle.position.copy(particle.userData.basePosition);
            scene.add(particle);
            particles.push(particle);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Handle control updates
        window.handleControlUpdate = (control, value) => {
            if (control === 'temperature') {
                // Update particle colors based on temperature
                particles.forEach(p => {
                    p.material.color.setHex(AnimationUtils.getTemperatureColor(value));
                });
            }
            if (control === 'zoom') {
                AnimationUtils.applyZoom(camera, value);
            }
            if (control === 'particleCount') {
                AnimationUtils.updateParticleCount(particles, value);
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (animationState.isPlaying) {
                const time = Date.now() * 0.001 * animationState.speed;
                const temp = animationState.temperature;

                particles.forEach((particle, i) => {
                    if (!particle.visible) return;

                    const basePos = particle.userData.basePosition;

                    if (temp < 0) {
                        // Solid state - vibrate in place
                        particle.position.x = basePos.x + Math.sin(time * 2 + i) * 0.1;
                        particle.position.y = basePos.y + Math.cos(time * 2 + i) * 0.1;
                        particle.position.z = basePos.z;
                    } else if (temp < 100) {
                        // Liquid state - flow but stay close
                        const flowSpeed = temp / 100;
                        particle.position.x = basePos.x + Math.sin(time + i) * flowSpeed;
                        particle.position.y = basePos.y + Math.cos(time + i) * flowSpeed;
                        particle.position.z = basePos.z + Math.sin(time * 0.5 + i) * flowSpeed * 0.5;
                    } else {
                        // Gas state - random motion
                        const speed = AnimationUtils.getParticleSpeed(temp);
                        particle.position.x += (Math.random() - 0.5) * speed * 50;
                        particle.position.y += (Math.random() - 0.5) * speed * 50;
                        particle.position.z += (Math.random() - 0.5) * speed * 50;

                        // Boundary check
                        if (Math.abs(particle.position.x) > 20) particle.position.x *= -0.9;
                        if (Math.abs(particle.position.y) > 20) particle.position.y *= -0.9;
                        if (Math.abs(particle.position.z) > 20) particle.position.z *= -0.9;
                    }
                });

                if (animationState.rotation3D) {
                    scene.rotation.y += 0.005 * animationState.speed;
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize controls
        window.handleControlUpdate('temperature', animationState.temperature);
        window.handleControlUpdate('zoom', animationState.zoom);
        window.handleControlUpdate('particleCount', animationState.particleCount);

        animate();
    </script>
  </body>
  </html>
`
};

---- File Content End ----


=== File: chemistryDefinition.ts ===
Path: library\chapter1\chemistryDefinition.ts
---- File Content Start ----
// src/data/animations/library/chapter1/chemistryDefinition.ts
import { AnimationConfig } from '../../types';
import { baseAnimationTemplate } from '../baseAnimationTemplate';

export const chemistryDefinition: AnimationConfig = {
  height: 600,
  autoPlay: true,
  loop: false,
  features: {
    speed: true,
  },
  html: baseAnimationTemplate + `
    <style>
      #animation-container {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        position: relative;
        overflow: hidden;
      }

      /* Title Section */
      .title-section {
        text-align: center;
        margin-bottom: 30px;
        opacity: 0;
        transform: translateY(-20px);
        animation: fadeInDown 1s forwards;
      }

      .main-title {
        font-size: 28px;
        font-weight: bold;
        color: white;
        margin-bottom: 10px;
      }

      .definition-text {
        font-size: 16px;
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.5;
        max-width: 500px;
        margin: 0 auto;
      }

      .highlight {
        background: rgba(255, 255, 255, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .highlight:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      /* Branch Cards */
      .branches-container {
        display: flex;
        gap: 20px;
        margin-top: 40px;
        opacity: 0;
        animation: fadeIn 1s forwards 0.5s;
      }

      .branch-card {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 20px;
        width: 160px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .branch-card:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .branch-card.active {
        background: rgba(255, 255, 255, 0.3);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .branch-icon {
        font-size: 48px;
        margin-bottom: 10px;
      }

      .branch-title {
        font-size: 18px;
        font-weight: bold;
        color: white;
        margin-bottom: 5px;
      }

      .branch-subtitle {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
      }

      /* Content Panels */
      .content-panel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 16px;
        padding: 20px;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.5s ease;
        max-height: 200px;
        overflow-y: auto;
      }

      .content-panel.active {
        opacity: 1;
        transform: translateY(0);
      }

      .panel-title {
        font-size: 20px;
        font-weight: bold;
        color: #4ecdc4;
        margin-bottom: 10px;
      }

      .panel-content {
        color: white;
        line-height: 1.6;
      }

      /* Properties Panel */
      .element-display {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-top: 15px;
      }

      .element-box {
        background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
        width: 80px;
        height: 80px;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        animation: pulse 2s infinite;
      }

      .element-symbol {
        font-size: 36px;
        font-weight: bold;
      }

      .element-name {
        font-size: 12px;
      }

      .properties-list {
        flex: 1;
      }

      .property-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        opacity: 0;
        animation: slideInRight 0.5s forwards;
      }

      .property-item:nth-child(1) { animation-delay: 0.1s; }
      .property-item:nth-child(2) { animation-delay: 0.2s; }
      .property-item:nth-child(3) { animation-delay: 0.3s; }
      .property-item:nth-child(4) { animation-delay: 0.4s; }

      .property-icon {
        font-size: 20px;
      }

      .property-text {
        font-size: 14px;
      }

      /* Composition Panel */
      .molecule-display {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin: 20px 0;
      }

      .atom {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        font-size: 20px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        animation: bounceIn 0.5s;
      }

      .atom-hydrogen {
        background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
        color: #333;
      }

      .atom-oxygen {
        background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
      }

      .bond {
        width: 30px;
        height: 3px;
        background: #4ecdc4;
        animation: expandWidth 0.5s;
      }

      .formula-display {
        text-align: center;
        margin-top: 10px;
        font-size: 24px;
        font-weight: bold;
        color: white;
      }

      /* Structure Panel */
      .structure-display {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
        position: relative;
        height: 120px;
      }

      .structure-molecule {
        position: relative;
        animation: rotate3d 10s linear infinite;
        transform-style: preserve-3d;
      }

      .structure-atom {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        font-size: 16px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      }

      .structure-bond {
        position: absolute;
        background: #4ecdc4;
        height: 3px;
        transform-origin: left center;
      }

      .angle-display {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        color: #4ecdc4;
        font-size: 14px;
        font-weight: bold;
      }

      /* Animations */
      @keyframes fadeInDown {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      @keyframes pulse {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      @keyframes slideInRight {
        from {
          opacity: 0;
          transform: translateX(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes bounceIn {
        0% {
          transform: scale(0);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes expandWidth {
        from {
          width: 0;
        }
        to {
          width: 30px;
        }
      }

      @keyframes rotate3d {
        from {
          transform: rotateY(0deg);
        }
        to {
          transform: rotateY(360deg);
        }
      }

      /* Mobile responsiveness */
      @media (max-width: 600px) {
        .branches-container {
          flex-direction: column;
          gap: 15px;
          align-items: center;
        }

        .branch-card {
          width: 200px;
        }

        .main-title {
          font-size: 24px;
        }

        .definition-text {
          font-size: 14px;
        }
      }
    </style>

    <div id="animation-container">
      <!-- Title Section -->
      <div class="title-section">
        <h1 class="main-title">What is Chemistry?</h1>
        <p class="definition-text">
          Chemistry is the branch of science that deals with the
          <span class="highlight" data-branch="properties">properties</span>,
          <span class="highlight" data-branch="composition">composition</span>, and
          <span class="highlight" data-branch="structure">structure</span>
          of substances, as well as the physical and chemical changes in matter.
        </p>
      </div>

      <!-- Branch Cards -->
      <div class="branches-container">
        <div class="branch-card" data-branch="properties">
          <div class="branch-icon">🔬</div>
          <div class="branch-title">Properties</div>
          <div class="branch-subtitle">What it's like</div>
        </div>

        <div class="branch-card" data-branch="composition">
          <div class="branch-icon">⚛️</div>
          <div class="branch-title">Composition</div>
          <div class="branch-subtitle">What it's made of</div>
        </div>

        <div class="branch-card" data-branch="structure">
          <div class="branch-icon">🧬</div>
          <div class="branch-title">Structure</div>
          <div class="branch-subtitle">How it's arranged</div>
        </div>
      </div>

      <!-- Content Panels -->
      <div class="content-panel" id="properties-panel">
        <div class="panel-title">Properties of Matter</div>
        <div class="panel-content">
          <div class="element-display">
            <div class="element-box">
              <div class="element-symbol">O</div>
              <div class="element-name">Oxygen</div>
            </div>
            <div class="properties-list">
              <div class="property-item">
                <span class="property-icon">🌡️</span>
                <span class="property-text">Boiling point: -183°C</span>
              </div>
              <div class="property-item">
                <span class="property-icon">💨</span>
                <span class="property-text">Colorless gas</span>
              </div>
              <div class="property-item">
                <span class="property-icon">🔥</span>
                <span class="property-text">Supports combustion</span>
              </div>
              <div class="property-item">
                <span class="property-icon">⚗️</span>
                <span class="property-text">Highly reactive</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="content-panel" id="composition-panel">
        <div class="panel-title">Composition of Matter</div>
        <div class="panel-content">
          <div class="molecule-display">
            <div class="atom atom-hydrogen">H</div>
            <div class="bond"></div>
            <div class="atom atom-oxygen">O</div>
            <div class="bond"></div>
            <div class="atom atom-hydrogen">H</div>
          </div>
          <div class="formula-display">H₂O = 2 Hydrogen + 1 Oxygen</div>
          <p style="text-align: center; margin-top: 10px; font-size: 14px;">
            Water is composed of hydrogen and oxygen atoms in a 2:1 ratio
          </p>
        </div>
      </div>

      <div class="content-panel" id="structure-panel">
        <div class="panel-title">Structure of Matter</div>
        <div class="panel-content">
          <div class="structure-display">
            <div class="structure-molecule">
              <div class="structure-atom atom-oxygen" style="left: 50px; top: 40px;">O</div>
              <div class="structure-atom atom-hydrogen" style="left: 20px; top: 80px;">H</div>
              <div class="structure-atom atom-hydrogen" style="left: 80px; top: 80px;">H</div>
              <div class="structure-bond" style="left: 50px; top: 50px; width: 40px; transform: rotate(140deg);"></div>
              <div class="structure-bond" style="left: 70px; top: 50px; width: 40px; transform: rotate(40deg);"></div>
            </div>
            <div class="angle-display">Bond angle: 104.5°</div>
          </div>
          <p style="text-align: center; font-size: 14px;">
            The bent shape of water gives it unique properties like polarity
          </p>
        </div>
      </div>
    </div>

    <script>
      // Initialize animation
      let currentPanel = null;
      // Local animationSpeed variable is removed, use window.animationState.speed

      // Get all interactive elements
      const highlights = document.querySelectorAll('.highlight');
      const branchCards = document.querySelectorAll('.branch-card');
      const contentPanels = document.querySelectorAll('.content-panel');

      // Add click handlers to highlights
      highlights.forEach(highlight => {
        highlight.addEventListener('click', () => {
          const branch = highlight.dataset.branch;
          showPanel(branch);
        });
      });

      // Add click handlers to branch cards
      branchCards.forEach(card => {
        card.addEventListener('click', () => {
          const branch = card.dataset.branch;
          showPanel(branch);
        });
      });

      // Show panel function
      function showPanel(branch) {
        branchCards.forEach(card => card.classList.remove('active'));
        contentPanels.forEach(panel => panel.classList.remove('active'));

        const panel = document.getElementById(branch + '-panel');
        if (panel) {
          const card = document.querySelector(`.branch-card[data-branch="${branch}"]`);
          if (card) card.classList.add('active');
          setTimeout(() => {
            panel.classList.add('active');
            if (branch === 'properties') {
              resetPropertyAnimations(window.animationState.speed);
            } else if (branch === 'composition') {
              resetCompositionAnimations(window.animationState.speed);
            }
          }, 50); // Small delay for UI update
          currentPanel = branch;
        }
      }

      // Reset animations and apply current speed
      function resetPropertyAnimations(currentSpeed) {
        const items = document.querySelectorAll('#properties-panel .property-item');
        items.forEach((item, index) => {
          item.style.animation = 'none'; // Clear previous animation
          // Force reflow to ensure animation restarts
          // eslint-disable-next-line no-unused-expressions
          item.offsetHeight;
          const baseDuration = 0.5;
          const baseDelay = index * 0.1;
          item.style.animationName = 'slideInRight';
          item.style.animationDuration = `${baseDuration / currentSpeed}s`;
          item.style.animationDelay = `${baseDelay / currentSpeed}s`;
          item.style.animationFillMode = 'forwards';
          item.style.animationTimingFunction = 'ease'; // Assuming default, adjust if needed
        });
      }

      function resetCompositionAnimations(currentSpeed) {
        const atoms = document.querySelectorAll('#composition-panel .molecule-display .atom');
        const bonds = document.querySelectorAll('#composition-panel .molecule-display .bond');
        const baseDuration = 0.5;

        atoms.forEach(atom => {
          atom.style.animation = 'none';
          // eslint-disable-next-line no-unused-expressions
          atom.offsetHeight;
          atom.style.animationName = 'bounceIn';
          atom.style.animationDuration = `${baseDuration / currentSpeed}s`;
          atom.style.animationFillMode = 'forwards';
        });

        bonds.forEach(bond => {
          bond.style.animation = 'none';
          // eslint-disable-next-line no-unused-expressions
          bond.offsetHeight;
          bond.style.animationName = 'expandWidth';
          bond.style.animationDuration = `${baseDuration / currentSpeed}s`;
          bond.style.animationFillMode = 'forwards';
        });
      }

      // Function to adjust durations of CSS-defined animations
      function updateStaticCssAnimationSpeeds(currentSpeed) {
        const speedMultiplier = 1 / currentSpeed;

        const titleSection = document.querySelector('.title-section');
        if (titleSection) { // Base duration 1s
          titleSection.style.animationDuration = `${1 * speedMultiplier}s`;
        }

        const branchesContainer = document.querySelector('.branches-container');
        if (branchesContainer) { // Base duration 1s, base delay 0.5s
          branchesContainer.style.animationDuration = `${1 * speedMultiplier}s`;
          branchesContainer.style.animationDelay = `${0.5 * speedMultiplier}s`;
        }

        const elementBox = document.querySelector('#properties-panel .element-box');
        if (elementBox) { // Base duration 2s for pulse
            elementBox.style.animationDuration = `${2 * speedMultiplier}s`;
        }

        const structureMolecule = document.querySelector('#structure-panel .structure-molecule');
        if (structureMolecule) { // Base duration 10s for rotate3d
            structureMolecule.style.animationDuration = `${10 * speedMultiplier}s`;
        }

        // Add any other elements with CSS @keyframe animations here
      }


      // Auto-show first panel after intro, respecting initial speed
      // This needs to wait for window.animationState to be potentially updated by initialState
      window.addEventListener('load', () => {
        // Initialize animations with the current speed
        updateStaticCssAnimationSpeeds(window.animationState.speed);

        // If properties panel is the first one, its animations will be set by showPanel
        setTimeout(() => {
          showPanel('properties');
        }, 2000 / window.animationState.speed);


        // Set up handler for future speed changes from React Native
        window.handleControlUpdate = function(control, value) {
          if (control === 'speed') {
            updateStaticCssAnimationSpeeds(value);
            // If a panel is active, re-apply its dynamic animations with new speed
            if (currentPanel === 'properties') {
              resetPropertyAnimations(value);
            } else if (currentPanel === 'composition') {
              resetCompositionAnimations(value);
            }
          }
          // Handle other controls if necessary for this specific animation
        };

        // Send ready message
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'animationReady',
            animation: 'chemistry-definition'
          }));
        }
      });
    </script>
  </body>
  </html>
`
};

---- File Content End ----


=== File: waterFormation.ts ===
Path: library\chapter1\waterFormation.ts
---- File Content Start ----
import { AnimationConfig } from '../../types';
import { AnimationFactory } from '../../core/AnimationFactory';
import { baseStyles } from '../../styles/baseStyles';

export const createHydrogenOxygenWater = (): AnimationConfig => {
  return {
    height: 500,
    autoPlay: false,
    loop: false,
    features: {
      temperature: true,
      beforeAfter: true,
      speed: true
    },
    html: `
      ${baseStyles}
      <div id="animation-container" class="chemistry-animation">
        <!-- Container for dynamic content -->
      </div>
      <script>
        // Initialize animation
        const animation = new ReactionAnimation({
          containerId: 'animation-container',
          reaction: {
            reactants: [
              { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
              { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
            ],
            products: [
              { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
            ],
            activationEnergy: 100,
            effects: ['explosion', 'flame']
          }
        });

        // Handle controls from React Native
        window.addEventListener('message', (event) => {
          const data = JSON.parse(event.data);
          if (data.type === 'controlUpdate') {
            animation.handleControl(data.control, data.value);
          }
        });

        // Auto-start if configured
        if (window.animationState?.isPlaying) {
          animation.play();
        }
      </script>
    `
  };
};

---- File Content End ----


=== File: SafetyService.ts ===
Path: services\SafetyService.ts
---- File Content Start ----
import { SafetyConstraints, SafetyStatus } from '../types';

export class SafetyService {
  static checkSafety(
    constraints: SafetyConstraints | undefined,
    currentState: Record<string, any>
  ): SafetyStatus {
    const result: SafetyStatus = {
      isSafe: true,
      warnings: [],
      requiredEquipment: constraints?.requiredEquipment || []
    };

    if (!constraints) return result;

    // Temperature checks
    if (constraints.maxTemperature && currentState.temperature > constraints.maxTemperature) {
      result.isSafe = false;
      result.warnings.push(`Temperature exceeds safe limit (${constraints.maxTemperature}°C)`);
    }

    // Pressure checks
    if (constraints.maxPressure && currentState.pressure > constraints.maxPressure) {
      result.isSafe = false;
      result.warnings.push(`Pressure exceeds safe limit (${constraints.maxPressure}atm)`);
    }

    // Concentration checks
    if (constraints.maxConcentration && currentState.concentration > constraints.maxConcentration) {
      result.isSafe = false;
      result.warnings.push(`Concentration exceeds safe limit (${constraints.maxConcentration}M)`);
    }

    // Hazardous reaction checks
    if (
      constraints.hazardousReactions &&
      constraints.hazardousReactions.includes(currentState.reactionType)
    ) {
      result.warnings.push(`Hazardous reaction: ${currentState.reactionType}`);
    }

    return result;
  }
}

---- File Content End ----


=== File: baseStyles.ts ===
Path: styles\baseStyles.ts
---- File Content Start ----
export const baseStyles = `
<style>
  /* Base animation container */
  .chemistry-animation {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background: linear-gradient(180deg, #0f0f23 0%, #1a1a3e 100%);
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  }

  /* Atom styles */
  .atom {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(255,255,255,0.3);
  }

  .atom:hover {
    transform: scale(1.1);
    z-index: 10;
  }

  /* Bond styles */
  .bond {
    position: absolute;
    background: #4ecdc4;
    transform-origin: left center;
    transition: all 0.5s ease;
  }

  .bond-single { height: 3px; }
  .bond-double { height: 6px; box-shadow: 0 3px 0 #4ecdc4; }
  .bond-triple { height: 9px; box-shadow: 0 3px 0 #4ecdc4, 0 6px 0 #4ecdc4; }
  .bond-ionic {
    height: 3px;
    background: repeating-linear-gradient(
      90deg,
      #4ecdc4 0,
      #4ecdc4 5px,
      transparent 5px,
      transparent 10px
    );
  }

  /* Include other shared styles... */
</style>
`;

---- File Content End ----


=== File: DissolutionTemplate.ts ===
Path: templates\DissolutionTemplate.ts
---- File Content Start ----
// src/data/animations/templates/DissolutionTemplate.ts
export class DissolutionAnimationTemplate extends ChemistryAnimationEngine {
  private soluteType: string;
  private solventType: string;
  private saturationPoint: number;
  private currentAmount: number = 0;
  private soluteParticles: HTMLElement[] = [];
  private solventMolecules: HTMLElement[] = [];
  private dissolvedParticles: HTMLElement[] = [];

  constructor(
    containerId: string,
    soluteType: string = 'NaCl',
    solventType: string = 'H2O',
    saturationPoint: number = 36 // g per 100g water
  ) {
    super(containerId);
    this.soluteType = soluteType;
    this.solventType = solventType;
    this.saturationPoint = saturationPoint;
    this.setupContainer();
    this.createSolvent();
  }

  private setupContainer(): void {
    // Create beaker visual
    const beaker = document.createElement('div');
    beaker.className = 'beaker';
    beaker.style.cssText = `
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 400px;
      border: 3px solid rgba(255,255,255,0.3);
      border-bottom: 5px solid rgba(255,255,255,0.4);
      border-radius: 0 0 20px 20px;
      background: linear-gradient(
        180deg,
        transparent 0%,
        rgba(66, 165, 245, 0.1) 30%,
        rgba(66, 165, 245, 0.2) 100%
      );
    `;
    this.container.appendChild(beaker);

    // Create measurement marks
    for (let i = 1; i <= 4; i++) {
      const mark = document.createElement('div');
      mark.style.cssText = `
        position: absolute;
        left: -20px;
        bottom: ${i * 80}px;
        width: 10px;
        height: 2px;
        background: rgba(255,255,255,0.5);
      `;
      beaker.appendChild(mark);

      const label = document.createElement('div');
      label.textContent = `${i * 25}mL`;
      label.style.cssText = `
        position: absolute;
        left: -60px;
        bottom: ${i * 80 - 10}px;
        color: rgba(255,255,255,0.7);
        font-size: 12px;
      `;
      beaker.appendChild(label);
    }

    // Saturation indicator
    const saturationIndicator = document.createElement('div');
    saturationIndicator.className = 'saturation-indicator';
    saturationIndicator.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      color: white;
    `;
    saturationIndicator.innerHTML = `
      <h4>Saturation Level</h4>
      <div class="saturation-bar" style="
        width: 200px;
        height: 20px;
        background: rgba(255,255,255,0.2);
        border-radius: 10px;
        overflow: hidden;
        margin-top: 10px;
      ">
        <div class="saturation-fill" id="saturation-fill" style="
          width: 0%;
          height: 100%;
          background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
          transition: width 0.5s ease;
        "></div>
      </div>
      <p id="saturation-text" style="margin-top: 10px; font-size: 14px;">
        0g / ${this.saturationPoint}g
      </p>
    `;
    this.container.appendChild(saturationIndicator);
  }

  private createSolvent(): void {
    // Create water molecules
    const beakerBounds = {
      left: this.container.offsetWidth / 2 - 150,
      right: this.container.offsetWidth / 2 + 150,
      top: this.container.offsetHeight - 350,
      bottom: this.container.offsetHeight - 50
    };

    for (let i = 0; i < 30; i++) {
      const water = this.createWaterMolecule(
        Math.random() * (beakerBounds.right - beakerBounds.left) + beakerBounds.left,
        Math.random() * (beakerBounds.bottom - beakerBounds.top) + beakerBounds.top
      );
      this.solventMolecules.push(water);
      this.addWaterMotion(water, beakerBounds);
    }
  }

  private createWaterMolecule(x: number, y: number): HTMLElement {
    const water = document.createElement('div');
    water.className = 'water-molecule';
    water.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 40px;
      height: 35px;
      opacity: 0.7;
    `;

    water.innerHTML = `
      <svg viewBox="0 0 40 35" xmlns="http://www.w3.org/2000/svg">
        <circle cx="20" cy="15" r="8" fill="#FF6B6B" opacity="0.8"/>
        <circle cx="12" cy="25" r="5" fill="#FFFFFF" opacity="0.8"/>
        <circle cx="28" cy="25" r="5" fill="#FFFFFF" opacity="0.8"/>
        <line x1="20" y1="15" x2="12" y2="25" stroke="#4ECDC4" stroke-width="2" opacity="0.6"/>
        <line x1="20" y1="15" x2="28" y2="25" stroke="#4ECDC4" stroke-width="2" opacity="0.6"/>
      </svg>
    `;

    this.container.appendChild(water);
    return water;
  }

  private addWaterMotion(water: HTMLElement, bounds: any): void {
    let angle = Math.random() * Math.PI * 2;
    let speed = 0.5 + Math.random() * 0.5;

    const animate = () => {
      angle += 0.02;
      const x = parseFloat(water.style.left) + Math.cos(angle) * speed;
      const y = parseFloat(water.style.top) + Math.sin(angle) * speed * 0.5;

      // Keep within bounds
      if (x < bounds.left || x > bounds.right - 40) speed *= -1;
      if (y < bounds.top || y > bounds.bottom - 35) speed *= -1;

      water.style.left = `${x}px`;
      water.style.top = `${y}px`;

      requestAnimationFrame(animate);
    };

    animate();
  }

  public async addSolute(amount: number = 5): Promise<void> {
    if (this.currentAmount >= this.saturationPoint) {
      await this.showSaturationMessage();
      return;
    }

    const actualAmount = Math.min(amount, this.saturationPoint - this.currentAmount);
    this.currentAmount += actualAmount;

    // Update saturation indicator
    this.updateSaturationIndicator();

    // Create solute crystal
    const crystal = this.createSoluteCrystal();
    await this.dropCrystal(crystal);

    // Dissolve or settle based on saturation
    if (this.currentAmount <= this.saturationPoint) {
      await this.dissolveCrystal(crystal);
    } else {
      await this.settleCrystal(crystal);
    }
  }

  private createSoluteCrystal(): HTMLElement {
    const crystal = document.createElement('div');
    crystal.className = 'solute-crystal';

    if (this.soluteType === 'NaCl') {
      // Salt crystal - cubic structure
      crystal.style.cssText = `
        position: absolute;
        left: ${this.container.offsetWidth / 2 - 20}px;
        top: 50px;
        width: 40px;
        height: 40px;
        background: linear-gradient(45deg, #FFFFFF 25%, #E0E0E0 50%, #FFFFFF 75%);
        border: 1px solid #CCCCCC;
        transform: rotate(45deg);
      `;
    } else if (this.soluteType === 'sugar') {
      // Sugar crystal - more irregular
      crystal.style.cssText = `
        position: absolute;
        left: ${this.container.offsetWidth / 2 - 20}px;
        top: 50px;
        width: 35px;
        height: 35px;
        background: radial-gradient(circle at 30% 30%, #FFFFFF, #F5F5DC);
        border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
      `;
    }

    this.container.appendChild(crystal);
    return crystal;
  }

  private async dropCrystal(crystal: HTMLElement): Promise<void> {
    const targetY = this.container.offsetHeight - 250;
    await this.animateMove(crystal, parseFloat(crystal.style.left), targetY, 1000);
  }

  private async dissolveCrystal(crystal: HTMLElement): Promise<void> {
    // Create ion/molecule particles
    const particles = this.soluteType === 'NaCl' ?
      await this.createIons(crystal) :
      await this.createMolecules(crystal);

    // Fade out crystal
    await this.animateFade(crystal, 0, 500);
    crystal.remove();

    // Disperse particles
    await this.disperseParticles(particles);
  }

  private async createIons(crystal: HTMLElement): Promise<HTMLElement[]> {
    const ions: HTMLElement[] = [];
    const x = parseFloat(crystal.style.left);
    const y = parseFloat(crystal.style.top);

    // Create Na+ and Cl- ions
    for (let i = 0; i < 4; i++) {
      const isNa = i % 2 === 0;
      const ion = document.createElement('div');
      ion.className = isNa ? 'na-ion' : 'cl-ion';
      ion.style.cssText = `
        position: absolute;
        left: ${x + 20}px;
        top: ${y + 20}px;
        width: ${isNa ? 25 : 30}px;
        height: ${isNa ? 25 : 30}px;
        border-radius: 50%;
        background: ${isNa ? '#FFD700' : '#00FF00'};
        color: ${isNa ? '#000' : '#FFF'};
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        opacity: 0;
        transform: scale(0);
      `;
      ion.textContent = isNa ? 'Na+' : 'Cl-';

      this.container.appendChild(ion);
      ions.push(ion);
      this.dissolvedParticles.push(ion);

      // Animate appearance
      setTimeout(() => {
        ion.style.transition = 'all 0.5s ease';
        ion.style.opacity = '1';
        ion.style.transform = 'scale(1)';
      }, i * 100);
    }

    return ions;
  }

  private async disperseParticles(particles: HTMLElement[]): Promise<void> {
    const beakerBounds = {
      left: this.container.offsetWidth / 2 - 130,
      right: this.container.offsetWidth / 2 + 130,
      top: this.container.offsetHeight - 350,
      bottom: this.container.offsetHeight - 80
    };

    particles.forEach((particle, index) => {
      setTimeout(() => {
        const targetX = Math.random() * (beakerBounds.right - beakerBounds.left) + beakerBounds.left;
        const targetY = Math.random() * (beakerBounds.bottom - beakerBounds.top) + beakerBounds.top;

        this.animateMove(particle, targetX, targetY, 1500);

        // Add floating motion
        this.addParticleMotion(particle, beakerBounds);
      }, index * 200);
    });
  }

  private addParticleMotion(particle: HTMLElement, bounds: any): void {
    let angle = Math.random() * Math.PI * 2;

    const animate = () => {
      angle += 0.03;
      const baseX = parseFloat(particle.dataset.targetX || particle.style.left);
      const baseY = parseFloat(particle.dataset.targetY || particle.style.top);

      const offsetX = Math.sin(angle) * 15;
      const offsetY = Math.cos(angle * 1.5) * 10;

      particle.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1)`;

      requestAnimationFrame(animate);
    };

    setTimeout(animate, 2000);
  }

  private async settleCrystal(crystal: HTMLElement): Promise<void> {
    // Crystal settles at bottom as undissolved
    const bottomY = this.container.offsetHeight - 60;
    await this.animateMove(
      crystal,
      parseFloat(crystal.style.left) + (Math.random() - 0.5) * 50,
      bottomY,
      1000
    );

    this.soluteParticles.push(crystal);
  }

  private updateSaturationIndicator(): void {
    const percentage = (this.currentAmount / this.saturationPoint) * 100;
    const fill = document.getElementById('saturation-fill');
    const text = document.getElementById('saturation-text');

    if (fill) fill.style.width = `${Math.min(percentage, 100)}%`;
    if (text) text.textContent = `${this.currentAmount}g / ${this.saturationPoint}g`;
  }

  private async showSaturationMessage(): Promise<void> {
    const message = document.createElement('div');
    message.className = 'saturation-message';
    message.textContent = 'Solution is saturated! No more solute can dissolve.';
    message.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(244, 67, 54, 0.9);
      color: white;
      padding: 20px 30px;
      border-radius: 10px;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
    `;

    this.container.appendChild(message);

    setTimeout(() => message.style.opacity = '1', 100);
    setTimeout(() => {
      message.style.opacity = '0';
      setTimeout(() => message.remove(), 500);
    }, 3000);
  }

  public async play(): Promise<void> {
    // Demonstrate dissolution process
    for (let i = 0; i < 8; i++) {
      await this.addSolute(5);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }

  public reset(): void {
    // Clear all particles
    this.dissolvedParticles.forEach(p => p.remove());
    this.soluteParticles.forEach(p => p.remove());
    this.dissolvedParticles = [];
    this.soluteParticles = [];
    this.currentAmount = 0;
    this.updateSaturationIndicator();
  }

  protected showAtomProperties(atom: HTMLElement): void {
    // Show properties of clicked particle
  }
}

---- File Content End ----


=== File: ReactionTemplate.ts ===
Path: templates\ReactionTemplate.ts
---- File Content Start ----
// src/data/animations/templates/ReactionTemplate.ts
export interface ReactionConfig {
  reactants: Array<{
    formula: string;
    count: number;
    position: { x: number; y: number };
  }>;
  products: Array<{
    formula: string;
    count: number;
    position: { x: number; y: number };
  }>;
  activationEnergy?: number;
  reactionType: 'combustion' | 'synthesis' | 'decomposition' | 'displacement';
  effects?: Array<'flame' | 'explosion' | 'bubble' | 'spark'>;
}

export class ReactionAnimationTemplate extends ChemistryAnimationEngine {
  private config: ReactionConfig;
  private equationDisplay: HTMLElement;
  private infoPanel: HTMLElement;

  constructor(containerId: string, config: ReactionConfig) {
    super(containerId);
    this.config = config;
    this.setupUI();
    this.createInitialState();
  }

  private setupUI(): void {
    // Create equation display
    this.equationDisplay = document.createElement('div');
    this.equationDisplay.className = 'equation-display';
    this.equationDisplay.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px 25px;
      border-radius: 10px;
      color: white;
      font-size: 20px;
      font-family: 'Courier New', monospace;
    `;

    // Build equation string
    const reactantStrings = this.config.reactants.map(r =>
      r.count > 1 ? `${r.count}${r.formula}` : r.formula
    );
    const productStrings = this.config.products.map(p =>
      p.count > 1 ? `${p.count}${p.formula}` : p.formula
    );

    this.equationDisplay.innerHTML = `
      <span class="reactants">${reactantStrings.join(' + ')}</span>
      <span class="arrow"> → </span>
      <span class="products">${productStrings.join(' + ')}</span>
    `;

    this.container.appendChild(this.equationDisplay);

    // Create info panel
    this.infoPanel = document.createElement('div');
    this.infoPanel.className = 'info-panel';
    this.infoPanel.style.cssText = `
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      color: white;
      max-width: 250px;
    `;
    this.container.appendChild(this.infoPanel);
  }

  private createInitialState(): void {
    // Create reactant molecules
    this.config.reactants.forEach((reactant, index) => {
      for (let i = 0; i < reactant.count; i++) {
        const id = `reactant-${index}-${i}`;
        const offsetX = i * 100;
        const offsetY = index * 100;

        this.createMolecule(
          reactant.formula,
          reactant.position.x + offsetX,
          reactant.position.y + offsetY,
          id
        );
      }
    });
  }

  public async play(): Promise<void> {
    this.animationState = 'playing';

    // Show activation energy requirement
    if (this.config.activationEnergy) {
      await this.showActivationEnergy();
    }

    // Move reactants to center
    await this.moveReactantsToCenter();

    // Show reaction effects
    if (this.config.effects) {
      await this.showReactionEffects();
    }

    // Transform to products
    await this.transformToProducts();

    this.animationState = 'complete';
  }

  private async showActivationEnergy(): Promise<void> {
    const button = document.createElement('button');
    button.className = 'activation-button';
    button.textContent = '🔥 Provide Activation Energy';
    button.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%);
      border: none;
      color: white;
      padding: 15px 30px;
      border-radius: 30px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255,107,107,0.3);
    `;

    this.container.appendChild(button);

    return new Promise(resolve => {
      button.addEventListener('click', () => {
        button.remove();
        resolve();
      });
    });
  }

  private async moveReactantsToCenter(): Promise<void> {
    const centerX = this.container.offsetWidth / 2;
    const centerY = this.container.offsetHeight / 2;

    const movePromises: Promise<void>[] = [];

    this.molecules.forEach((molecule) => {
      movePromises.push(
        this.animateMove(molecule, centerX - 50, centerY - 50, 1500)
      );
    });

    await Promise.all(movePromises);
  }

  private async showReactionEffects(): Promise<void> {
    for (const effect of this.config.effects!) {
      switch (effect) {
        case 'explosion':
          await this.showExplosion();
          break;
        case 'flame':
          await this.showFlame();
          break;
        case 'spark':
          await this.showSpark();
          break;
        case 'bubble':
          await this.showBubbles();
          break;
      }
    }
  }

  private async showExplosion(): Promise<void> {
    const explosion = document.createElement('div');
    explosion.className = 'explosion-effect';
    explosion.style.cssText = `
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      background: radial-gradient(circle,
        rgba(255,255,0,0.8) 0%,
        rgba(255,140,0,0.6) 40%,
        transparent 70%
      );
      border-radius: 50%;
      opacity: 0;
    `;

    this.container.appendChild(explosion);

    // Animate explosion
    await this.animateScale(explosion, 5, 600);
    await this.animateFade(explosion, 0, 400);

    explosion.remove();
  }

  private async transformToProducts(): Promise<void> {
    // Fade out reactants
    const fadePromises: Promise<void>[] = [];
    this.molecules.forEach(molecule => {
      fadePromises.push(this.animateFade(molecule, 0, 500));
    });
    await Promise.all(fadePromises);

    // Remove reactant molecules
    this.molecules.forEach(molecule => molecule.remove());
    this.molecules.clear();

    // Create product molecules
    this.config.products.forEach((product, index) => {
      for (let i = 0; i < product.count; i++) {
        const id = `product-${index}-${i}`;
        const offsetX = i * 120;
        const offsetY = index * 100;

        const molecule = this.createMolecule(
          product.formula,
          product.position.x + offsetX,
          product.position.y + offsetY,
          id
        );

        // Start invisible
        molecule.style.opacity = '0';
        molecule.style.transform = 'scale(0)';

        // Animate in
        setTimeout(() => {
          this.animateScale(molecule, 1, 500);
          this.animateFade(molecule, 1, 500);
        }, i * 200);
      }
    });
  }

  public reset(): void {
    // Clear all elements
    this.atoms.forEach(atom => atom.remove());
    this.bonds.forEach(bond => bond.remove());
    this.molecules.forEach(molecule => molecule.remove());

    this.atoms.clear();
    this.bonds.clear();
    this.molecules.clear();

    // Reset state
    this.animationState = 'idle';

    // Recreate initial state
    this.createInitialState();
  }

  protected showAtomProperties(atom: HTMLElement): void {
    const element = atom.dataset.element!;
    const elementData = ChemicalElement.get(element);

    this.infoPanel.innerHTML = `
      <h3>${elementData.name}</h3>
      ${elementData.properties.map(prop => `<p>• ${prop}</p>`).join('')}
    `;
  }

  // Additional effect methods
  private async showFlame(): Promise<void> {
    // Implementation for flame effect
  }

  private async showSpark(): Promise<void> {
    // Implementation for spark effect
  }

  private async showBubbles(): Promise<void> {
    // Implementation for bubble effect
  }
}

---- File Content End ----


=== File: StateChangeTemplate.ts ===
Path: templates\StateChangeTemplate.ts
---- File Content Start ----
// src/data/animations/templates/StateChangeTemplate.ts
export class StateChangeAnimationTemplate extends ChemistryAnimationEngine {
  private particles: HTMLElement[] = [];
  private currentState: 'solid' | 'liquid' | 'gas';
  private substance: string;
  private particleCount: number = 50;

  constructor(
    containerId: string,
    substance: string,
    initialState: 'solid' | 'liquid' | 'gas' = 'solid'
  ) {
    super(containerId);
    this.substance = substance;
    this.currentState = initialState;
    this.createParticles();
    this.arrangeParticles(initialState);
  }

  private createParticles(): void {
    const element = this.substance; // Assuming single element for simplicity
    const elementData = ChemicalElement.get(element);

    for (let i = 0; i < this.particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'state-particle';
      particle.style.cssText = `
        position: absolute;
        width: 30px;
        height: 30px;
        background: radial-gradient(circle at 30% 30%,
          ${this.lightenColor(elementData.color)},
          ${elementData.color}
        );
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: ${this.getTextColor(elementData.color)};
        transition: all 0.5s ease;
      `;
      particle.textContent = element;

      this.particles.push(particle);
      this.container.appendChild(particle);
    }
  }

  private arrangeParticles(state: 'solid' | 'liquid' | 'gas'): void {
    const containerWidth = this.container.offsetWidth;
    const containerHeight = this.container.offsetHeight;

    this.particles.forEach((particle, index) => {
      let x: number, y: number;

      switch (state) {
        case 'solid':
          // Grid arrangement
          const cols = Math.ceil(Math.sqrt(this.particleCount));
          const row = Math.floor(index / cols);
          const col = index % cols;
          x = (containerWidth / cols) * col + 50;
          y = (containerHeight / cols) * row + 50;

          // Add small vibration
          this.addVibration(particle, 2);
          break;

        case 'liquid':
          // Loose arrangement with flow
          x = Math.random() * (containerWidth - 100) + 50;
          y = containerHeight - 100 - (Math.random() * 200);

          // Add flowing motion
          this.addFlowingMotion(particle);
          break;

        case 'gas':
          // Random positions
          x = Math.random() * (containerWidth - 50);
          y = Math.random() * (containerHeight - 50);

          // Add rapid random motion
          this.addRandomMotion(particle);
          break;
      }

      particle.style.left = `${x}px`;
      particle.style.top = `${y}px`;
    });
  }

  private addVibration(particle: HTMLElement, amplitude: number): void {
    const baseX = parseFloat(particle.style.left);
    const baseY = parseFloat(particle.style.top);

    const animate = () => {
      if (this.currentState === 'solid') {
        const offsetX = (Math.random() - 0.5) * amplitude;
        const offsetY = (Math.random() - 0.5) * amplitude;
        particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        requestAnimationFrame(animate);
      }
    };

    animate();
  }

  private addFlowingMotion(particle: HTMLElement): void {
    let angle = Math.random() * Math.PI * 2;

    const animate = () => {
      if (this.currentState === 'liquid') {
        angle += 0.02;
        const offsetX = Math.sin(angle) * 20;
        const offsetY = Math.cos(angle * 0.5) * 10;
        particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        requestAnimationFrame(animate);
      }
    };

    animate();
  }

  private addRandomMotion(particle: HTMLElement): void {
    let velocityX = (Math.random() - 0.5) * 4;
    let velocityY = (Math.random() - 0.5) * 4;

    const animate = () => {
      if (this.currentState === 'gas') {
        let x = parseFloat(particle.style.left);
        let y = parseFloat(particle.style.top);

        x += velocityX;
        y += velocityY;

        // Bounce off walls
        // Bounce off walls
       if (x < 0 || x > this.container.offsetWidth - 30) {
         velocityX *= -1;
       }
       if (y < 0 || y > this.container.offsetHeight - 30) {
         velocityY *= -1;
       }

       particle.style.left = `${x}px`;
       particle.style.top = `${y}px`;

       requestAnimationFrame(animate);
     }
   };

   animate();
 }

 public async transitionTo(newState: 'solid' | 'liquid' | 'gas'): Promise<void> {
   this.animationState = 'playing';
   this.currentState = newState;

   // Show transition effects
   await this.showTransitionEffect(this.currentState, newState);

   // Rearrange particles
   this.arrangeParticles(newState);

   this.animationState = 'idle';
 }

 private async showTransitionEffect(
   fromState: 'solid' | 'liquid' | 'gas',
   toState: 'solid' | 'liquid' | 'gas'
 ): Promise<void> {
   const effectMap = {
     'solid-liquid': 'melting',
     'liquid-gas': 'boiling',
     'gas-liquid': 'condensation',
     'liquid-solid': 'freezing',
     'solid-gas': 'sublimation',
     'gas-solid': 'deposition'
   };

   const transitionKey = `${fromState}-${toState}`;
   const effect = effectMap[transitionKey];

   if (effect) {
     await this.displayTransitionLabel(effect);
   }
 }

 private async displayTransitionLabel(label: string): Promise<void> {
   const labelElement = document.createElement('div');
   labelElement.className = 'transition-label';
   labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
   labelElement.style.cssText = `
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background: rgba(0,0,0,0.8);
     color: white;
     padding: 20px 40px;
     border-radius: 10px;
     font-size: 24px;
     font-weight: bold;
     opacity: 0;
     transition: opacity 0.5s ease;
   `;

   this.container.appendChild(labelElement);

   // Animate in
   setTimeout(() => labelElement.style.opacity = '1', 100);

   // Hold
   await new Promise(resolve => setTimeout(resolve, 2000));

   // Animate out
   labelElement.style.opacity = '0';
   setTimeout(() => labelElement.remove(), 500);
 }

 public async play(): Promise<void> {
   // Cycle through states
   await this.transitionTo('liquid');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('gas');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('liquid');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('solid');
 }

 public reset(): void {
   this.currentState = 'solid';
   this.arrangeParticles('solid');
 }

 protected showAtomProperties(atom: HTMLElement): void {
   // Not implemented for state changes
 }
}

---- File Content End ----


---- File Content End ----


=== File: types.ts ===
Path: data\animations\types.ts
---- File Content Start ----
// src/data/animations/types.ts - Updated
export type AnimationTemplateType = 'reaction' | 'state-change' | 'dissolution' | 'bonding' | 'equilibrium' | 'definition';

export type AnimationType =
  | 'hydrogen-oxygen-water'
  | 'states-of-matter'
  | 'phase-changes'
  | 'carbon-allotropes'
  | 'solutions-colloids'
  | 'temperature-solubility'
  | 'chemistry-definition'
  | 'chemistry-definition-interactive'; // NEW

export interface AnimationConfig {
  html: string;
  height: number;
  autoPlay: boolean;
  loop: boolean;
  backgroundColor?: string;
  features?: AnimationFeatures;
  safety?: SafetyConstraints;
  template?: {
    type: AnimationTemplateType;
    config: any;
  };
}

export interface AnimationFeatures {
  temperature?: boolean;      // Enable temperature slider
  zoom?: boolean;             // Enable zoom controls
  speed?: boolean;            // Enable speed controls
  beforeAfter?: boolean;      // Enable before/after toggle
  rotation3D?: boolean;       // Enable 3D rotation
  particleCount?: boolean;    // Enable particle count control
  pressure?: boolean;         // Enable pressure control
  concentration?: boolean;    // Enable concentration slider
}

export interface AnimationEngine {
  play(): Promise<void>;
  pause(): void;
  reset(): void;
  setSpeed(speed: number): void;
  setTemperature?(temp: number): void;
}

export interface ChemicalEntity {
  element: string;
  position: { x: number; y: number; z?: number };
  state?: 'solid' | 'liquid' | 'gas' | 'aqueous';
}

export interface ReactionConfig {
  reactants: ChemicalEntity[];
  products: ChemicalEntity[];
  conditions?: {
    temperature?: number;
    pressure?: number;
    catalyst?: string;
  };
}

export interface SafetyConstraints {
  maxTemperature?: number;
  maxPressure?: number;
  maxConcentration?: number;
  minDistance?: number;
  requiredEquipment?: string[];
  hazardousReactions?: string[];
}

export interface SafetyStatus {
  isSafe: boolean;
  warnings: string[];
  requiredEquipment: string[];
}

---- File Content End ----


=== File: AnimationEngine.ts ===
Path: data\animations\core\AnimationEngine.ts
---- File Content Start ----
// src/data/animations/core/AnimationEngine.ts
export abstract class ChemistryAnimationEngine {
  protected container: HTMLElement;
  protected atoms: Map<string, HTMLElement> = new Map();
  protected bonds: Map<string, HTMLElement> = new Map();
  protected molecules: Map<string, HTMLElement> = new Map();
  protected animationState: 'idle' | 'playing' | 'complete' = 'idle';

  constructor(containerId: string) {
    this.container = document.getElementById(containerId)!;
  }

  // Create atom with standardized styling
  protected createAtom(
    element: string,
    x: number,
    y: number,
    id: string
  ): HTMLElement {
    const elementData = ChemicalElement.get(element);
    const atom = document.createElement('div');

    atom.className = 'atom';
    atom.id = id;
    atom.style.cssText = `
      position: absolute;
      width: ${elementData.size}px;
      height: ${elementData.size}px;
      left: ${x}px;
      top: ${y}px;
      background: radial-gradient(circle at 30% 30%,
        ${this.lightenColor(elementData.color)},
        ${elementData.color}
      );
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: ${this.getTextColor(elementData.color)};
      font-size: ${elementData.size * 0.4}px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    `;

    atom.textContent = element;
    atom.dataset.element = element;
    atom.dataset.x = x.toString();
    atom.dataset.y = y.toString();

    this.atoms.set(id, atom);
    this.container.appendChild(atom);

    // Add interactions
    this.addAtomInteractions(atom);

    return atom;
  }

  // Create bond between atoms
  protected createBond(
    atom1Id: string,
    atom2Id: string,
    type: 'single' | 'double' | 'triple' | 'ionic',
    id: string
  ): HTMLElement {
    const atom1 = this.atoms.get(atom1Id)!;
    const atom2 = this.atoms.get(atom2Id)!;

    const bond = document.createElement('div');
    bond.className = `bond bond-${type}`;
    bond.id = id;

    const styles: Record<string, string> = {
      single: 'height: 3px; background: #4ecdc4;',
      double: 'height: 6px; background: #4ecdc4; box-shadow: 0 3px 0 #4ecdc4;',
      triple: 'height: 9px; background: #4ecdc4; box-shadow: 0 3px 0 #4ecdc4, 0 6px 0 #4ecdc4;',
      ionic: 'height: 3px; background: repeating-linear-gradient(90deg, #4ecdc4 0, #4ecdc4 5px, transparent 5px, transparent 10px);'
    };

    bond.style.cssText = `
      position: absolute;
      ${styles[type]}
      transform-origin: left center;
      transition: all 0.5s ease;
    `;

    this.updateBondPosition(bond, atom1, atom2);
    this.bonds.set(id, bond);
    this.container.appendChild(bond);

    return bond;
  }

  // Update bond position based on atom positions
  protected updateBondPosition(
    bond: HTMLElement,
    atom1: HTMLElement,
    atom2: HTMLElement
  ): void {
    const rect1 = atom1.getBoundingClientRect();
    const rect2 = atom2.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();

    const x1 = rect1.left - containerRect.left + rect1.width / 2;
    const y1 = rect1.top - containerRect.top + rect1.height / 2;
    const x2 = rect2.left - containerRect.left + rect2.width / 2;
    const y2 = rect2.top - containerRect.top + rect2.height / 2;

    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

    bond.style.width = `${length}px`;
    bond.style.left = `${x1}px`;
    bond.style.top = `${y1}px`;
    bond.style.transform = `rotate(${angle}deg)`;
  }

  // Create complete molecule from template
  protected createMolecule(
    formula: string,
    x: number,
    y: number,
    id: string
  ): HTMLElement {
    const template = MoleculeTemplates.get(formula);
    const molecule = document.createElement('div');
    molecule.className = 'molecule';
    molecule.id = id;
    molecule.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
    `;

    // Create atoms within molecule
    template.atoms.forEach((atomData, index) => {
      const atomId = `${id}-atom-${index}`;
      const atom = this.createAtom(
        atomData.element,
        atomData.position.x,
        atomData.position.y,
        atomId
      );
      molecule.appendChild(atom);
    });

    // Create bonds
    template.bonds.forEach((bondData, index) => {
      const bondId = `${id}-bond-${index}`;
      const atom1Id = `${id}-atom-${bondData.from}`;
      const atom2Id = `${id}-atom-${bondData.to}`;

      setTimeout(() => {
        this.createBond(atom1Id, atom2Id, bondData.type, bondId);
      }, 100);
    });

    this.molecules.set(id, molecule);
    this.container.appendChild(molecule);

    return molecule;
  }

  // Animation utilities
  protected async animateMove(
    element: HTMLElement,
    x: number,
    y: number,
    duration: number = 1000
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `all ${duration}ms ease-in-out`;
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;

      setTimeout(resolve, duration);
    });
  }

  protected async animateScale(
    element: HTMLElement,
    scale: number,
    duration: number = 500
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `transform ${duration}ms ease-in-out`;
      element.style.transform = `scale(${scale})`;

      setTimeout(resolve, duration);
    });
  }

  protected async animateFade(
    element: HTMLElement,
    opacity: number,
    duration: number = 500
  ): Promise<void> {
    return new Promise(resolve => {
      element.style.transition = `opacity ${duration}ms ease-in-out`;
      element.style.opacity = opacity.toString();

      setTimeout(resolve, duration);
    });
  }

  // Helper methods
  private lightenColor(color: string): string {
    // Simple color lightening
    const num = parseInt(color.slice(1), 16);
    const amt = 40;
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return `#${(0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255))
      .toString(16).slice(1)}`;
  }

  private getTextColor(bgColor: string): string {
    // Determine if text should be light or dark
    const color = bgColor.slice(1);
    const r = parseInt(color.substr(0, 2), 16);
    const g = parseInt(color.substr(2, 2), 16);
    const b = parseInt(color.substr(4, 2), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 155 ? '#000000' : '#FFFFFF';
  }

  private addAtomInteractions(atom: HTMLElement): void {
    atom.addEventListener('click', () => this.showAtomProperties(atom));
    atom.addEventListener('mouseenter', () => {
      if (this.animationState !== 'playing') {
        atom.style.transform = 'scale(1.1)';
        atom.style.zIndex = '10';
      }
    });
    atom.addEventListener('mouseleave', () => {
      if (this.animationState !== 'playing') {
        atom.style.transform = 'scale(1)';
        atom.style.zIndex = '1';
      }
    });
  }

  protected abstract showAtomProperties(atom: HTMLElement): void;
  public abstract play(): Promise<void>;
  public abstract reset(): void;
}

---- File Content End ----


=== File: ChemicalElements.ts ===
Path: data\animations\core\ChemicalElements.ts
---- File Content Start ----
// src/data/animations/core/ChemicalElements.ts
export class ChemicalElement {
  static readonly ELEMENTS = {
    H: {
      name: 'Hydrogen',
      symbol: 'H',
      atomicNumber: 1,
      color: '#FFFFFF',
      size: 40,
      mass: 1.008,
      valence: 1,
      properties: [
        'Lightest element',
        'Highly flammable',
        'Colorless gas',
        'Forms H₂ molecules',
        'Explosive with oxygen'
      ]
    },
    O: {
      name: 'Oxygen',
      symbol: 'O',
      atomicNumber: 8,
      color: '#FF6B6B',
      size: 60,
      mass: 15.999,
      valence: 2,
      properties: [
        'Supports combustion',
        'Colorless gas',
        'Forms O₂ molecules',
        '21% of air',
        'Essential for life'
      ]
    },
    C: {
      name: 'Carbon',
      symbol: 'C',
      atomicNumber: 6,
      color: '#333333',
      size: 55,
      mass: 12.011,
      valence: 4,
      properties: [
        'Forms 4 bonds',
        'Basis of organic chemistry',
        'Multiple allotropes',
        'Black solid (graphite)',
        'Forms chains and rings'
      ]
    },
    N: {
      name: 'Nitrogen',
      symbol: 'N',
      atomicNumber: 7,
      color: '#0066CC',
      size: 52,
      mass: 14.007,
      valence: 3,
      properties: [
        'Inert gas',
        '78% of air',
        'Forms N₂ molecules',
        'Triple bond in N₂',
        'Essential for proteins'
      ]
    },
    Na: {
      name: 'Sodium',
      symbol: 'Na',
      atomicNumber: 11,
      color: '#FFD700',
      size: 65,
      mass: 22.990,
      valence: 1,
      properties: [
        'Soft metal',
        'Highly reactive',
        'Stored in oil',
        'Forms Na+ ions',
        'Explodes in water'
      ]
    },
    Cl: {
      name: 'Chlorine',
      symbol: 'Cl',
      atomicNumber: 17,
      color: '#00FF00',
      size: 62,
      mass: 35.453,
      valence: 1,
      properties: [
        'Toxic gas',
        'Green-yellow color',
        'Forms Cl₂ molecules',
        'Strong oxidizer',
        'Used in bleach'
      ]
    }
  };

  static get(symbol: string) {
    return this.ELEMENTS[symbol];
  }
}

---- File Content End ----


=== File: MoleculeTemplates.ts ===
Path: data\animations\core\MoleculeTemplates.ts
---- File Content Start ----
// src/data/animations/core/MoleculeTemplates.ts
export interface MoleculeStructure {
  atoms: Array<{
    element: string;
    position: { x: number; y: number; z?: number };
    id?: string;
  }>;
  bonds: Array<{
    from: number;
    to: number;
    type: 'single' | 'double' | 'triple' | 'ionic';
    angle?: number;
  }>;
  properties?: string[];
  state?: 'solid' | 'liquid' | 'gas' | 'aqueous';
}

export class MoleculeTemplates {
  static readonly MOLECULES: Record<string, MoleculeStructure> = {
    'H2': {
      atoms: [
        { element: 'H', position: { x: -20, y: 0 } },
        { element: 'H', position: { x: 20, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'single' }],
      state: 'gas'
    },
    'O2': {
      atoms: [
        { element: 'O', position: { x: -30, y: 0 } },
        { element: 'O', position: { x: 30, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'double' }],
      state: 'gas'
    },
    'H2O': {
      atoms: [
        { element: 'O', position: { x: 0, y: 0 } },
        { element: 'H', position: { x: -30, y: 25 }, id: 'H1' },
        { element: 'H', position: { x: 30, y: 25 }, id: 'H2' }
      ],
      bonds: [
        { from: 0, to: 1, type: 'single', angle: 104.5 },
        { from: 0, to: 2, type: 'single', angle: 104.5 }
      ],
      properties: [
        'Universal solvent',
        'Bent shape (104.5°)',
        'Polar molecule',
        'High surface tension',
        'Expands when frozen'
      ],
      state: 'liquid'
    },
    'NaCl': {
      atoms: [
        { element: 'Na', position: { x: -40, y: 0 } },
        { element: 'Cl', position: { x: 40, y: 0 } }
      ],
      bonds: [{ from: 0, to: 1, type: 'ionic' }],
      properties: [
        'Table salt',
        'Ionic compound',
        'Crystal lattice',
        'Soluble in water',
        'High melting point'
      ],
      state: 'solid'
    },
    'CO2': {
      atoms: [
        { element: 'C', position: { x: 0, y: 0 } },
        { element: 'O', position: { x: -50, y: 0 } },
        { element: 'O', position: { x: 50, y: 0 } }
      ],
      bonds: [
        { from: 0, to: 1, type: 'double' },
        { from: 0, to: 2, type: 'double' }
      ],
      properties: [
        'Linear molecule',
        'Greenhouse gas',
        'Dry ice when solid',
        'Acidic in water',
        'Fire extinguisher'
      ],
      state: 'gas'
    }
  };

  static get(formula: string): MoleculeStructure {
    return this.MOLECULES[formula];
  }
}

---- File Content End ----


=== File: TemplateLoader.ts ===
Path: data\animations\core\TemplateLoader.ts
---- File Content Start ----
// src/data/animations/core/TemplateLoader.ts
import { AnimationTemplateType } from '../types';

export class TemplateLoader {
  static getTemplateCode(templateType: AnimationTemplateType): string {
    switch (templateType) {
      case 'reaction':
        return `
          class ReactionAnimation {
            constructor(config) {
              this.config = config;
              this.container = document.getElementById('animation-container');
              this.init();
            }

            init() {
              const equation = document.createElement('div');
              equation.className = 'equation-display';
              equation.innerHTML = this.buildEquation();
              this.container.appendChild(equation);
              this.createReactants();
            }

            buildEquation() {
              const reactants = this.config.reactants.map(r =>
                r.count > 1 ? \`\${r.count}\${r.formula}\` : r.formula
              ).join(' + ');

              const products = this.config.products.map(p =>
                p.count > 1 ? \`\${p.count}\${p.formula}\` : p.formula
              ).join(' + ');

              return \`\${reactants} → \${products}\`;
            }

            createReactants() {
              console.log('Creating reactants:', this.config.reactants);
            }

            play() {
              console.log('Playing reaction animation');
            }
          }
        `;

      case 'state-change':
        return `
          class StateChangeAnimation {
            constructor(config) {
              this.config = config;
              this.container = document.getElementById('animation-container');
              this.currentState = config.initialState;
              this.init();
            }

            init() {
              this.createParticles();
              this.arrangeParticles(this.currentState);
            }

            createParticles() {
              console.log('Creating particles for', this.config.substance);
            }

            arrangeParticles(state) {
              console.log('Arranging particles in', state, 'state');
            }

            transitionTo(newState) {
              this.currentState = newState;
              this.arrangeParticles(newState);
            }
          }
        `;

      case 'definition':
  return `
    class DefinitionAnimation {
      constructor(config) {
        this.config = config;
        this.container = document.getElementById('animation-container');
        console.log('Definition animation initialized with config:', config);
      }

      play() {
        console.log('Definition animation playing');
        return Promise.resolve();
      }

      pause() {
        console.log('Definition animation paused');
      }

      reset() {
        console.log('Definition animation reset');
      }

      setSpeed(speed) {
        console.log('Definition animation speed set to:', speed);
      }
    }
  `;

      default:
        return '';
    }
  }
}

---- File Content End ----


=== File: baseAnimationTemplate.ts ===
Path: data\animations\library\baseAnimationTemplate.ts
---- File Content Start ----
export const baseAnimationTemplate = `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: box-shadow 0.3s ease;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #safety-warning {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 90%;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Animation state
        let animationState = {
            temperature: 20,
            zoom: 1,
            speed: 1,
            showBefore: true,
            rotation3D: true,
            particleCount: 50,
            pressure: 1,
            concentration: 0.5,
            isPlaying: true,
            safetyStatus: { isSafe: true, warnings: [] }
        };

        // Initialize with passed state
        if (window.initialState) {
            animationState = { ...animationState, ...window.initialState };
        }

        // Safety functions
        function handleSafetyStatus(status) {
            if (!status.isSafe) {
                document.body.style.boxShadow = 'inset 0 0 0 3px #ff3b30';
                showSafetyWarning(status.warnings);
            } else {
                document.body.style.boxShadow = 'none';
                hideSafetyWarning();
            }
        }

        function showSafetyWarning(warnings) {
            let warningEl = document.getElementById('safety-warning');
            if (!warningEl) {
                warningEl = document.createElement('div');
                warningEl.id = 'safety-warning';
                document.body.appendChild(warningEl);
            }

            // Update content
            warningEl.innerHTML = warnings.join(' ⚠️ ') +
                '<br><small>Adjust parameters to safe levels</small>';
        }

        function hideSafetyWarning() {
            const warningEl = document.getElementById('safety-warning');
            if (warningEl) warningEl.remove();
        }

        // Handle control updates from React Native
        window.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'controlUpdate') {
                    animationState[data.control] = data.value;

                    // Handle safety update
                    if (data.control === 'safetyStatus') {
                        handleSafetyStatus(data.value);
                    }

                    // Call animation-specific update handler
                    if (window.handleControlUpdate) {
                        window.handleControlUpdate(data.control, data.value);
                    }
                }

                if (data.action === 'restart' && window.resetAnimation) {
                    window.resetAnimation();
                }
            } catch (e) {
                console.error('Message handling error:', e);
            }
        });

        // Send state updates back to React Native
        function sendStateUpdate(state) {
            if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'stateUpdate',
                    state: state
                }));
            }
        }

        // Common animation utilities
        const AnimationUtils = {
            // Temperature effects
            getTemperatureColor: (temp) => {
                if (temp < 0) return 0x87CEEB; // Ice blue
                if (temp < 50) return 0x4169E1; // Royal blue
                if (temp < 100) return 0xFF8C00; // Dark orange
                return 0xFF4500; // Orange red
            },

            // Particle motion based on temperature
            getParticleSpeed: (temp) => {
                return 0.001 + (temp + 100) / 10000;
            },

            // Zoom handling
            applyZoom: (camera, zoom) => {
                camera.position.z = 15 / zoom;
                camera.updateProjectionMatrix();
            },

            // Speed time scaling
            getTimeScale: (speed) => {
                return speed;
            },

            // Particle visibility
            updateParticleCount: (particles, count) => {
                particles.forEach((p, i) => {
                    p.visible = i < count;
                });
            }
        };

        // Export for use in animations
        window.AnimationUtils = AnimationUtils;
        window.animationState = animationState;
        window.sendStateUpdate = sendStateUpdate;

        // Initialize safety status
        handleSafetyStatus(animationState.safetyStatus);
    </script>
</body>
</html>
`;

---- File Content End ----


=== File: chemistryCoreConcepts.ts ===
Path: data\animations\library\chemistryCoreConcepts.ts
---- File Content Start ----
// In animationRegistry.ts or a new file like 'chemistryCoreConcepts.ts'
export const chemistryCoreConcepts: AnimationConfig = {
  height: 400, // Good height for visibility of details
  autoPlay: true,
  loop: false, // It's a narrative animation, so likely no loop or a very long one
  backgroundColor: '#1f2937', // A dark, neutral background (e.g., dark slate gray)
  features: {
    temperature: true,    // For Scene 2 (Properties/Phase Changes) & Scene 5
    zoom: true,           // Generally useful for all scenes
    speed: true,          // For controlling animation rates in all scenes
    beforeAfter: true,    // For Scene 5 (Chemical Change)
    rotation3D: true,     // For Scene 3, 4, 6 (Composition, Structure, Conclusion)
    particleCount: true,  // For Scene 2 (Properties) & Scene 3 (Composition)
    // pressure: false,   // Less critical for this core overview
    // concentration: false // Less critical for this core overview
  },
  html: `<!-- HTML structure will be baseAnimationTemplate + specific script -->`
};

---- File Content End ----


=== File: hydrogenOxygenWater.ts ===
Path: data\animations\library\hydrogenOxygenWater.ts
---- File Content Start ----
// src/data/animations/library/hydrogenOxygenWater.ts
import { AnimationConfig } from '../types';
import { baseAnimationTemplate } from './baseAnimationTemplate';

export const hydrogenOxygenWater: AnimationConfig = {
  height: 500,
  autoPlay: true,
  loop: false,
  features: {
    speed: true,
    beforeAfter: true,
    rotation3D: true,
    temperature: true,
  },
    safety: {
        maxTemperature: 100,
        maxPressure: 2,
        maxConcentration: 1.0,
        minDistance: 0.5,
        requiredEquipment: ['Safety Goggles', 'Gloves'],
        hazardousReactions: ['explosive', 'toxic']
    },
  html: baseAnimationTemplate + `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        /* Add your full animation styles here */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>
    <script>
        // Your full Three.js animation code here
        // Add message posting for communication with React Native

        // When animation completes:
        window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'animationComplete'
        }));

        // Listen for control messages
        window.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            if (data.action === 'restart') {
                resetAnimation();
            }
        });
    </script>
</body>
</html>
`
};

---- File Content End ----


=== File: statesOfMatter.ts ===
Path: data\animations\library\statesOfMatter.ts
---- File Content Start ----
// src/data/animations/library/statesOfMatter.ts
import { AnimationConfig } from '../types';
import { baseAnimationTemplate } from './baseAnimationTemplate';

export const statesOfMatter: AnimationConfig = {
  height: 350,
  autoPlay: true,
  loop: true,
  features: {
    temperature: true,
    zoom: true,
    speed: true,
    particleCount: true
  },
 safety: {
    maxTemperature: 100,
    maxPressure: 2,
    maxConcentration: 1.0,
    minDistance: 0.5,
    requiredEquipment: ['Safety Goggles', 'Gloves'],
    hazardousReactions: ['explosive', 'toxic']
 },
  html: baseAnimationTemplate + `
    <script>
        // States of Matter specific animation code
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Create particles for each state
        const particles = [];
        const particleGeometry = new THREE.SphereGeometry(0.3, 16, 16);

        // Create particle grid
        for (let i = 0; i < 200; i++) {
            const material = new THREE.MeshPhongMaterial({
                color: 0x3498db,
                emissive: 0x2980b9,
                emissiveIntensity: 0.2
            });
            const particle = new THREE.Mesh(particleGeometry, material);
            particle.userData.basePosition = new THREE.Vector3(
                (i % 10 - 5) * 1.5,
                (Math.floor(i / 10) % 10 - 5) * 1.5,
                (Math.floor(i / 100) - 1) * 1.5
            );
            particle.position.copy(particle.userData.basePosition);
            scene.add(particle);
            particles.push(particle);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Handle control updates
        window.handleControlUpdate = (control, value) => {
            if (control === 'temperature') {
                // Update particle colors based on temperature
                particles.forEach(p => {
                    p.material.color.setHex(AnimationUtils.getTemperatureColor(value));
                });
            }
            if (control === 'zoom') {
                AnimationUtils.applyZoom(camera, value);
            }
            if (control === 'particleCount') {
                AnimationUtils.updateParticleCount(particles, value);
            }
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (animationState.isPlaying) {
                const time = Date.now() * 0.001 * animationState.speed;
                const temp = animationState.temperature;

                particles.forEach((particle, i) => {
                    if (!particle.visible) return;

                    const basePos = particle.userData.basePosition;

                    if (temp < 0) {
                        // Solid state - vibrate in place
                        particle.position.x = basePos.x + Math.sin(time * 2 + i) * 0.1;
                        particle.position.y = basePos.y + Math.cos(time * 2 + i) * 0.1;
                        particle.position.z = basePos.z;
                    } else if (temp < 100) {
                        // Liquid state - flow but stay close
                        const flowSpeed = temp / 100;
                        particle.position.x = basePos.x + Math.sin(time + i) * flowSpeed;
                        particle.position.y = basePos.y + Math.cos(time + i) * flowSpeed;
                        particle.position.z = basePos.z + Math.sin(time * 0.5 + i) * flowSpeed * 0.5;
                    } else {
                        // Gas state - random motion
                        const speed = AnimationUtils.getParticleSpeed(temp);
                        particle.position.x += (Math.random() - 0.5) * speed * 50;
                        particle.position.y += (Math.random() - 0.5) * speed * 50;
                        particle.position.z += (Math.random() - 0.5) * speed * 50;

                        // Boundary check
                        if (Math.abs(particle.position.x) > 20) particle.position.x *= -0.9;
                        if (Math.abs(particle.position.y) > 20) particle.position.y *= -0.9;
                        if (Math.abs(particle.position.z) > 20) particle.position.z *= -0.9;
                    }
                });

                if (animationState.rotation3D) {
                    scene.rotation.y += 0.005 * animationState.speed;
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize controls
        window.handleControlUpdate('temperature', animationState.temperature);
        window.handleControlUpdate('zoom', animationState.zoom);
        window.handleControlUpdate('particleCount', animationState.particleCount);

        animate();
    </script>
  </body>
  </html>
`
};

---- File Content End ----


=== File: chemistryDefinition.ts ===
Path: data\animations\library\chapter1\chemistryDefinition.ts
---- File Content Start ----
export const chemistryDefinition = {
  height: 600,
  autoPlay: true,
  loop: false, // Set to false as animations are event-driven
  features: {
    speed: true,
    zoom: true,
    rotation3D: true
  },
  template: {
    type: 'definition',
    config: {}
  },
  html: `
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #scene-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Game-style Side Menu */
        #game-menu {
            position: absolute;
            top: 50%;
            left: 10px; /* Adjusted for a less boxy feel */
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .menu-item {
            /* Removed background and border for a less "boxy" look, relying on text and hover effects */
            padding: 12px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-width: 180px; /* Ensure text fits */
            text-align: left;
            border-left: 3px solid transparent; /* For active state */
        }

        .menu-item:hover {
            transform: translateX(5px);
            background-color: rgba(78, 205, 196, 0.1);
        }

        .menu-item.active {
            border-left: 3px solid #4ECDC4;
            background-color: rgba(78, 205, 196, 0.2);
            transform: translateX(5px);
        }

        .menu-icon {
            font-size: 20px;
            margin-right: 10px;
            vertical-align: middle;
        }

        .menu-text {
            font-size: 16px;
            font-weight: 500;
            color: white;
            vertical-align: middle;
        }

        /* Title */
        #title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            background: rgba(0,0,0,0.2);
            padding: 10px 25px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        .title-main {
            font-size: 22px;
            font-weight: bold;
            color: #4ECDC4;
            margin-bottom: 3px;
        }

        .title-sub {
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        /* Info Panel (replaces animation-status) */
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            backdrop-filter: blur(8px);
            opacity: 0;
            transition: all 0.5s ease;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }

        #info-panel.visible {
            opacity: 1;
            bottom: 30px; /* Animate in */
        }

        .info-text {
            font-size: 14px;
            color: #E0E0E0;
            line-height: 1.6;
        }
        .info-text strong {
            color: #4ECDC4;
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(78, 205, 196, 0.2);
            border-top: 3px solid #4ECDC4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .highlight-glow {
            animation: glowPulse 1.5s infinite alternate;
        }

        @keyframes glowPulse {
            from { box-shadow: 0 0 10px #4ECDC4, 0 0 20px #4ECDC4; }
            to { box-shadow: 0 0 20px #66e0d5, 0 0 30px #66e0d5; }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            #game-menu {
                left: 5px;
                gap: 5px;
                top: 60px; /* Position below title on mobile */
                transform: translateY(0);
            }
            .menu-item {
                padding: 10px 12px;
                min-width: 150px;
            }
            .menu-icon { font-size: 18px; }
            .menu-text { font-size: 14px; }
            .title-main { font-size: 18px; }
            .title-sub { font-size: 12px; }
            #info-panel { width: 90%; font-size: 13px; padding: 10px 15px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div style="color: #4ECDC4; font-size: 16px;">Loading Chemistry Lab...</div>
        </div>

        <div id="title">
            <div class="title-main">Interactive Chemistry Lab</div>
            <div class="title-sub">Explore fundamental concepts</div>
        </div>

        <div id="game-menu">
            <div class="menu-item active" data-concept="intro">
                <span class="menu-icon">🏠</span>
                <span class="menu-text">Welcome</span>
            </div>
            <div class="menu-item" data-concept="properties">
                <span class="menu-icon">📊</span> <!-- Changed icon -->
                <span class="menu-text">Properties</span>
            </div>
            <div class="menu-item" data-concept="composition">
                <span class="menu-icon">🧪</span>
                <span class="menu-text">Composition</span>
            </div>
            <div class="menu-item" data-concept="structure">
                <span class="menu-icon">⚛️</span> <!-- Changed icon -->
                <span class="menu-text">Structure</span>
            </div>
        </div>

        <div id="scene-container"></div>

        <div id="info-panel">
            <div class="info-text">Select a concept from the menu to begin.</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let currentConcept = 'intro';
        let sceneObjects = {
            water: null,
            salt: null,
            elementsGroup: null, // Group containing all element samples
            elementMap: new Map() // To easily access element 3D objects by symbol
        };
        let activeAnimations = {
            properties: null,
            composition: null,
            structure: null
        };
        let isAnimatingGlobal = false; // Prevents multiple concept animations
        let clock = new THREE.Clock();

        // Element data store
        const elementDataStore = {
            'H': { name: 'Hydrogen', symbol: 'H', atomicNumber: 1, atomicMass: '1.008 u', color: 0xFFFFFF,
                   description: 'The lightest and most abundant chemical element.' },
            'O': { name: 'Oxygen', symbol: 'O', atomicNumber: 8, atomicMass: '15.999 u', color: 0xFF4444,
                   description: 'Highly reactive nonmetal, essential for respiration.' },
            'He': { name: 'Helium', symbol: 'He', atomicNumber: 2, atomicMass: '4.0026 u', color: 0xD4AF37, // Gold-ish
                   description: 'A noble gas, the second lightest element.' },
            'U': { name: 'Uranium', symbol: 'U', atomicNumber: 92, atomicMass: '238.03 u', color: 0x00FF00, // Bright Green for radioactive feel
                   description: 'A heavy, radioactive metal used in nuclear reactors.' },
            'C': { name: 'Carbon', symbol: 'C', atomicNumber: 6, atomicMass: '12.011 u', color: 0x444444,
                   description: 'Forms the basis of all known life.' },
            'Na': { name: 'Sodium', symbol: 'Na', atomicNumber: 11, atomicMass: '22.990 u', color: 0xAAAAFF, // Light blue/silver
                   description: 'A highly reactive alkali metal.' },
            'Cl': { name: 'Chlorine', symbol: 'Cl', atomicNumber: 17, atomicMass: '35.45 u', color: 0x90EE90, // Light green for Cl gas
                   description: 'A reactive halogen, commonly found in salt.'}
        };


        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 60);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 12);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0); // Transparent background for HTML gradient

            document.getElementById('scene-container').appendChild(renderer.domElement);

            setupLighting();
            createLabEnvironment();

            document.getElementById('loading').style.display = 'none';
            showInfoPanel('Welcome to the Interactive Chemistry Lab! Click menu items to explore.', 5000);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const pointLight = new THREE.PointLight(0x4ECDC4, 0.7, 30);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);
        }

        function createLabEnvironment() {
            const tableGeometry = new THREE.BoxGeometry(15, 0.3, 8);
            const tableMaterial = new THREE.MeshPhongMaterial({ color: 0x34495e, shininess: 20 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.y = -1.15;
            table.receiveShadow = true;
            scene.add(table);

            sceneObjects.water = createWaterBottle();
            sceneObjects.salt = createSaltShaker();
            sceneObjects.elementsGroup = createElementSamples();

            createBackgroundParticles();
        }

        function createWaterBottle() { /* ... (keep existing createWaterBottle, ensure it's added to scene) ... */
            const group = new THREE.Group();
            const bottleGeometry = new THREE.CylinderGeometry(0.7, 0.5, 2.5, 16);
            const bottleMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.6, shininess: 80 });
            const bottle = new THREE.Mesh(bottleGeometry, bottleMaterial);
            bottle.castShadow = true;
            group.add(bottle);

            const capGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.25, 16);
            const capMaterial = new THREE.MeshPhongMaterial({ color: 0x2980b9 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.375;
            cap.castShadow = true;
            group.add(cap);

            group.position.set(-3.5, 0, 0);
            group.userData.name = 'Water Bottle';
            scene.add(group);
            return group;
        }

        function createSaltShaker() { /* ... (keep existing createSaltShaker, ensure it's added to scene) ... */
            const group = new THREE.Group();
            const shakerGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2, 16);
            const shakerMaterial = new THREE.MeshPhongMaterial({ color: 0xEAEAEA, shininess: 40 });
            const shaker = new THREE.Mesh(shakerGeometry, shakerMaterial);
            shaker.castShadow = true;
            group.add(shaker);

            const topGeometry = new THREE.CylinderGeometry(0.3, 0.5, 0.3, 16);
            const topMaterial = new THREE.MeshPhongMaterial({ color: 0xBDC3C7 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1.15;
            top.castShadow = true;
            group.add(top);

            group.position.set(3.5, -0.1, 0); // slightly lower
            group.userData.name = 'Salt Shaker';
            scene.add(group);
            return group;
        }

        function createElementSamples() {
            const group = new THREE.Group();
            const elementsToShow = ['H', 'O', 'He', 'U', 'C', 'Na']; // H, O, He, U are for properties
            const positions = [
                [-5, 0, 2.5], [-3, 0, 2.5], [-1, 0, 2.5], // H, O, He
                [1, 0, 2.5], [3, 0, 2.5], [5, 0, 2.5]    // U, C, Na
            ];

            elementsToShow.forEach((symbol, index) => {
                const elData = elementDataStore[symbol];
                if (!elData) return;

                const elGroup = new THREE.Group();

                const baseGeo = new THREE.CylinderGeometry(0.45, 0.55, 0.2, 16);
                const baseMat = new THREE.MeshPhongMaterial({color: 0x555555});
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = -0.4;
                elGroup.add(base);

                const sampleGeo = new THREE.SphereGeometry(0.35, 32, 32);
                const sampleMat = new THREE.MeshPhongMaterial({
                    color: elData.color,
                    shininess: 80,
                    emissive: (symbol === 'U') ? elData.color : 0x000000, // Glow for Uranium
                    emissiveIntensity: (symbol === 'U') ? 0.5 : 1,
                });
                const sample = new THREE.Mesh(sampleGeo, sampleMat);
                sample.castShadow = true;
                elGroup.add(sample);

                // Label
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#222'; ctx.fillRect(0,0,128,64);
                ctx.fillStyle = 'white'; ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center'; ctx.fillText(elData.symbol, 64, 45);
                const labelTexture = new THREE.CanvasTexture(canvas);
                const labelMat = new THREE.SpriteMaterial({ map: labelTexture });
                const labelSprite = new THREE.Sprite(labelMat);
                labelSprite.scale.set(1, 0.5, 1);
                labelSprite.position.set(0, -0.7, 0);
                elGroup.add(labelSprite);

                elGroup.position.set(...positions[index]);
                elGroup.userData = { ...elData, type: 'element_sample', originalEmissive: sampleMat.emissive.getHex() };
                group.add(elGroup);
                sceneObjects.elementMap.set(symbol, elGroup);
            });
            group.position.y = 0; // Adjust if needed
            scene.add(group);
            return group;
        }


        function createBackgroundParticles() { /* ... (keep existing or similar) ... */
            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 0.05 + 0.02, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.6 ? 0x4ECDC4 : (Math.random() > 0.3 ? 0x64B5F6 : 0xffffff),
                    transparent: true,
                    opacity: Math.random() * 0.4 + 0.2
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 30 - 10 // Biased towards back
                );
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.005,
                    (Math.random() - 0.5) * 0.005,
                    (Math.random() - 0.5) * 0.005
                );
                scene.add(particle);
            }
        }

        // --- Camera Animation Utility ---
        let cameraAnimation;
        function animateCameraTo(targetPosition, lookAtTarget, duration = 1500, onComplete = null) {
            if (cameraAnimation) cancelAnimationFrame(cameraAnimation);

            const startPosition = camera.position.clone();
            const startLookAt = new THREE.Vector3(); // Current lookAt
            camera.getWorldDirection(startLookAt).multiplyScalar(10).add(camera.position); // A bit hacky to get current lookAt point

            const finalLookAt = lookAtTarget.clone();
            let startTime = null;

            function animate(time) {
                if (startTime === null) startTime = time;
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); // Ease in-out

                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);

                const currentLookAt = new THREE.Vector3().lerpVectors(startLookAt, finalLookAt, easeProgress);
                camera.lookAt(currentLookAt);

                if (progress < 1) {
                    cameraAnimation = requestAnimationFrame(animate);
                } else {
                    cameraAnimation = null;
                    if (onComplete) onComplete();
                }
            }
            cameraAnimation = requestAnimationFrame(animate);
        }

        // --- Info Panel ---
        let infoPanelTimeout;
        function showInfoPanel(htmlContent, duration = null) {
            const panel = document.getElementById('info-panel');
            const textElement = panel.querySelector('.info-text');
            textElement.innerHTML = htmlContent;
            panel.classList.add('visible');

            if (infoPanelTimeout) clearTimeout(infoPanelTimeout);
            if (duration) {
                infoPanelTimeout = setTimeout(() => hideInfoPanel(), duration);
            }
        }

        function hideInfoPanel() {
            if (infoPanelTimeout) clearTimeout(infoPanelTimeout);
            document.getElementById('info-panel').classList.remove('visible');
        }

        // --- Highlighting ---
        let currentHighlightedObject = null;
        function highlightObject(object, glow = true) {
            if (currentHighlightedObject && currentHighlightedObject.userData.sphere) {
                 currentHighlightedObject.userData.sphere.material.emissive.setHex(currentHighlightedObject.userData.originalEmissive || 0x000000);
            }
            currentHighlightedObject = null;

            if (object && object.children && object.children.length > 0) {
                const sphere = object.children.find(child => child.geometry.type === 'SphereGeometry'); // Assuming the main part is a sphere
                if (sphere) {
                    object.userData.sphere = sphere; // cache it
                    object.userData.originalEmissive = sphere.material.emissive.getHex();
                    sphere.material.emissive.setHex(0x4ECDC4); // Highlight color
                    currentHighlightedObject = object;
                }
            }
        }
        function clearHighlight() {
             if (currentHighlightedObject && currentHighlightedObject.userData.sphere) {
                 currentHighlightedObject.userData.sphere.material.emissive.setHex(currentHighlightedObject.userData.originalEmissive || 0x000000);
            }
            currentHighlightedObject = null;
        }


        // --- PROPERTIES ANIMATION ---
        async function animateProperties() {
            if (isAnimatingGlobal) return;
            isAnimatingGlobal = true;
            showInfoPanel('Exploring element properties...');

            const elementsToFeature = ['O', 'H', 'He', 'U'];
            const originalCameraPos = camera.position.clone();
            const originalLookAt = new THREE.Vector3(0,0,0); // Assuming initial lookAt is origin

            for (const symbol of elementsToFeature) {
                const elementObj = sceneObjects.elementMap.get(symbol);
                if (!elementObj) continue;

                const elData = elementDataStore[symbol];
                highlightObject(elementObj);

                const targetCamPos = elementObj.position.clone().add(new THREE.Vector3(0, 1, 3)); // Adjust camera offset
                await new Promise(resolve => animateCameraTo(targetCamPos, elementObj.position, 1200, resolve));

                showInfoPanel(
                    \`<strong>\${elData.name} (\${elData.symbol})</strong><br>
                    Atomic Number: \${elData.atomicNumber}<br>
                    Atomic Mass: \${elData.atomicMass}<br>
                    <em>\${elData.description}</em>\`
                );
                await new Promise(resolve => setTimeout(resolve, 3500)); // Time to read
                clearHighlight();
            }

            showInfoPanel('Properties exploration complete. Returning to main view.', 2000);
            animateCameraTo(originalCameraPos, originalLookAt, 1500, () => {
                isAnimatingGlobal = false;
            });
        }

        // --- COMPOSITION ANIMATION ---
        let compositionElements = [];
        async function animateComposition() {
            if (isAnimatingGlobal) return;
            isAnimatingGlobal = true;
            showInfoPanel('Analyzing chemical compositions...');

            compositionElements.forEach(el => scene.remove(el));
            compositionElements = [];

            const originalCameraPos = camera.position.clone();
            const originalLookAt = new THREE.Vector3(0,0,0);

            // 1. Water (H2O)
            const waterBottle = sceneObjects.water;
            highlightObject(waterBottle.children[0]); // Highlight bottle mesh itself
            let targetCamPosWater = waterBottle.position.clone().add(new THREE.Vector3(0, 1, 4));
            await new Promise(resolve => animateCameraTo(targetCamPosWater, waterBottle.position, 1200, resolve));
            showInfoPanel('Water (H₂O) is composed of Hydrogen and Oxygen.');

            const h1 = createFloatingAtom('H', elementDataStore['H'].color, waterBottle.position, new THREE.Vector3(-1, 0.5, 0.5));
            const h2 = createFloatingAtom('H', elementDataStore['H'].color, waterBottle.position, new THREE.Vector3(-1, -0.5, 0.5));
            const o = createFloatingAtom('O', elementDataStore['O'].color, waterBottle.position, new THREE.Vector3(1, 0, 0.5));
            compositionElements.push(h1, h2, o);
            scene.add(h1, h2, o);
            await new Promise(resolve => setTimeout(resolve, 3000));
            clearHighlight();

            // 2. Salt (NaCl)
            const saltShaker = sceneObjects.salt;
            highlightObject(saltShaker.children[0]);
            let targetCamPosSalt = saltShaker.position.clone().add(new THREE.Vector3(0, 1, 4));
            await new Promise(resolve => animateCameraTo(targetCamPosSalt, saltShaker.position, 1200, resolve));
            showInfoPanel('Table Salt (NaCl) is composed of Sodium and Chlorine.');

            const na = createFloatingAtom('Na', elementDataStore['Na'].color, saltShaker.position, new THREE.Vector3(-1, 0.3, 0.5));
            const cl = createFloatingAtom('Cl', elementDataStore['Cl'].color, saltShaker.position, new THREE.Vector3(1, 0.3, 0.5));
            compositionElements.push(na, cl);
            scene.add(na, cl);
            await new Promise(resolve => setTimeout(resolve, 3000));
            clearHighlight();

            showInfoPanel('Composition analysis complete. Returning to main view.', 2000);
            animateCameraTo(originalCameraPos, originalLookAt, 1500, () => {
                compositionElements.forEach(el => scene.remove(el));
                compositionElements = [];
                isAnimatingGlobal = false;
            });
        }

        function createFloatingAtom(symbol, color, originPosition, offsetPosition, scale = 0.4) {
            const group = new THREE.Group();
            const atomGeo = new THREE.SphereGeometry(scale, 16, 16);
            const atomMat = new THREE.MeshPhongMaterial({ color: color, shininess: 70 });
            const atomMesh = new THREE.Mesh(atomGeo, atomMat);
            group.add(atomMesh);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0,0,64,64); // Transparent background
            ctx.fillStyle = 'white'; ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center'; ctx.fillText(symbol, 32, 42);
            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelMat = new THREE.SpriteMaterial({ map: labelTexture });
            const labelSprite = new THREE.Sprite(labelMat);
            labelSprite.scale.set(scale * 1.5, scale * 1.5 * (64/64), 1); // Adjust scale based on aspect
            labelSprite.position.y = scale * 1.5; // Position above atom
            group.add(labelSprite);

            group.position.copy(originPosition); // Start at origin
            // Animate to offset
            const targetPos = originPosition.clone().add(offsetPosition);
            animateObjectToTarget(group, targetPos, 1000);
            return group;
        }

        function animateObjectToTarget(object, targetPosition, duration) {
            const startPos = object.position.clone();
            let startTime = null;
            function anim(time) {
                if (startTime === null) startTime = time;
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                object.position.lerpVectors(startPos, targetPosition, easeProgress);
                if (progress < 1) requestAnimationFrame(anim);
            }
            requestAnimationFrame(anim);
        }


        // --- STRUCTURE ANIMATION ---
        let atomicStructureVisuals = [];
        async function animateStructure() {
            if (isAnimatingGlobal) return;
            isAnimatingGlobal = true;

            atomicStructureVisuals.forEach(obj => scene.remove(obj));
            atomicStructureVisuals = [];

            const originalCameraPos = camera.position.clone();
            const originalLookAt = new THREE.Vector3(0,0,0); // Default lookAt

            // Focus on Helium for demonstration
            const elementSymbol = 'He';
            const elementObj = sceneObjects.elementMap.get(elementSymbol);
            const elData = elementDataStore[elementSymbol];

            if (!elementObj || !elData) {
                showInfoPanel('Could not find element for structure view.', 3000);
                isAnimatingGlobal = false;
                return;
            }

            showInfoPanel(\`Visualizing atomic structure of \${elData.name}...\`);
            highlightObject(elementObj);
            const focusPoint = elementObj.position.clone().add(new THREE.Vector3(0, 2, 0)); // Point above element
            const camPos = elementObj.position.clone().add(new THREE.Vector3(0, 2, 4)); // Camera slightly above and in front

            await new Promise(resolve => animateCameraTo(camPos, focusPoint, 1200, resolve));
            elementObj.visible = false; // Hide the sample

            // Create atomic structure (Helium: 2p, 2n, 2e)
            const nucleus = new THREE.Group();
            // Protons
            const protonGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const protonMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const p1 = new THREE.Mesh(protonGeo, protonMat); p1.position.set(-0.15, 0, 0);
            const p2 = new THREE.Mesh(protonGeo, protonMat); p2.position.set(0.15, 0.05, 0.05);
            nucleus.add(p1, p2);
            // Neutrons
            const neutronGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const neutronMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const n1 = new THREE.Mesh(neutronGeo, neutronMat); n1.position.set(0, -0.15, 0.05);
            const n2 = new THREE.Mesh(neutronGeo, neutronMat); n2.position.set(0.05, 0.1, -0.1);
            nucleus.add(n1, n2);

            nucleus.position.copy(focusPoint);
            scene.add(nucleus);
            atomicStructureVisuals.push(nucleus);

            // Electrons
            const electronGeo = new THREE.SphereGeometry(0.08, 16, 16);
            const electronMat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            const electrons = [];
            const orbitRadius = 1.5;
            for (let i = 0; i < 2; i++) {
                const electron = new THREE.Mesh(electronGeo, electronMat);
                electron.userData.angle = (i / 2) * Math.PI * 2 + Math.random() * 0.5; // Stagger start
                electron.userData.orbitSpeed = 0.01 + Math.random() * 0.005;
                electron.position.set(
                    Math.cos(electron.userData.angle) * orbitRadius,
                    0, // simple planar orbit for now
                    Math.sin(electron.userData.angle) * orbitRadius
                );
                nucleus.add(electron); // Add to nucleus group so they move with it
                electrons.push(electron);
                atomicStructureVisuals.push(electron); // Though they are children, good for direct removal
            }

            activeAnimations.structure = { nucleus, electrons, orbitRadius };

            showInfoPanel("Atomic structure (protons, neutrons, electrons) determines an element's chemical behavior and properties.", 6000);

            await new Promise(resolve => setTimeout(resolve, 6000)); // Display time

            activeAnimations.structure = null; // Stop electron animation
            atomicStructureVisuals.forEach(obj => scene.remove(obj)); // obj might be group or individual mesh
            atomicStructureVisuals = [];
            elementObj.visible = true; // Show sample again
            clearHighlight();

            showInfoPanel('Structure view complete. Returning to main view.', 2000);
            animateCameraTo(originalCameraPos, originalLookAt, 1500, () => {
                isAnimatingGlobal = false;
            });
        }


        // --- Menu Interaction ---
        function handleMenuClick(concept) {
            if (concept === currentConcept || isAnimatingGlobal) return;

            document.querySelectorAll('.menu-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.concept === concept) {
                    item.classList.add('active');
                }
            });
            currentConcept = concept;
            hideInfoPanel(); // Clear previous messages
            clearHighlight(); // Clear any existing highlights

            // Reset camera if a previous animation left it focused
            if (camera.position.distanceTo(new THREE.Vector3(0, 3, 12)) > 0.1) {
                 animateCameraTo(new THREE.Vector3(0, 3, 12), new THREE.Vector3(0,0,0), 800);
            }


            switch(concept) {
                case 'intro':
                    showInfoPanel('Welcome! Explore chemistry concepts by clicking the menu.', 4000);
                    // Potentially reset camera to default if it was moved
                    animateCameraTo(new THREE.Vector3(0, 3, 12), new THREE.Vector3(0,0,0), 1000);
                    break;
                case 'properties':
                    animateProperties();
                    break;
                case 'composition':
                    animateComposition();
                    break;
                case 'structure':
                    animateStructure();
                    break;
            }
            createParticleBurst(true); // Subtle burst
        }

        function createParticleBurst(subtle = false) { /* ... (keep existing or similar) ... */
            const count = subtle ? 10 : 20;
            const spread = subtle ? 1 : 2;
            const size = subtle ? 0.03 : 0.05;

            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: [0x4ECDC4, 0xFF6B6B, 0xFFD93D, 0x6BCF7F][Math.floor(Math.random() * 4)],
                    transparent: true, opacity: 0.9
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set( (Math.random() - 0.5) * spread, Math.random() * spread + 1, (Math.random() - 0.5) * spread );
                const velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.1, Math.random() * 0.05 + 0.02, (Math.random() - 0.5) * 0.1 );
                particle.userData = { velocity, life: 1.0, isBurstParticle: true };
                scene.add(particle);
            }
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Gentle rotation for scene items (if not focused by an animation)
            if (!isAnimatingGlobal) {
                if (sceneObjects.water) sceneObjects.water.rotation.y += 0.002;
                if (sceneObjects.salt) sceneObjects.salt.rotation.y += 0.002;
                if (sceneObjects.elementsGroup) sceneObjects.elementsGroup.rotation.y += 0.001;
            }

            // Animate background particles & burst particles
            scene.traverse((object) => {
                if (object.userData.velocity) {
                    object.position.addScaledVector(object.userData.velocity, delta * 20); // Adjust multiplier for speed

                    if (object.userData.isBurstParticle) {
                        object.userData.velocity.y -= 0.002; // Gravity for burst
                        object.userData.life -= delta * 0.8;
                        object.material.opacity = Math.max(0, object.userData.life);
                        if (object.userData.life <= 0) scene.remove(object);
                    } else { // Background particles
                        if (Math.abs(object.position.x) > 15) object.position.x = -object.position.x;
                        if (Math.abs(object.position.y) > 10) object.position.y = -object.position.y;
                        if (Math.abs(object.position.z) > 15) object.position.z = -object.position.z;
                    }
                }
            });

            // Electron orbits for Structure animation
            if (activeAnimations.structure && activeAnimations.structure.electrons) {
                const { electrons, nucleus, orbitRadius } = activeAnimations.structure;
                electrons.forEach(e => {
                    e.userData.angle += e.userData.orbitSpeed;
                    e.position.set(
                        Math.cos(e.userData.angle) * orbitRadius,
                        Math.sin(e.userData.angle * 0.7) * orbitRadius * 0.3, // Slight wobble on Y
                        Math.sin(e.userData.angle) * orbitRadius
                    );
                });
                nucleus.rotation.y += 0.005; // Gently rotate nucleus
            }


            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', () => handleMenuClick(item.dataset.concept));
        });

        window.addEventListener('message', (event) => {
            // Existing message handling
        });

        window.addEventListener('load', () => {
            setTimeout(() => {
                initThreeJS();
                animate();
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'animationReady', animation: 'chemistry-explorer'
                    }));
                }
            }, 200); // Slight delay for assets
        });
    </script>
</body>
</html>
`
};

---- File Content End ----


=== File: chemistryDefinitionInteractive.ts ===
Path: data\animations\library\chapter1\chemistryDefinitionInteractive.ts
---- File Content Start ----
// src/data/animations/library/chapter1/chemistryDefinitionInteractive.ts
import { AnimationConfig } from '../../types';
import { baseAnimationTemplate } from '../baseAnimationTemplate';

// Scene definitions with additional examples
const openingDuration = 2;
const definitionDisplayAndHighlightDuration = 2.5;
const finalDefinitionSummaryDuration = 3.5;

// Durations for explanation content scenes
const branchExplanationDuration = 4;
const propertyExplanationDuration = 2;
const compositionExplanationDuration = 2.5;
const physicalChangeExplanationDuration = 3;
const chemicalChangeExplanationDuration = 4;
const lawExplanationDuration = 2;

const configScenes = [];
const configDurations = [];

// 1. Opening Title
configScenes.push('opening');                           configDurations.push(openingDuration);

// 2. Initial Definition view
configScenes.push('definition-show-initial');           configDurations.push(definitionDisplayAndHighlightDuration);

// 3. Branch of Science
configScenes.push('definition-highlight-branch');       configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('branch-of-science-content');         configDurations.push(branchExplanationDuration);

// 4. Properties
configScenes.push('definition-highlight-properties');   configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('property-1-content');                configDurations.push(propertyExplanationDuration);
configScenes.push('property-2-content');                configDurations.push(propertyExplanationDuration);
configScenes.push('property-3-content');                configDurations.push(propertyExplanationDuration);

// 5. Composition & Structure
configScenes.push('definition-highlight-composition');  configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('composition-1-content');             configDurations.push(compositionExplanationDuration);
configScenes.push('composition-2-content');             configDurations.push(compositionExplanationDuration);
configScenes.push('composition-3-content');             configDurations.push(compositionExplanationDuration);

// 6. Physical Changes - Added ammonia and CO2 examples
configScenes.push('definition-highlight-physical');     configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('physical-changes-1-content');        configDurations.push(physicalChangeExplanationDuration);
configScenes.push('physical-changes-2-content');        configDurations.push(physicalChangeExplanationDuration);
configScenes.push('physical-changes-3-content');        configDurations.push(physicalChangeExplanationDuration);

// 7. Chemical Changes - Added more examples, removed subtitles
configScenes.push('definition-highlight-chemical');     configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('chemical-changes-1-content');        configDurations.push(chemicalChangeExplanationDuration);
configScenes.push('chemical-changes-2-content');        configDurations.push(chemicalChangeExplanationDuration);
configScenes.push('chemical-changes-3-content');        configDurations.push(chemicalChangeExplanationDuration);

// 8. Laws
configScenes.push('definition-highlight-laws');         configDurations.push(definitionDisplayAndHighlightDuration);
configScenes.push('law-1-content');                     configDurations.push(lawExplanationDuration);
configScenes.push('law-2-content');                     configDurations.push(lawExplanationDuration);
configScenes.push('law-3-content');                     configDurations.push(lawExplanationDuration);
configScenes.push('law-4-content');                     configDurations.push(lawExplanationDuration);

// 9. Final Definition Summary
configScenes.push('final-definition-summary');          configDurations.push(finalDefinitionSummaryDuration);

const newTotalDuration = configDurations.reduce((a, b) => a + b, 0);

export const chemistryDefinitionInteractive: AnimationConfig = {
  height: 600,
  autoPlay: false,
  loop: false,
  features: {
    speed: true,
  },
  template: {
    type: 'definition',
    config: {
      scenes: configScenes,
      sceneDurations: configDurations,
      totalDuration: newTotalDuration
    }
  },
  html: baseAnimationTemplate.replace('</body>', '') + `
    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        color: white;
      }

      #animation-container {
        width: 100vw;
        height: 100vh;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center center;
        transition: transform 0.3s ease;
      }

      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        padding: 1rem;
        box-sizing: border-box;
        transform-origin: center center;
        transition: transform 0.3s ease;
      }

      .scene-title {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        opacity: 0; visibility: hidden;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
      }
      .scene-title.visible {
        opacity: 1; visibility: visible;
        transform: translate(-50%, -50%) scale(1);
        transition-delay: 0s;
      }

      .section-title {
        position: absolute;
        top: 8%;
        left: 50%;
        transform: translateX(-50%) translateY(-20px) scale(0.95);
        font-size: 1.5rem;
        font-weight: bold;
        text-align: center;
        opacity: 0; visibility: hidden;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        color: #FFD700;
        width: 90%;
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
      }
      .section-title.visible {
        opacity: 1; visibility: visible;
        transform: translateX(-50%) translateY(0) scale(1);
        transition-delay: 0s;
      }

      .property-subtitle {
        position: absolute;
        top: 15%;
        left: 50%;
        transform: translateX(-50%) translateY(-10px) scale(0.95);
        font-size: 1.4rem;
        font-weight: bold;
        text-align: center;
        opacity: 0; visibility: hidden;
        color: rgba(255,255,255,0.9);
        background: rgba(0,0,0,0.5);
        padding: 0.5rem 1rem;
        border-radius: 8px;
        width: auto;
        max-width: 80%;
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
      }
      .property-subtitle.visible {
        opacity: 1; visibility: visible;
        transform: translateX(-50%) translateY(0) scale(1);
        transition-delay: 0s;
      }

      .definition-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        background: rgba(0,0,0,0.85);
        padding: 2.5rem 3rem;
        border-radius: 20px;
        font-size: 1.3rem;
        max-width: 90%;
        width: auto;
        min-width: 300px;
        text-align: center;
        opacity: 0; visibility: hidden;
        line-height: 1.7;
        border: 3px solid #FFD700;
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
      }
      .definition-text.visible {
        opacity: 1; visibility: visible;
        transform: translate(-50%, -50%) scale(1);
        transition-delay: 0s;
      }

      .highlight-word {
        transition: all 0.5s ease;
        padding: 0.1em 0.25em;
        border-radius: 4px;
        display: inline-block;
      }
      .highlight-word.active {
        background: linear-gradient(45deg, #FFD700, #FFA500);
        color: #333;
        font-weight: bold;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.75);
        animation: activeHighlightPulseAnim 1.5s ease-in-out infinite alternate;
        transform: scale(1.06);
      }
      @keyframes activeHighlightPulseAnim {
        to { opacity: 0.9; transform: scale(1.09); box-shadow: 0 2px 18px rgba(255, 200, 0, 0.8); }
      }
      .highlight-word.explained {
        background-color: rgba(78, 205, 196, 0.22);
        border-bottom: 2px dotted rgba(78, 205, 196, 0.65);
        color: #E8E8E8;
        font-weight: normal;
        transform: scale(1);
        animation: none;
        opacity: 0.95;
      }

      .science-tree {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -40%) scale(0.95);
        opacity: 0; visibility: hidden;
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
        width: 100%;
        max-width: 500px;
      }
      .science-tree.visible {
        opacity: 1; visibility: visible;
        transform: translate(-50%, -40%) scale(1);
        transition-delay: 0s;
      }

      .science-center {
        width: 60px; height: 60px;
        background: radial-gradient(circle at 30% 30%, #FFD700, #FFA000);
        border-radius: 50%; display: flex; align-items: center; justify-content: center;
        font-size: 0.8rem; font-weight: bold; color: #333;
        margin: 0 auto 35px; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        animation: centerPulseAnimCSS 2s ease-in-out infinite;
      }
      @keyframes centerPulseAnimCSS {0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

      .branches-container { display: flex; justify-content: center; gap: 15px; position: relative; flex-wrap: wrap; }
      .branch-card {
        background: rgba(255,255,255,0.15); padding: 1rem; border-radius: 12px;
        text-align: center; min-width: 90px; backdrop-filter: blur(10px);
        border: 2px solid rgba(255,255,255,0.2); transition: all 0.5s ease;
        position: relative; cursor: default; margin: 0.25rem;
      }
      .branch-card.chemistry {
        min-width: 120px; transform: scale(1.1);
        background: rgba(255,215,0,0.2); border: 3px solid #FFD700;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      }
      .branch-card.active-highlight {
        transform: scale(1.25);
        background: rgba(255,215,0,0.35); border: 3px solid #FFEB3B;
        box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
      }
      .branch-icon { font-size: 2rem; margin-bottom: 0.5rem; }
      .branch-title { font-size: 0.9rem; font-weight: bold; }

      .single-item-container {
        position: absolute;
        top: 55%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        opacity: 0; visibility: hidden;
        transition: opacity 0.8s ease, transform 0.8s ease, visibility 0s linear 0.8s;
        text-align: center;
        width: 90%;
        max-width: 400px;
      }
      .single-item-container.visible {
        opacity: 1; visibility: visible;
        transform: translate(-50%, -50%) scale(1);
        transition-delay: 0s;
      }

      .property-showcase, .composition-showcase, .law-showcase, .reaction-demo-card, .phase-change-card {
        background: rgba(255,255,255,0.1); border-radius: 20px; padding: 2rem;
        backdrop-filter: blur(10px); border: 2px solid rgba(255,255,255,0.2);
        transition: all 0.3s ease;
        min-height: 200px; display: flex; flex-direction: column; justify-content: center;
      }

      .property-visual { width: 80px; height: 80px; margin: 0 auto 1rem; border-radius: 15px; display: flex; align-items: center; justify-content: center; font-size: 2rem; position: relative; overflow: hidden; }
      .liquid { background: linear-gradient(180deg, #4FC3F7 0%, #29B6F6 100%); }
      .solid { background: linear-gradient(45deg, #90A4AE 0%, #607D8B 100%); }
      .gas { background: linear-gradient(135deg, #E1F5FE 0%, #B3E5FC 100%); }
      .property-title { font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem; color: #FFD700; }
      .property-value { font-size: 1.2rem; background: rgba(255,193,7,0.9); color: #333; padding: 0.5rem 1rem; border-radius: 8px; font-weight: bold; display: inline-block; margin-top: 0.5rem; }

      .composition-icon { font-size: 3rem; margin-bottom: 1rem; }
      .composition-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 1rem; color: #FFD700; }
      .molecule-structure { display: flex; align-items: center; justify-content: center; margin: 1rem 0; flex-wrap: wrap; gap: 0.25rem; min-height: 40px; }
      .atom { width: 35px; height: 35px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; margin: 0.125rem; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: relative; animation: atomPulseCSS 2s ease-in-out infinite; font-size: 0.8rem; }
      .sodium { background: radial-gradient(circle at 30% 30%, #FFD700, #FFA000); }
      .chlorine { background: radial-gradient(circle at 30% 30%, #4CAF50, #388E3C); }
      .hydrogen { background: radial-gradient(circle at 30% 30%, #FFFFFF, #E0E0E0); color: #333; }
      .oxygen { background: radial-gradient(circle at 30% 30%, #F44336, #C62828); }
      .carbon { background: radial-gradient(circle at 30% 30%, #333333, #000000); }
      .nitrogen { background: radial-gradient(circle at 30% 30%, #2196F3, #1976D2); }
      @keyframes atomPulseCSS { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
      .bond { width: 20px; height: 3px; background: #4ECDC4; animation: bondGlowCSS 2s ease-in-out infinite; }
      @keyframes bondGlowCSS { 0%, 100% { box-shadow: 0 0 3px #4ECDC4; } 50% { box-shadow: 0 0 8px #4ECDC4; } }
      .info-text { font-size: 1rem; margin-top: 1rem; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.3); padding: 0.5rem 1rem; border-radius: 8px; }

      .phase-change-card-content { display: flex; align-items: center; gap: 1rem; justify-content:center; }
      .phase-visual { width: 60px; height: 60px; border-radius: 10px; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
      .ice { background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%); }
      .water { background: linear-gradient(135deg, #4FC3F7 0%, #29B6F6 100%); }
      .vapor { background: linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%); }
      .arrow-right { font-size: 1.5rem; color: #FFD700; animation: arrowPulseCSS 1s ease-in-out infinite; }
      @keyframes arrowPulseCSS { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

      .reaction-equation { font-size: 1.5rem; text-align: center; margin-bottom: 1rem; font-family: 'Courier New', monospace; color: #FFD700; background: rgba(0,0,0,0.3); padding: 0.5rem 1rem; border-radius: 8px; }
      .reaction-visual { display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
      .reactant, .product { padding: 0.5rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; min-width: 60px; font-size: 0.8rem; }
      .plus, .arrow-reaction { font-size: 1.2rem; color: #FFD700; align-self: center; }

      .law-icon { font-size: 3rem; margin-bottom: 1rem; }
      .law-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 1rem; color: #FFD700; }
      .law-description { font-size: 1rem; line-height: 1.5; color: rgba(255,255,255,0.9); }

      .controls { position: absolute; bottom: 60px; right: 15px; display: flex; gap: 8px; z-index: 20; pointer-events: auto; flex-direction: column; align-items: flex-end; }
      .control-row { display: flex; gap: 8px; margin-bottom: 8px; }
      .control-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3); transition: all 0.3s ease; font-size: 12px; }
      .control-btn:hover { background: rgba(255,255,255,0.3); transform: translateY(-1px); }
      .control-btn.active { background: rgba(255,215,0,0.3); border-color: #FFD700; }
      .progress-bar { position: absolute; bottom: 50px; left: 0; height: 3px; background: #FFD700; transition: width 0.5s ease; z-index: 20; width: 0%; }

      /* Mobile Optimizations */
      @media (max-width: 768px) {
        .scene-title { font-size: 2.5rem; padding: 0 1rem; }
        .section-title { font-size: 1.3rem; padding: 0 1rem; top: 10%; }
        .definition-text { font-size: 1rem; max-width: 95%; padding: 1.5rem; }
        .single-item-container { width: 95%; max-width: none; padding: 0 0.5rem; }
        .property-showcase, .composition-showcase, .law-showcase, .reaction-demo-card, .phase-change-card { padding: 1.5rem; }
        .controls { bottom: 50px; right: 10px; }
        .progress-bar { bottom: 40px; }
      }
      @media (max-width: 480px) {
        .scene-title { font-size: 2rem; }
        .section-title { font-size: 1.1rem; }
        .definition-text { font-size: 0.9rem; padding: 1rem; }
        .property-showcase, .composition-showcase, .law-showcase, .reaction-demo-card, .phase-change-card { padding: 1rem; }
        .reaction-equation { font-size: 1.2rem; }
        .control-btn { padding: 6px 12px; font-size: 11px; }
        .controls { flex-direction: row; bottom: 10px; right: 50%; transform: translateX(50%); }
        .control-row { margin-bottom: 0; }
      }
    </style>

    <div id="animation-container">
      <div id="canvas-container"></div>
      <div id="ui-overlay">
        <!-- Scene: Opening Title -->
        <div class="scene-title" id="title">Chemistry</div>

        <!-- Main Definition Text -->
        <div class="definition-text" id="main-definition">
          <strong>Chemistry</strong> is the <span id="highlight-branch" class="highlight-word">branch of science</span> that deals with the
          <span id="highlight-properties" class="highlight-word">properties</span>,
          <span id="highlight-composition" class="highlight-word">composition</span>, and
          <span id="highlight-structure" class="highlight-word">structure</span> of substances, as well as the
          <span id="highlight-physical" class="highlight-word">physical</span> and <span id="highlight-chemical" class="highlight-word">chemical changes</span>
          in matter and the <span id="highlight-laws" class="highlight-word">laws or principles</span>
          that govern these changes.
        </div>

        <!-- Branch of Science Content -->
        <div class="section-title" id="section-title-branch">1. Branch of Science</div>
        <div class="science-tree" id="science-tree-content">
          <div class="science-center">SCIENCE</div>
          <div class="branches-container">
            <div class="branch-card chemistry" id="chemistry-branch">
              <div class="branch-icon">🧪</div><div class="branch-title">Chemistry</div>
            </div>
            <div class="branch-card"><div class="branch-icon">🔬</div><div class="branch-title">Biology</div></div>
            <div class="branch-card"><div class="branch-icon">📐</div><div class="branch-title">Physics</div></div>
          </div>
        </div>

        <!-- Properties Content -->
        <div class="section-title" id="section-title-properties">2. Substance Properties</div>
        <div class="property-subtitle" id="property-subtitle-1">Density</div>
        <div class="single-item-container" id="property-1">
          <div class="property-showcase">
            <div class="property-visual liquid">💧</div><div class="property-title">Water</div>
            <div class="property-value">Density: 1.0 g/mL</div>
          </div>
        </div>
        <div class="property-subtitle" id="property-subtitle-2">Color</div>
        <div class="single-item-container" id="property-2">
          <div class="property-showcase">
            <div class="property-visual solid">⚫</div><div class="property-title">Carbon</div>
            <div class="property-value">Color: Black</div>
          </div>
        </div>
        <div class="property-subtitle" id="property-subtitle-3">Boiling Point</div>
        <div class="single-item-container" id="property-3">
          <div class="property-showcase">
            <div class="property-visual gas">💨</div><div class="property-title">Nitrogen</div>
            <div class="property-value">Boiling: -196°C</div>
          </div>
        </div>

        <!-- Composition & Structure Content -->
        <div class="section-title" id="section-title-composition">3. Composition & Structure</div>
        <div class="property-subtitle" id="composition-subtitle-1">Salt (NaCl)</div>
        <div class="single-item-container" id="composition-1">
          <div class="composition-showcase">
            <div class="composition-icon">🧂</div><div class="composition-name">Salt (NaCl)</div>
            <div class="molecule-structure"><div class="atom sodium">Na</div><div class="bond"></div><div class="atom chlorine">Cl</div></div>
            <div class="info-text">Ionic Compound</div>
          </div>
        </div>
        <div class="property-subtitle" id="composition-subtitle-2">Water (H₂O)</div>
        <div class="single-item-container" id="composition-2">
          <div class="composition-showcase">
            <div class="composition-icon">💧</div><div class="composition-name">Water (H₂O)</div>
            <div class="molecule-structure"><div class="atom hydrogen">H</div><div class="bond"></div><div class="atom oxygen">O</div><div class="bond"></div><div class="atom hydrogen">H</div></div>
            <div class="info-text">Covalent Compound</div>
          </div>
        </div>
        <div class="property-subtitle" id="composition-subtitle-3">Sugar (C₆H₁₂O₆)</div>
        <div class="single-item-container" id="composition-3">
          <div class="composition-showcase">
            <div class="composition-icon">🍯</div><div class="composition-name">Sugar (C₆H₁₂O₆)</div>
            <div class="molecule-structure"><div class="atom carbon">C</div><div class="atom hydrogen">H</div><div class="atom oxygen">O</div></div>
            <div class="info-text">Complex Organic</div>
          </div>
        </div>

        <!-- Physical Changes Content - Added Ammonia and CO2 examples -->
        <div class="section-title" id="section-title-physical">4. Physical Changes</div>
        <div class="property-subtitle" id="physical-subtitle-1">Water States</div>
        <div class="single-item-container" id="physical-changes-1">
          <div class="phase-change-card">
            <div class="phase-change-card-content">
              <div style="text-align: center;"><div class="phase-visual ice">🧊</div><div>Ice</div></div>
              <div class="arrow-right">→</div>
              <div style="text-align: center;"><div class="phase-visual water">💧</div><div>Water</div></div>
              <div class="arrow-right">→</div>
              <div style="text-align: center;"><div class="phase-visual vapor">☁️</div><div>Steam</div></div>
            </div>
            <div class="info-text">Changes state, not identity.</div>
          </div>
        </div>
        <div class="property-subtitle" id="physical-subtitle-2">Ammonia (NH₃)</div>
        <div class="single-item-container" id="physical-changes-2">
          <div class="phase-change-card">
            <div class="phase-change-card-content">
              <div style="text-align: center;"><div class="phase-visual ice">❄️</div><div>Solid NH₃</div></div>
              <div class="arrow-right">→</div>
              <div style="text-align: center;"><div class="phase-visual water">💨</div><div>Liquid NH₃</div></div>
              <div class="arrow-right">→</div>
              <div style="text-align: center;"><div class="phase-visual vapor">☁️</div><div>Gas NH₃</div></div>
            </div>
            <div class="info-text">Ammonia changing phases.</div>
          </div>
        </div>
        <div class="property-subtitle" id="physical-subtitle-3">Carbon Dioxide (CO₂)</div>
        <div class="single-item-container" id="physical-changes-3">
          <div class="phase-change-card">
            <div class="phase-change-card-content">
              <div style="text-align: center;"><div class="phase-visual ice">🧊</div><div>Dry Ice</div></div>
              <div class="arrow-right">→</div>
              <div style="text-align: center;"><div class="phase-visual vapor">💨</div><div>CO₂ Gas</div></div>
            </div>
            <div class="info-text">Sublimation: solid to gas directly.</div>
          </div>
        </div>

        <!-- Chemical Changes Content - Removed subtitles, added more examples -->
        <div class="section-title" id="section-title-chemical">5. Chemical Changes</div>
        <div class="single-item-container" id="chemical-changes-1">
          <div class="reaction-demo-card">
            <div class="reaction-equation">2H₂ + O₂ → 2H₂O</div>
            <div class="reaction-visual">
              <div class="reactant"><div class="molecule-structure"><div class="atom hydrogen">H</div><div class="bond"></div><div class="atom hydrogen">H</div></div><div>Hydrogen</div></div>
              <div class="plus">+</div>
              <div class="reactant"><div class="molecule-structure"><div class="atom oxygen">O</div><div class="bond"></div><div class="atom oxygen">O</div></div><div>Oxygen</div></div>
              <div class="arrow-reaction">→</div>
              <div class="product"><div class="molecule-structure"><div class="atom hydrogen">H</div><div class="bond"></div><div class="atom oxygen">O</div><div class="bond"></div><div class="atom hydrogen">H</div></div><div>Water</div></div>
            </div>
            <div class="info-text">New substance (water) formed.</div>
          </div>
        </div>
        <div class="single-item-container" id="chemical-changes-2">
          <div class="reaction-demo-card">
            <div class="reaction-equation">CH₄ + 2O₂ → CO₂ + 2H₂O</div>
            <div class="reaction-visual">
              <div class="reactant"><div class="molecule-structure"><div class="atom carbon">C</div><div class="atom hydrogen">H₄</div></div><div>Methane</div></div>
              <div class="plus">+</div><div class="reactant"><div class="molecule-structure"><div class="atom oxygen">O₂</div></div><div>Oxygen</div></div>
              <div class="arrow-reaction">→</div><div class="product"><div class="molecule-structure"><div class="atom carbon">C</div><div class="atom oxygen">O₂</div></div><div>CO₂ + H₂O</div></div>
            </div>
            <div class="info-text">Combustion reaction.</div>
          </div>
        </div>
        <div class="single-item-container" id="chemical-changes-3">
          <div class="reaction-demo-card">
            <div class="reaction-equation">4Fe + 3O₂ → 2Fe₂O₃</div>
            <div class="reaction-visual">
              <div class="reactant"><div class="molecule-structure"><div class="atom" style="background: radial-gradient(circle at 30% 30%, #B0B0B0, #808080);">Fe</div></div><div>Iron</div></div>
              <div class="plus">+</div><div class="reactant"><div class="molecule-structure"><div class="atom oxygen">O₂</div></div><div>Oxygen</div></div>
              <div class="arrow-reaction">→</div><div class="product"><div class="molecule-structure"><div class="atom" style="background: radial-gradient(circle at 30% 30%, #CD853F, #A0522D);">Fe₂O₃</div></div><div>Rust</div></div>
            </div>
            <div class="info-text">Iron oxidation (rusting).</div>
          </div>
        </div>

        <!-- Laws Content - Added judge emoji -->
        <div class="section-title" id="section-title-laws">6. Study of Laws</div>
        <div class="single-item-container" id="law-1">
          <div class="law-showcase">
            <div class="law-icon">👨‍⚖️</div><div class="law-title">Conservation of Mass</div>
            <div class="law-description">Mass is not created or destroyed.</div>
          </div>
        </div>
        <div class="single-item-container" id="law-2">
          <div class="law-showcase">
            <div class="law-icon">🔨</div><div class="law-title">Conservation of Energy</div>
            <div class="law-description">Energy changes form, not lost.</div>
          </div>
        </div>
        <div class="single-item-container" id="law-3">
          <div class="law-showcase">
            <div class="law-icon">⚖️</div><div class="law-title">Le Chatelier's Principle</div>
            <div class="law-description">Equilibrium shifts to relieve stress.</div>
          </div>
        </div>
        <div class="single-item-container" id="law-4">
          <div class="law-showcase">
            <div class="law-icon">👩‍⚖️</div><div class="law-title">Definite Proportions</div>
            <div class="law-description">Compounds have fixed element ratios.</div>
          </div>
        </div>

      </div>

      <div class="controls">
        <div class="control-row">
          <button class="control-btn" id="slow-btn" onclick="window.setSpeed(0.5)">🐌 Slow</button>
          <button class="control-btn" id="normal-btn" onclick="window.setSpeed(1)">🚶 Normal</button>
          <button class="control-btn active" id="fast-btn" onclick="window.setSpeed(2)">🏃 Fast</button>
        </div>
        <div class="control-row">
          <button class="control-btn" onclick="window.restartAnimation()">🔄 Restart</button>
          <button class="control-btn" onclick="window.togglePause()" id="pauseBtnEl">▶️ Play</button>
        </div>
      </div>
      <div class="progress-bar" id="progressBarEl"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var currentSceneIdx = 0;
        var isPlaying = false;
        var animationProgress = 0;
        var threeScene, threeCamera, threeRenderer;
        var particles = [];
        var currentZoom = 1;
        var currentSpeed = 2; // Start with fast speed

        var scenes = ${JSON.stringify(configScenes)};
        var sceneDurations = ${JSON.stringify(configDurations)};
        var totalDuration = ${newTotalDuration};

        var explainedHighlightTermIds = [];
        var currentActiveTermId = null;

        var definitionHighlightMap = {
            'definition-highlight-branch': 'highlight-branch',
            'definition-highlight-properties': 'highlight-properties',
            'definition-highlight-composition': ['highlight-composition', 'highlight-structure'],
            'definition-highlight-physical': 'highlight-physical',
            'definition-highlight-chemical': 'highlight-chemical',
            'definition-highlight-laws': 'highlight-laws'
        };

        var contentSceneDetailsMap = {
            'branch-of-science-content': { mainDivId: 'science-tree-content', sectionTitleId: 'section-title-branch' },
            'property-1-content': { mainDivId: 'property-1', sectionTitleId: 'section-title-properties', subtitleId: 'property-subtitle-1' },
            'property-2-content': { mainDivId: 'property-2', sectionTitleId: 'section-title-properties', subtitleId: 'property-subtitle-2' },
            'property-3-content': { mainDivId: 'property-3', sectionTitleId: 'section-title-properties', subtitleId: 'property-subtitle-3' },
            'composition-1-content': { mainDivId: 'composition-1', sectionTitleId: 'section-title-composition', subtitleId: 'composition-subtitle-1' },
            'composition-2-content': { mainDivId: 'composition-2', sectionTitleId: 'section-title-composition', subtitleId: 'composition-subtitle-2' },
            'composition-3-content': { mainDivId: 'composition-3', sectionTitleId: 'section-title-composition', subtitleId: 'composition-subtitle-3' },
            'physical-changes-1-content': { mainDivId: 'physical-changes-1', sectionTitleId: 'section-title-physical', subtitleId: 'physical-subtitle-1' },
            'physical-changes-2-content': { mainDivId: 'physical-changes-2', sectionTitleId: 'section-title-physical', subtitleId: 'physical-subtitle-2' },
            'physical-changes-3-content': { mainDivId: 'physical-changes-3', sectionTitleId: 'section-title-physical', subtitleId: 'physical-subtitle-3' },
            'chemical-changes-1-content': { mainDivId: 'chemical-changes-1', sectionTitleId: 'section-title-chemical' },
            'chemical-changes-2-content': { mainDivId: 'chemical-changes-2', sectionTitleId: 'section-title-chemical' },
            'chemical-changes-3-content': { mainDivId: 'chemical-changes-3', sectionTitleId: 'section-title-chemical' },
            'law-1-content': { mainDivId: 'law-1', sectionTitleId: 'section-title-laws' },
            'law-2-content': { mainDivId: 'law-2', sectionTitleId: 'section-title-laws' },
            'law-3-content': { mainDivId: 'law-3', sectionTitleId: 'section-title-laws' },
            'law-4-content': { mainDivId: 'law-4', sectionTitleId: 'section-title-laws' }
        };

        function initThreeJS_internal() {
            if (threeScene) return;
            threeScene = new THREE.Scene();
            threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            threeRenderer = new THREE.WebGLRenderer({ alpha: true });
            threeRenderer.setSize(window.innerWidth, window.innerHeight);
            threeRenderer.setClearColor(0x000000, 0);
            var canvasContainer = document.getElementById('canvas-container');
            if (canvasContainer) canvasContainer.appendChild(threeRenderer.domElement);
            else { console.error("Canvas container not found!"); return; }
            createParticles_internal();
            threeCamera.position.z = 5;
            animate3D_internal();
        }

        function createParticles_internal() {
            var geometry = new THREE.SphereGeometry(0.015, 6, 6);
            var material = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.6, transparent: true });
            for (var i = 0; i < 30; i++) {
                var particle = new THREE.Mesh(geometry, material);
                particle.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.015, (Math.random() - 0.5) * 0.015, (Math.random() - 0.5) * 0.015),
                    originalPosition: particle.position.clone()
                };
                threeScene.add(particle); particles.push(particle);
            }
        }

        function animate3D_internal() {
            if (!threeScene) return;
            requestAnimationFrame(animate3D_internal);
            particles.forEach(function(p) {
                var sceneName = scenes[currentSceneIdx] || '';
                if (sceneName === 'opening') {
                    var time = Date.now() * 0.001 * currentSpeed;
                    var radius = 1.5 + Math.sin(time * 0.5 + p.userData.originalPosition.x) * 0.3;
                    p.position.x = Math.cos(time + p.userData.originalPosition.x) * radius;
                    p.position.y = Math.sin(time + p.userData.originalPosition.y) * radius;
                    p.position.z = Math.sin(time * 0.7 + p.userData.originalPosition.z) * radius * 0.2;
                } else {
                    var vel = p.userData.velocity.clone().multiplyScalar(currentSpeed);
                    p.position.add(vel);
                    if (Math.abs(p.position.x) > 4) p.userData.velocity.x *= -1;
                    if (Math.abs(p.position.y) > 4) p.userData.velocity.y *= -1;
                    if (Math.abs(p.position.z) > 4) p.userData.velocity.z *= -1;
                }
            });
            if(threeRenderer && threeScene && threeCamera) threeRenderer.render(threeScene, threeCamera);
        }

        function showElementVisually(elementId) {
            var el = document.getElementById(elementId);
            if(el) el.classList.add('visible');
        }

        function hideElementVisually(elementId) {
            var el = document.getElementById(elementId);
            if(el) el.classList.remove('visible');
        }

        function hideAllSceneContent() {
            var allContentIds = ['title', 'main-definition', 'section-title-branch', 'science-tree-content',
                'section-title-properties', 'property-subtitle-1', 'property-1', 'property-subtitle-2', 'property-2', 'property-subtitle-3', 'property-3',
                'section-title-composition', 'composition-subtitle-1', 'composition-1', 'composition-subtitle-2', 'composition-2', 'composition-subtitle-3', 'composition-3',
                'section-title-physical', 'physical-subtitle-1', 'physical-changes-1', 'physical-subtitle-2', 'physical-changes-2', 'physical-subtitle-3', 'physical-changes-3',
                'section-title-chemical', 'chemical-changes-1', 'chemical-changes-2', 'chemical-changes-3',
                'section-title-laws', 'law-1', 'law-2', 'law-3', 'law-4'
            ];
            allContentIds.forEach(hideElementVisually);
            var chemBranch = document.getElementById('chemistry-branch');
            if (chemBranch) chemBranch.classList.remove('active-highlight');
        }

        function updateDefinitionHighlights() {
            var allSpans = document.querySelectorAll('#main-definition .highlight-word');
            allSpans.forEach(function(span) {
                span.classList.remove('active', 'explained');
                if (explainedHighlightTermIds.includes(span.id)) {
                    span.classList.add('explained');
                }
            });

            if (currentActiveTermId) {
                var idsToActivate = Array.isArray(currentActiveTermId) ? currentActiveTermId : [currentActiveTermId];
                idsToActivate.forEach(function(id){
                    var activeElement = document.getElementById(id);
                    if (activeElement) {
                        activeElement.classList.remove('explained');
                        activeElement.classList.add('active');
                    }
                });
            }
        }

        function runScene(sceneIdx) {
            hideAllSceneContent();
            currentActiveTermId = null;

            var sceneName = scenes[sceneIdx];

            if (sceneName === 'opening') {
                showElementVisually('title');
            } else if (sceneName.startsWith('definition-highlight-') || sceneName === 'definition-show-initial' || sceneName === 'final-definition-summary') {
                showElementVisually('main-definition');

                if(sceneName === 'final-definition-summary'){
                    Object.keys(definitionHighlightMap).forEach(function(defSceneKey){
                        var termToExplain = definitionHighlightMap[defSceneKey];
                        var termsToAdd = Array.isArray(termToExplain) ? termToExplain : [termToExplain];
                        termsToAdd.forEach(function(tId){
                            if(tId && !explainedHighlightTermIds.includes(tId)) explainedHighlightTermIds.push(tId);
                        });
                    });
                } else if (definitionHighlightMap[sceneName]) {
                    currentActiveTermId = definitionHighlightMap[sceneName];
                }
                updateDefinitionHighlights();
            } else if (contentSceneDetailsMap[sceneName]) {
                var details = contentSceneDetailsMap[sceneName];
                showElementVisually(details.mainDivId);
                if(details.sectionTitleId) showElementVisually(details.sectionTitleId);
                if(details.subtitleId) showElementVisually(details.subtitleId);

                var prevSceneName = sceneIdx > 0 ? scenes[sceneIdx-1] : null;
                if (prevSceneName && definitionHighlightMap[prevSceneName]) {
                    var termsJustExplained = definitionHighlightMap[prevSceneName];
                    var termsArray = Array.isArray(termsJustExplained) ? termsJustExplained : [termsJustExplained];
                    termsArray.forEach(function(termId){
                        if (termId && !explainedHighlightTermIds.includes(termId)) {
                            explainedHighlightTermIds.push(termId);
                        }
                    });
                }

                if (sceneName === 'branch-of-science-content') {
                    var chemBranchCard = document.getElementById('chemistry-branch');
                    if (chemBranchCard) chemBranchCard.classList.add('active-highlight');
                }
            }
        }

        function updateProgress_internal() {
            if (!isPlaying) return;
            animationProgress += (1/60) * currentSpeed;
            var progressPercentage = (animationProgress / totalDuration) * 100;
            var progressBar = document.getElementById('progressBarEl');
            if(progressBar) progressBar.style.width = Math.min(progressPercentage, 100) + '%';

            var timeAccumulator = 0; var newSceneIdx = 0;
            for (var i = 0; i < sceneDurations.length; i++) {
                if (animationProgress < timeAccumulator + sceneDurations[i]) {
                    newSceneIdx = i; break;
                }
                timeAccumulator += sceneDurations[i];
                if (i === sceneDurations.length - 1 && animationProgress >= totalDuration) {
                    newSceneIdx = i;
                }
            }

            if (newSceneIdx !== currentSceneIdx) {
                currentSceneIdx = newSceneIdx;
                runScene(currentSceneIdx);
            }

            if (animationProgress >= totalDuration && isPlaying) {
                animationProgress = totalDuration;
                isPlaying = false;
                var pauseBtn = document.getElementById('pauseBtnEl');
                if(pauseBtn) pauseBtn.innerHTML = '🔄 Replay';
            }
        }

        window.restartAnimation = function() {
            animationProgress = 0;
            currentSceneIdx = 0;
            explainedHighlightTermIds = [];
            currentActiveTermId = null;
            isPlaying = true; // Auto-start after restart

            var pauseBtn = document.getElementById('pauseBtnEl');
            if(pauseBtn) pauseBtn.innerHTML = '⏸️ Pause';

            var progressBar = document.getElementById('progressBarEl');
            if(progressBar) progressBar.style.width = '0%';
            runScene(0);
        };

        window.togglePause = function() {
            if (animationProgress >= totalDuration) {
                // If at end, restart
                window.restartAnimation();
                return;
            }

            isPlaying = !isPlaying;
            var btn = document.getElementById('pauseBtnEl');
            if(btn) btn.innerHTML = isPlaying ? '⏸️ Pause' : '▶️ Play';
        };

        window.setSpeed = function(speed) {
            currentSpeed = speed;
            // Update button states
            document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            if (speed === 0.5) document.getElementById('slow-btn').classList.add('active');
            else if (speed === 1) document.getElementById('normal-btn').classList.add('active');
            else if (speed === 2) document.getElementById('fast-btn').classList.add('active');
        };

        window.handleControlUpdate = function(control, value) {
            if (control === 'speed') {
                currentSpeed = Math.max(0.1, value);
                window.setSpeed(currentSpeed);
            }
            if (control === 'playPause') {
                if (isPlaying !== value) window.togglePause();
            }
        };

        function onWindowResize_internal() {
            if (threeCamera && threeRenderer) {
                var animContainer = document.getElementById('animation-container');
                if (!animContainer) return;
                var newWidth = animContainer.clientWidth;
                var newHeight = animContainer.clientHeight;

                if (newWidth > 0 && newHeight > 0) {
                    threeCamera.aspect = newWidth / newHeight;
                    threeCamera.updateProjectionMatrix();
                }
                threeRenderer.setSize(animContainer.offsetWidth, animContainer.offsetHeight);
            }
        }

        window.addEventListener('load', function() {
            isPlaying = false; // Start paused

            var pauseBtn = document.getElementById('pauseBtnEl');
            if(pauseBtn) pauseBtn.innerHTML = '▶️ Play';

            initThreeJS_internal();
            runScene(0);
            setInterval(updateProgress_internal, 1000/60);
            window.addEventListener('resize', onWindowResize_internal);
            onWindowResize_internal();

            if (window.ReactNativeWebView && typeof window.ReactNativeWebView.postMessage === 'function') {
                window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'animationReady', payload: { animationId: 'chemistryDefinitionInteractive' }}));
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === ' ' || event.code === 'Space') {
                event.preventDefault();
                window.togglePause();
            } else if (event.key === 'r' || event.key === 'R') {
                window.restartAnimation();
            } else if (event.key === '1') {
                window.setSpeed(0.5);
            } else if (event.key === '2') {
                window.setSpeed(1);
            } else if (event.key === '3') {
                window.setSpeed(2);
            }
        });

    </script>
  </body>
  </html>`
}

---- File Content End ----


=== File: waterFormation.ts ===
Path: data\animations\library\chapter1\waterFormation.ts
---- File Content Start ----
import { AnimationConfig } from '../../types';
import { AnimationFactory } from '../../core/AnimationFactory';
import { baseStyles } from '../../styles/baseStyles';

export const createHydrogenOxygenWater = (): AnimationConfig => {
  return {
    height: 500,
    autoPlay: false,
    loop: false,
    features: {
      temperature: true,
      beforeAfter: true,
      speed: true
    },
    html: `
      ${baseStyles}
      <div id="animation-container" class="chemistry-animation">
        <!-- Container for dynamic content -->
      </div>
      <script>
        // Initialize animation
        const animation = new ReactionAnimation({
          containerId: 'animation-container',
          reaction: {
            reactants: [
              { formula: 'H2', count: 2, position: { x: 150, y: 250 } },
              { formula: 'O2', count: 1, position: { x: 500, y: 250 } }
            ],
            products: [
              { formula: 'H2O', count: 2, position: { x: 300, y: 250 } }
            ],
            activationEnergy: 100,
            effects: ['explosion', 'flame']
          }
        });

        // Handle controls from React Native
        window.addEventListener('message', (event) => {
          const data = JSON.parse(event.data);
          if (data.type === 'controlUpdate') {
            animation.handleControl(data.control, data.value);
          }
        });

        // Auto-start if configured
        if (window.animationState?.isPlaying) {
          animation.play();
        }
      </script>
    `
  };
};

---- File Content End ----


=== File: SafetyService.ts ===
Path: data\animations\services\SafetyService.ts
---- File Content Start ----
import { SafetyConstraints, SafetyStatus } from '../types';

export class SafetyService {
  static checkSafety(
    constraints: SafetyConstraints | undefined,
    currentState: Record<string, any>
  ): SafetyStatus {
    const result: SafetyStatus = {
      isSafe: true,
      warnings: [],
      requiredEquipment: constraints?.requiredEquipment || []
    };

    if (!constraints) return result;

    // Temperature checks
    if (constraints.maxTemperature && currentState.temperature > constraints.maxTemperature) {
      result.isSafe = false;
      result.warnings.push(`Temperature exceeds safe limit (${constraints.maxTemperature}°C)`);
    }

    // Pressure checks
    if (constraints.maxPressure && currentState.pressure > constraints.maxPressure) {
      result.isSafe = false;
      result.warnings.push(`Pressure exceeds safe limit (${constraints.maxPressure}atm)`);
    }

    // Concentration checks
    if (constraints.maxConcentration && currentState.concentration > constraints.maxConcentration) {
      result.isSafe = false;
      result.warnings.push(`Concentration exceeds safe limit (${constraints.maxConcentration}M)`);
    }

    // Hazardous reaction checks
    if (
      constraints.hazardousReactions &&
      constraints.hazardousReactions.includes(currentState.reactionType)
    ) {
      result.warnings.push(`Hazardous reaction: ${currentState.reactionType}`);
    }

    return result;
  }
}

---- File Content End ----


=== File: baseStyles.ts ===
Path: data\animations\styles\baseStyles.ts
---- File Content Start ----
export const baseStyles = `
<style>
  /* Base animation container */
  .chemistry-animation {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background: linear-gradient(180deg, #0f0f23 0%, #1a1a3e 100%);
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  }

  /* Atom styles */
  .atom {
    position: absolute;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(255,255,255,0.3);
  }

  .atom:hover {
    transform: scale(1.1);
    z-index: 10;
  }

  /* Bond styles */
  .bond {
    position: absolute;
    background: #4ecdc4;
    transform-origin: left center;
    transition: all 0.5s ease;
  }

  .bond-single { height: 3px; }
  .bond-double { height: 6px; box-shadow: 0 3px 0 #4ecdc4; }
  .bond-triple { height: 9px; box-shadow: 0 3px 0 #4ecdc4, 0 6px 0 #4ecdc4; }
  .bond-ionic {
    height: 3px;
    background: repeating-linear-gradient(
      90deg,
      #4ecdc4 0,
      #4ecdc4 5px,
      transparent 5px,
      transparent 10px
    );
  }

  /* Include other shared styles... */
</style>
`;

---- File Content End ----


=== File: DissolutionTemplate.ts ===
Path: data\animations\templates\DissolutionTemplate.ts
---- File Content Start ----
// src/data/animations/templates/DissolutionTemplate.ts
export class DissolutionAnimationTemplate extends ChemistryAnimationEngine {
  private soluteType: string;
  private solventType: string;
  private saturationPoint: number;
  private currentAmount: number = 0;
  private soluteParticles: HTMLElement[] = [];
  private solventMolecules: HTMLElement[] = [];
  private dissolvedParticles: HTMLElement[] = [];

  constructor(
    containerId: string,
    soluteType: string = 'NaCl',
    solventType: string = 'H2O',
    saturationPoint: number = 36 // g per 100g water
  ) {
    super(containerId);
    this.soluteType = soluteType;
    this.solventType = solventType;
    this.saturationPoint = saturationPoint;
    this.setupContainer();
    this.createSolvent();
  }

  private setupContainer(): void {
    // Create beaker visual
    const beaker = document.createElement('div');
    beaker.className = 'beaker';
    beaker.style.cssText = `
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 400px;
      border: 3px solid rgba(255,255,255,0.3);
      border-bottom: 5px solid rgba(255,255,255,0.4);
      border-radius: 0 0 20px 20px;
      background: linear-gradient(
        180deg,
        transparent 0%,
        rgba(66, 165, 245, 0.1) 30%,
        rgba(66, 165, 245, 0.2) 100%
      );
    `;
    this.container.appendChild(beaker);

    // Create measurement marks
    for (let i = 1; i <= 4; i++) {
      const mark = document.createElement('div');
      mark.style.cssText = `
        position: absolute;
        left: -20px;
        bottom: ${i * 80}px;
        width: 10px;
        height: 2px;
        background: rgba(255,255,255,0.5);
      `;
      beaker.appendChild(mark);

      const label = document.createElement('div');
      label.textContent = `${i * 25}mL`;
      label.style.cssText = `
        position: absolute;
        left: -60px;
        bottom: ${i * 80 - 10}px;
        color: rgba(255,255,255,0.7);
        font-size: 12px;
      `;
      beaker.appendChild(label);
    }

    // Saturation indicator
    const saturationIndicator = document.createElement('div');
    saturationIndicator.className = 'saturation-indicator';
    saturationIndicator.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      color: white;
    `;
    saturationIndicator.innerHTML = `
      <h4>Saturation Level</h4>
      <div class="saturation-bar" style="
        width: 200px;
        height: 20px;
        background: rgba(255,255,255,0.2);
        border-radius: 10px;
        overflow: hidden;
        margin-top: 10px;
      ">
        <div class="saturation-fill" id="saturation-fill" style="
          width: 0%;
          height: 100%;
          background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
          transition: width 0.5s ease;
        "></div>
      </div>
      <p id="saturation-text" style="margin-top: 10px; font-size: 14px;">
        0g / ${this.saturationPoint}g
      </p>
    `;
    this.container.appendChild(saturationIndicator);
  }

  private createSolvent(): void {
    // Create water molecules
    const beakerBounds = {
      left: this.container.offsetWidth / 2 - 150,
      right: this.container.offsetWidth / 2 + 150,
      top: this.container.offsetHeight - 350,
      bottom: this.container.offsetHeight - 50
    };

    for (let i = 0; i < 30; i++) {
      const water = this.createWaterMolecule(
        Math.random() * (beakerBounds.right - beakerBounds.left) + beakerBounds.left,
        Math.random() * (beakerBounds.bottom - beakerBounds.top) + beakerBounds.top
      );
      this.solventMolecules.push(water);
      this.addWaterMotion(water, beakerBounds);
    }
  }

  private createWaterMolecule(x: number, y: number): HTMLElement {
    const water = document.createElement('div');
    water.className = 'water-molecule';
    water.style.cssText = `
      position: absolute;
      left: ${x}px;
      top: ${y}px;
      width: 40px;
      height: 35px;
      opacity: 0.7;
    `;

    water.innerHTML = `
      <svg viewBox="0 0 40 35" xmlns="http://www.w3.org/2000/svg">
        <circle cx="20" cy="15" r="8" fill="#FF6B6B" opacity="0.8"/>
        <circle cx="12" cy="25" r="5" fill="#FFFFFF" opacity="0.8"/>
        <circle cx="28" cy="25" r="5" fill="#FFFFFF" opacity="0.8"/>
        <line x1="20" y1="15" x2="12" y2="25" stroke="#4ECDC4" stroke-width="2" opacity="0.6"/>
        <line x1="20" y1="15" x2="28" y2="25" stroke="#4ECDC4" stroke-width="2" opacity="0.6"/>
      </svg>
    `;

    this.container.appendChild(water);
    return water;
  }

  private addWaterMotion(water: HTMLElement, bounds: any): void {
    let angle = Math.random() * Math.PI * 2;
    let speed = 0.5 + Math.random() * 0.5;

    const animate = () => {
      angle += 0.02;
      const x = parseFloat(water.style.left) + Math.cos(angle) * speed;
      const y = parseFloat(water.style.top) + Math.sin(angle) * speed * 0.5;

      // Keep within bounds
      if (x < bounds.left || x > bounds.right - 40) speed *= -1;
      if (y < bounds.top || y > bounds.bottom - 35) speed *= -1;

      water.style.left = `${x}px`;
      water.style.top = `${y}px`;

      requestAnimationFrame(animate);
    };

    animate();
  }

  public async addSolute(amount: number = 5): Promise<void> {
    if (this.currentAmount >= this.saturationPoint) {
      await this.showSaturationMessage();
      return;
    }

    const actualAmount = Math.min(amount, this.saturationPoint - this.currentAmount);
    this.currentAmount += actualAmount;

    // Update saturation indicator
    this.updateSaturationIndicator();

    // Create solute crystal
    const crystal = this.createSoluteCrystal();
    await this.dropCrystal(crystal);

    // Dissolve or settle based on saturation
    if (this.currentAmount <= this.saturationPoint) {
      await this.dissolveCrystal(crystal);
    } else {
      await this.settleCrystal(crystal);
    }
  }

  private createSoluteCrystal(): HTMLElement {
    const crystal = document.createElement('div');
    crystal.className = 'solute-crystal';

    if (this.soluteType === 'NaCl') {
      // Salt crystal - cubic structure
      crystal.style.cssText = `
        position: absolute;
        left: ${this.container.offsetWidth / 2 - 20}px;
        top: 50px;
        width: 40px;
        height: 40px;
        background: linear-gradient(45deg, #FFFFFF 25%, #E0E0E0 50%, #FFFFFF 75%);
        border: 1px solid #CCCCCC;
        transform: rotate(45deg);
      `;
    } else if (this.soluteType === 'sugar') {
      // Sugar crystal - more irregular
      crystal.style.cssText = `
        position: absolute;
        left: ${this.container.offsetWidth / 2 - 20}px;
        top: 50px;
        width: 35px;
        height: 35px;
        background: radial-gradient(circle at 30% 30%, #FFFFFF, #F5F5DC);
        border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
      `;
    }

    this.container.appendChild(crystal);
    return crystal;
  }

  private async dropCrystal(crystal: HTMLElement): Promise<void> {
    const targetY = this.container.offsetHeight - 250;
    await this.animateMove(crystal, parseFloat(crystal.style.left), targetY, 1000);
  }

  private async dissolveCrystal(crystal: HTMLElement): Promise<void> {
    // Create ion/molecule particles
    const particles = this.soluteType === 'NaCl' ?
      await this.createIons(crystal) :
      await this.createMolecules(crystal);

    // Fade out crystal
    await this.animateFade(crystal, 0, 500);
    crystal.remove();

    // Disperse particles
    await this.disperseParticles(particles);
  }

  private async createIons(crystal: HTMLElement): Promise<HTMLElement[]> {
    const ions: HTMLElement[] = [];
    const x = parseFloat(crystal.style.left);
    const y = parseFloat(crystal.style.top);

    // Create Na+ and Cl- ions
    for (let i = 0; i < 4; i++) {
      const isNa = i % 2 === 0;
      const ion = document.createElement('div');
      ion.className = isNa ? 'na-ion' : 'cl-ion';
      ion.style.cssText = `
        position: absolute;
        left: ${x + 20}px;
        top: ${y + 20}px;
        width: ${isNa ? 25 : 30}px;
        height: ${isNa ? 25 : 30}px;
        border-radius: 50%;
        background: ${isNa ? '#FFD700' : '#00FF00'};
        color: ${isNa ? '#000' : '#FFF'};
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        opacity: 0;
        transform: scale(0);
      `;
      ion.textContent = isNa ? 'Na+' : 'Cl-';

      this.container.appendChild(ion);
      ions.push(ion);
      this.dissolvedParticles.push(ion);

      // Animate appearance
      setTimeout(() => {
        ion.style.transition = 'all 0.5s ease';
        ion.style.opacity = '1';
        ion.style.transform = 'scale(1)';
      }, i * 100);
    }

    return ions;
  }

  private async disperseParticles(particles: HTMLElement[]): Promise<void> {
    const beakerBounds = {
      left: this.container.offsetWidth / 2 - 130,
      right: this.container.offsetWidth / 2 + 130,
      top: this.container.offsetHeight - 350,
      bottom: this.container.offsetHeight - 80
    };

    particles.forEach((particle, index) => {
      setTimeout(() => {
        const targetX = Math.random() * (beakerBounds.right - beakerBounds.left) + beakerBounds.left;
        const targetY = Math.random() * (beakerBounds.bottom - beakerBounds.top) + beakerBounds.top;

        this.animateMove(particle, targetX, targetY, 1500);

        // Add floating motion
        this.addParticleMotion(particle, beakerBounds);
      }, index * 200);
    });
  }

  private addParticleMotion(particle: HTMLElement, bounds: any): void {
    let angle = Math.random() * Math.PI * 2;

    const animate = () => {
      angle += 0.03;
      const baseX = parseFloat(particle.dataset.targetX || particle.style.left);
      const baseY = parseFloat(particle.dataset.targetY || particle.style.top);

      const offsetX = Math.sin(angle) * 15;
      const offsetY = Math.cos(angle * 1.5) * 10;

      particle.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1)`;

      requestAnimationFrame(animate);
    };

    setTimeout(animate, 2000);
  }

  private async settleCrystal(crystal: HTMLElement): Promise<void> {
    // Crystal settles at bottom as undissolved
    const bottomY = this.container.offsetHeight - 60;
    await this.animateMove(
      crystal,
      parseFloat(crystal.style.left) + (Math.random() - 0.5) * 50,
      bottomY,
      1000
    );

    this.soluteParticles.push(crystal);
  }

  private updateSaturationIndicator(): void {
    const percentage = (this.currentAmount / this.saturationPoint) * 100;
    const fill = document.getElementById('saturation-fill');
    const text = document.getElementById('saturation-text');

    if (fill) fill.style.width = `${Math.min(percentage, 100)}%`;
    if (text) text.textContent = `${this.currentAmount}g / ${this.saturationPoint}g`;
  }

  private async showSaturationMessage(): Promise<void> {
    const message = document.createElement('div');
    message.className = 'saturation-message';
    message.textContent = 'Solution is saturated! No more solute can dissolve.';
    message.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(244, 67, 54, 0.9);
      color: white;
      padding: 20px 30px;
      border-radius: 10px;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
    `;

    this.container.appendChild(message);

    setTimeout(() => message.style.opacity = '1', 100);
    setTimeout(() => {
      message.style.opacity = '0';
      setTimeout(() => message.remove(), 500);
    }, 3000);
  }

  public async play(): Promise<void> {
    // Demonstrate dissolution process
    for (let i = 0; i < 8; i++) {
      await this.addSolute(5);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }

  public reset(): void {
    // Clear all particles
    this.dissolvedParticles.forEach(p => p.remove());
    this.soluteParticles.forEach(p => p.remove());
    this.dissolvedParticles = [];
    this.soluteParticles = [];
    this.currentAmount = 0;
    this.updateSaturationIndicator();
  }

  protected showAtomProperties(atom: HTMLElement): void {
    // Show properties of clicked particle
  }
}

---- File Content End ----


=== File: ReactionTemplate.ts ===
Path: data\animations\templates\ReactionTemplate.ts
---- File Content Start ----
// src/data/animations/templates/ReactionTemplate.ts
export interface ReactionConfig {
  reactants: Array<{
    formula: string;
    count: number;
    position: { x: number; y: number };
  }>;
  products: Array<{
    formula: string;
    count: number;
    position: { x: number; y: number };
  }>;
  activationEnergy?: number;
  reactionType: 'combustion' | 'synthesis' | 'decomposition' | 'displacement';
  effects?: Array<'flame' | 'explosion' | 'bubble' | 'spark'>;
}

export class ReactionAnimationTemplate extends ChemistryAnimationEngine {
  private config: ReactionConfig;
  private equationDisplay: HTMLElement;
  private infoPanel: HTMLElement;

  constructor(containerId: string, config: ReactionConfig) {
    super(containerId);
    this.config = config;
    this.setupUI();
    this.createInitialState();
  }

  private setupUI(): void {
    // Create equation display
    this.equationDisplay = document.createElement('div');
    this.equationDisplay.className = 'equation-display';
    this.equationDisplay.style.cssText = `
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 15px 25px;
      border-radius: 10px;
      color: white;
      font-size: 20px;
      font-family: 'Courier New', monospace;
    `;

    // Build equation string
    const reactantStrings = this.config.reactants.map(r =>
      r.count > 1 ? `${r.count}${r.formula}` : r.formula
    );
    const productStrings = this.config.products.map(p =>
      p.count > 1 ? `${p.count}${p.formula}` : p.formula
    );

    this.equationDisplay.innerHTML = `
      <span class="reactants">${reactantStrings.join(' + ')}</span>
      <span class="arrow"> → </span>
      <span class="products">${productStrings.join(' + ')}</span>
    `;

    this.container.appendChild(this.equationDisplay);

    // Create info panel
    this.infoPanel = document.createElement('div');
    this.infoPanel.className = 'info-panel';
    this.infoPanel.style.cssText = `
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 10px;
      color: white;
      max-width: 250px;
    `;
    this.container.appendChild(this.infoPanel);
  }

  private createInitialState(): void {
    // Create reactant molecules
    this.config.reactants.forEach((reactant, index) => {
      for (let i = 0; i < reactant.count; i++) {
        const id = `reactant-${index}-${i}`;
        const offsetX = i * 100;
        const offsetY = index * 100;

        this.createMolecule(
          reactant.formula,
          reactant.position.x + offsetX,
          reactant.position.y + offsetY,
          id
        );
      }
    });
  }

  public async play(): Promise<void> {
    this.animationState = 'playing';

    // Show activation energy requirement
    if (this.config.activationEnergy) {
      await this.showActivationEnergy();
    }

    // Move reactants to center
    await this.moveReactantsToCenter();

    // Show reaction effects
    if (this.config.effects) {
      await this.showReactionEffects();
    }

    // Transform to products
    await this.transformToProducts();

    this.animationState = 'complete';
  }

  private async showActivationEnergy(): Promise<void> {
    const button = document.createElement('button');
    button.className = 'activation-button';
    button.textContent = '🔥 Provide Activation Energy';
    button.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff6b6b 0%, #ff8787 100%);
      border: none;
      color: white;
      padding: 15px 30px;
      border-radius: 30px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255,107,107,0.3);
    `;

    this.container.appendChild(button);

    return new Promise(resolve => {
      button.addEventListener('click', () => {
        button.remove();
        resolve();
      });
    });
  }

  private async moveReactantsToCenter(): Promise<void> {
    const centerX = this.container.offsetWidth / 2;
    const centerY = this.container.offsetHeight / 2;

    const movePromises: Promise<void>[] = [];

    this.molecules.forEach((molecule) => {
      movePromises.push(
        this.animateMove(molecule, centerX - 50, centerY - 50, 1500)
      );
    });

    await Promise.all(movePromises);
  }

  private async showReactionEffects(): Promise<void> {
    for (const effect of this.config.effects!) {
      switch (effect) {
        case 'explosion':
          await this.showExplosion();
          break;
        case 'flame':
          await this.showFlame();
          break;
        case 'spark':
          await this.showSpark();
          break;
        case 'bubble':
          await this.showBubbles();
          break;
      }
    }
  }

  private async showExplosion(): Promise<void> {
    const explosion = document.createElement('div');
    explosion.className = 'explosion-effect';
    explosion.style.cssText = `
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      background: radial-gradient(circle,
        rgba(255,255,0,0.8) 0%,
        rgba(255,140,0,0.6) 40%,
        transparent 70%
      );
      border-radius: 50%;
      opacity: 0;
    `;

    this.container.appendChild(explosion);

    // Animate explosion
    await this.animateScale(explosion, 5, 600);
    await this.animateFade(explosion, 0, 400);

    explosion.remove();
  }

  private async transformToProducts(): Promise<void> {
    // Fade out reactants
    const fadePromises: Promise<void>[] = [];
    this.molecules.forEach(molecule => {
      fadePromises.push(this.animateFade(molecule, 0, 500));
    });
    await Promise.all(fadePromises);

    // Remove reactant molecules
    this.molecules.forEach(molecule => molecule.remove());
    this.molecules.clear();

    // Create product molecules
    this.config.products.forEach((product, index) => {
      for (let i = 0; i < product.count; i++) {
        const id = `product-${index}-${i}`;
        const offsetX = i * 120;
        const offsetY = index * 100;

        const molecule = this.createMolecule(
          product.formula,
          product.position.x + offsetX,
          product.position.y + offsetY,
          id
        );

        // Start invisible
        molecule.style.opacity = '0';
        molecule.style.transform = 'scale(0)';

        // Animate in
        setTimeout(() => {
          this.animateScale(molecule, 1, 500);
          this.animateFade(molecule, 1, 500);
        }, i * 200);
      }
    });
  }

  public reset(): void {
    // Clear all elements
    this.atoms.forEach(atom => atom.remove());
    this.bonds.forEach(bond => bond.remove());
    this.molecules.forEach(molecule => molecule.remove());

    this.atoms.clear();
    this.bonds.clear();
    this.molecules.clear();

    // Reset state
    this.animationState = 'idle';

    // Recreate initial state
    this.createInitialState();
  }

  protected showAtomProperties(atom: HTMLElement): void {
    const element = atom.dataset.element!;
    const elementData = ChemicalElement.get(element);

    this.infoPanel.innerHTML = `
      <h3>${elementData.name}</h3>
      ${elementData.properties.map(prop => `<p>• ${prop}</p>`).join('')}
    `;
  }

  // Additional effect methods
  private async showFlame(): Promise<void> {
    // Implementation for flame effect
  }

  private async showSpark(): Promise<void> {
    // Implementation for spark effect
  }

  private async showBubbles(): Promise<void> {
    // Implementation for bubble effect
  }
}

---- File Content End ----


=== File: StateChangeTemplate.ts ===
Path: data\animations\templates\StateChangeTemplate.ts
---- File Content Start ----
// src/data/animations/templates/StateChangeTemplate.ts
export class StateChangeAnimationTemplate extends ChemistryAnimationEngine {
  private particles: HTMLElement[] = [];
  private currentState: 'solid' | 'liquid' | 'gas';
  private substance: string;
  private particleCount: number = 50;

  constructor(
    containerId: string,
    substance: string,
    initialState: 'solid' | 'liquid' | 'gas' = 'solid'
  ) {
    super(containerId);
    this.substance = substance;
    this.currentState = initialState;
    this.createParticles();
    this.arrangeParticles(initialState);
  }

  private createParticles(): void {
    const element = this.substance; // Assuming single element for simplicity
    const elementData = ChemicalElement.get(element);

    for (let i = 0; i < this.particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'state-particle';
      particle.style.cssText = `
        position: absolute;
        width: 30px;
        height: 30px;
        background: radial-gradient(circle at 30% 30%,
          ${this.lightenColor(elementData.color)},
          ${elementData.color}
        );
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: ${this.getTextColor(elementData.color)};
        transition: all 0.5s ease;
      `;
      particle.textContent = element;

      this.particles.push(particle);
      this.container.appendChild(particle);
    }
  }

  private arrangeParticles(state: 'solid' | 'liquid' | 'gas'): void {
    const containerWidth = this.container.offsetWidth;
    const containerHeight = this.container.offsetHeight;

    this.particles.forEach((particle, index) => {
      let x: number, y: number;

      switch (state) {
        case 'solid':
          // Grid arrangement
          const cols = Math.ceil(Math.sqrt(this.particleCount));
          const row = Math.floor(index / cols);
          const col = index % cols;
          x = (containerWidth / cols) * col + 50;
          y = (containerHeight / cols) * row + 50;

          // Add small vibration
          this.addVibration(particle, 2);
          break;

        case 'liquid':
          // Loose arrangement with flow
          x = Math.random() * (containerWidth - 100) + 50;
          y = containerHeight - 100 - (Math.random() * 200);

          // Add flowing motion
          this.addFlowingMotion(particle);
          break;

        case 'gas':
          // Random positions
          x = Math.random() * (containerWidth - 50);
          y = Math.random() * (containerHeight - 50);

          // Add rapid random motion
          this.addRandomMotion(particle);
          break;
      }

      particle.style.left = `${x}px`;
      particle.style.top = `${y}px`;
    });
  }

  private addVibration(particle: HTMLElement, amplitude: number): void {
    const baseX = parseFloat(particle.style.left);
    const baseY = parseFloat(particle.style.top);

    const animate = () => {
      if (this.currentState === 'solid') {
        const offsetX = (Math.random() - 0.5) * amplitude;
        const offsetY = (Math.random() - 0.5) * amplitude;
        particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        requestAnimationFrame(animate);
      }
    };

    animate();
  }

  private addFlowingMotion(particle: HTMLElement): void {
    let angle = Math.random() * Math.PI * 2;

    const animate = () => {
      if (this.currentState === 'liquid') {
        angle += 0.02;
        const offsetX = Math.sin(angle) * 20;
        const offsetY = Math.cos(angle * 0.5) * 10;
        particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        requestAnimationFrame(animate);
      }
    };

    animate();
  }

  private addRandomMotion(particle: HTMLElement): void {
    let velocityX = (Math.random() - 0.5) * 4;
    let velocityY = (Math.random() - 0.5) * 4;

    const animate = () => {
      if (this.currentState === 'gas') {
        let x = parseFloat(particle.style.left);
        let y = parseFloat(particle.style.top);

        x += velocityX;
        y += velocityY;

        // Bounce off walls
        // Bounce off walls
       if (x < 0 || x > this.container.offsetWidth - 30) {
         velocityX *= -1;
       }
       if (y < 0 || y > this.container.offsetHeight - 30) {
         velocityY *= -1;
       }

       particle.style.left = `${x}px`;
       particle.style.top = `${y}px`;

       requestAnimationFrame(animate);
     }
   };

   animate();
 }

 public async transitionTo(newState: 'solid' | 'liquid' | 'gas'): Promise<void> {
   this.animationState = 'playing';
   this.currentState = newState;

   // Show transition effects
   await this.showTransitionEffect(this.currentState, newState);

   // Rearrange particles
   this.arrangeParticles(newState);

   this.animationState = 'idle';
 }

 private async showTransitionEffect(
   fromState: 'solid' | 'liquid' | 'gas',
   toState: 'solid' | 'liquid' | 'gas'
 ): Promise<void> {
   const effectMap = {
     'solid-liquid': 'melting',
     'liquid-gas': 'boiling',
     'gas-liquid': 'condensation',
     'liquid-solid': 'freezing',
     'solid-gas': 'sublimation',
     'gas-solid': 'deposition'
   };

   const transitionKey = `${fromState}-${toState}`;
   const effect = effectMap[transitionKey];

   if (effect) {
     await this.displayTransitionLabel(effect);
   }
 }

 private async displayTransitionLabel(label: string): Promise<void> {
   const labelElement = document.createElement('div');
   labelElement.className = 'transition-label';
   labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
   labelElement.style.cssText = `
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background: rgba(0,0,0,0.8);
     color: white;
     padding: 20px 40px;
     border-radius: 10px;
     font-size: 24px;
     font-weight: bold;
     opacity: 0;
     transition: opacity 0.5s ease;
   `;

   this.container.appendChild(labelElement);

   // Animate in
   setTimeout(() => labelElement.style.opacity = '1', 100);

   // Hold
   await new Promise(resolve => setTimeout(resolve, 2000));

   // Animate out
   labelElement.style.opacity = '0';
   setTimeout(() => labelElement.remove(), 500);
 }

 public async play(): Promise<void> {
   // Cycle through states
   await this.transitionTo('liquid');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('gas');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('liquid');
   await new Promise(resolve => setTimeout(resolve, 3000));
   await this.transitionTo('solid');
 }

 public reset(): void {
   this.currentState = 'solid';
   this.arrangeParticles('solid');
 }

 protected showAtomProperties(atom: HTMLElement): void {
   // Not implemented for state changes
 }
}

---- File Content End ----


=== File: useFetch.ts ===
Path: hooks\useFetch.ts
---- File Content Start ----
import { useEffect, useState, useCallback } from 'react';

type UseFetchResult<T> = {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
};

export function useFetch<T>(fetcher: () => Promise<T>): UseFetchResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await fetcher();
      setData(result);
    } catch (err: any) {
      console.error(err);
      setError(err.message || 'Something went wrong while fetching data.');
    } finally {
      setLoading(false);
    }
  }, [fetcher]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

---- File Content End ----


=== File: AppNavigator.tsx ===
Path: layouts\AppNavigator.tsx
---- File Content Start ----
// navigation/AppNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import BookListScreen from '@/screens/BookListScreen';
import ChapterListScreen from '@/screens/ChapterListScreen';
import TopicListScreen from '@/screens/TopicListScreen';
import ContentScreen from '@/screens/ContentScreen';

export type RootStackParamList = {
  Books: undefined;
  Chapters: { bookId: number };
  Topics: { chapterId: number };
  Content: { topicId: number }; // optional future screen
};

const Stack = createNativeStackNavigator<RootStackParamList>();

const AppNavigator = () => (
  <NavigationContainer>
    <Stack.Navigator initialRouteName="Books">
      <Stack.Screen name="Books" component={BookListScreen} options={{ title: 'LearnSpark 📚' }} />
      <Stack.Screen name="Chapters" component={ChapterListScreen} options={{ title: 'Chapters' }} />
      <Stack.Screen name="Topics" component={TopicListScreen} options={{ title: 'Topics' }} />
      <Stack.Screen name="Content" component={ContentScreen} />
    </Stack.Navigator>
  </NavigationContainer>
);

export default AppNavigator;

---- File Content End ----


=== File: RootNavigator.tsx ===
Path: layouts\RootNavigator.tsx
---- File Content Start ----
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import BookListScreen from '@/screens/BookListScreen';
import ChapterListScreen from '@/screens/ChapterListScreen'; // create later

export type RootStackParamList = {
  BookList: undefined;
  Chapter: { bookId: string; chapterId: string };
};

const Stack = createNativeStackNavigator<RootStackParamList>();

export default function RootNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="BookList" component={BookListScreen} />
        <Stack.Screen name="Chapter" component={ChapterListScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

---- File Content End ----


=== File: designSystem.ts ===
Path: lib\designSystem.ts
---- File Content Start ----
// ============================================
// COMPLETE DESIGN SYSTEM
// ============================================

// 1. BASE COLORS
export const brandColors = {
  primary: {
    main: '#2563eb',
    dark: '#1e40af',
    light: '#3b82f6',
    lighter: '#dbeafe',
    lightest: '#eff6ff',
  },
  secondary: {
    main: '#059669',
    dark: '#047857',
    light: '#10b981',
    lighter: '#d1fae5',
    lightest: '#ecfdf5',
  },
  accent: {
    main: '#7c3aed',
    dark: '#6d28d9',
    light: '#8b5cf6',
    lighter: '#e0e7ff',
    lightest: '#f3f4f6',
  },
  neutral: {
    dark: '#1f2937',
    main: '#6b7280',
    light: '#9ca3af',
    lighter: '#f3f4f6',
    lightest: '#fafafa',
  },
    danger: {
    main: '#dc2626',     // Strong red for immediate attention
    dark: '#b91c1c',     // Darker for pressed states
    light: '#ef4444',    // Lighter for subtle indicators
    lighter: '#fee2e2',  // Very light for backgrounds
    lightest: '#fef2f2', // Lightest for subtle notifications
  },
  warning: {
    main: '#f59e0b',     // Vibrant amber for warnings
    dark: '#d97706',     // Darker for emphasis
    light: '#fbbf24',    // Lighter for less critical warnings
    lighter: '#fef3c7',  // Very light for backgrounds
    lightest: '#fffbeb', // Lightest for subtle hints
  },
  success: '#10b981',
  error: '#dc2626',
  background: '#f8fafc',
} as const;

// 2. TYPOGRAPHY
export const typography = {
  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    '2xl': 24,
    '3xl': 30,
  },
  fontWeight: {
    normal: '400' as const,
    medium: '500' as const,
    semibold: '600' as const,
    bold: '700' as const,
  },
  lineHeight: {
    tight: 1.2,
    normal: 1.4,
    relaxed: 1.6,
  },
} as const;

// 3. SPACING
export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 20,
  xl: 24,
  '2xl': 32,
  '3xl': 48,
} as const;

// 4. LAYOUT
export const layout = {
  borderRadius: {
    sm: 4,
    md: 8,
    lg: 12,
    xl: 16,
  },
  containerPadding: spacing.md,
} as const;

// 5. SHADOW UTILITY
export const createShadow = (elevation: number) => ({
  shadowColor: '#000000',
  shadowOffset: {
    width: 0,
    height: elevation,
  },
  shadowOpacity: 0.1 + (elevation * 0.02),
  shadowRadius: elevation * 2,
  elevation: elevation * 2,
});

// 6. SCREEN-SPECIFIC STYLES
export const screenStyles = {
  // Common container for all screens
  container: {
    flexGrow: 1,
    backgroundColor: brandColors.background,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.lg,
  },

  // Screen headers/titles
  screenHeader: {
    fontSize: typography.fontSize['2xl'],
    fontWeight: typography.fontWeight.bold,
    color: brandColors.neutral.dark,
    marginBottom: spacing.lg,
    textAlign: 'center' as const,
  },

  // List items for navigation screens
  listItem: {
    backgroundColor: '#ffffff',
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    marginBottom: spacing.sm,
    borderRadius: layout.borderRadius.lg,
    borderLeftWidth: 4,
    ...createShadow(2),
  },

  listItemText: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.medium,
    color: brandColors.neutral.dark,
    lineHeight: typography.lineHeight.normal * typography.fontSize.lg,
  },

  // Loading and error states
  centeredContainer: {
    flex: 1,
    justifyContent: 'center' as const,
    alignItems: 'center' as const,
    backgroundColor: brandColors.background,
    paddingHorizontal: spacing.lg,
  },

  errorText: {
    fontSize: typography.fontSize.lg,
    color: brandColors.error,
    textAlign: 'center' as const,
    fontWeight: typography.fontWeight.medium,
  },

  emptyText: {
    fontSize: typography.fontSize.lg,
    color: brandColors.neutral.main,
    textAlign: 'center' as const,
    fontWeight: typography.fontWeight.medium,
  },
} as const;

// 7. SECTION STYLING (for ContentScreen)
export const sectionColorPalette = {
  coreDefinition: {
    header: '#1e40af',
    emoji: '🔑'
  },
  explanation: {
    header: '#2563eb',
    emoji: '💡'
  },
  examples: {
    header: '#059669',
    emoji: '🔍'
  },
  analogies: {
    header: '#0d9488',
    emoji: '🧩'
  },
  interactive: {
    header: '#065f46',
    emoji: '🎯'
  },
  exercises: {
    header: '#ea580c',
    emoji: '💪'
  },
  summary: {
    header: '#7c3aed',
    emoji: '📌'
  },
  connections: {
    header: '#6d28d9',
    emoji: '🔗'
  },
  funFacts: {
    header: '#6b7280',
    emoji: '🎉'
  },
  default: {
    header: '#4b5563',
    emoji: '📄'
  }
} as const;

// 8. SECTION MAPPING
const sectionTypeMapping: Record<string, keyof typeof sectionColorPalette> = {
  'CORE_DEFINITION': 'coreDefinition',
  'DEFINITION': 'coreDefinition',
  'EXPLANATION': 'explanation',
  'EXAMPLES': 'examples',
  'ANALOGIES_&_VISUALIZATIONS': 'analogies',
  'ANALOGIES_VISUALIZATIONS': 'analogies',
  'INTERACTIVE_ELEMENTS': 'interactive',
  'EXERCISES': 'exercises',
  'KEY_POINTS_&_SUMMARY': 'summary',
  'KEY_POINTS_SUMMARY': 'summary',
  'SUMMARY': 'summary',
  'CONNECTIONS': 'connections',
  'FUN_FACTS_&_TRIVIA': 'funFacts',
  'FUN_FACTS_TRIVIA': 'funFacts'
};

// 9. SECTION STYLING FUNCTIONS
export const getSectionStyles = (normalizedTitle: string) => {
  const sectionType = sectionTypeMapping[normalizedTitle] || 'default';
  const colorScheme = sectionColorPalette[sectionType];

  return {
    headerBgColor: colorScheme.header,
    headerTextColor: '#ffffff',
    iconEmoji: colorScheme.emoji,
    contentBgColor: '#ffffff',
    contentTextColor: '#374151',
    shadowColor: '#000000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 6,
    borderRadius: 12,
  };
};

export const getContentBackground = (normalizedTitle: string): string => {
  switch (normalizedTitle) {
    case 'KEY_POINTS_&_SUMMARY':
    case 'KEY_POINTS_SUMMARY':
    case 'SUMMARY':
      return '#f8fafc';
    case 'FUN_FACTS_&_TRIVIA':
    case 'FUN_FACTS_TRIVIA':
      return '#fefce8';
    case 'EXERCISES':
      return '#fefdf2';
    default:
      return '#ffffff';
  }
};

// 10. ENHANCED COMPONENT STYLES
export const enhancedComponentStyles = {
  sectionCard: {
    marginBottom: 16,
    borderRadius: 12,
    overflow: 'hidden',
    backgroundColor: '#ffffff',
    ...createShadow(3),
  },
  sectionHeader: {
    flexDirection: 'row' as const,
    alignItems: 'center' as const,
    paddingHorizontal: 20,
    paddingVertical: 16,
    minHeight: 64,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700' as const,
    color: '#ffffff',
    flex: 1,
    marginLeft: 12,
    letterSpacing: 0.5,
  },
  sectionContent: {
    paddingHorizontal: 20,
    paddingVertical: 16,
    backgroundColor: '#ffffff',
  },
  contentText: {
    fontSize: 16,
    lineHeight: 24,
    color: '#374151',
    marginBottom: 12,
  },
  listItem: {
    flexDirection: 'row' as const,
    alignItems: 'flex-start' as const,
    marginBottom: 8,
  },
  listBullet: {
    fontSize: 16,
    color: '#6b7280',
    marginRight: 8,
    marginTop: 2,
  },
  listText: {
    fontSize: 16,
    lineHeight: 24,
    color: '#374151',
    flex: 1,
  },
} as const;

---- File Content End ----


=== File: getBooks.ts ===
Path: lib\api\getBooks.ts
---- File Content Start ----
// lib/api/getBooks.ts
import { supabase } from './supabase';

export async function getBooks() {
  const { data, error } = await supabase
    .from('books')
    .select('book_pk, title')
    .order('book_pk');

  if (error) throw new Error(error.message);
  return data ?? [];
}

---- File Content End ----


=== File: getChapters.ts ===
Path: lib\api\getChapters.ts
---- File Content Start ----
import { supabase } from './supabase'; // or '@/lib/api/supabase' depending on your path

export async function getChapters(bookId: number) {
  const { data, error } = await supabase
    .from('chapters')
    .select('*')
    .eq('book_fk', bookId)
    .order('chapter_order');

  if (error) {
    console.error('Supabase error:', error);
    throw error;
  }

  return data;
}

---- File Content End ----


=== File: getSectionsWithElements.ts ===
Path: lib\api\getSectionsWithElements.ts
---- File Content Start ----
import { supabase } from './supabase';

export async function getSectionsWithElements(topicId: number) {
  const { data, error } = await supabase
    .from('sections')
    .select(`
      section_pk,
      title,
      section_type_xml,
      content_elements (
        element_pk,
        element_type,
        title_attribute,
        text_content,
        attribute_level,
        attribute_type,
        list_items (
          list_item_pk,
          item_text,
          order_in_list
        )
      )
    `)
    .eq('topic_fk', topicId)
    .order('order_in_topic', { ascending: true });

  if (error) {
    throw error;
  }

  return data;
}

---- File Content End ----


=== File: getTopics.ts ===
Path: lib\api\getTopics.ts
---- File Content Start ----
import { supabase } from '@/lib/api/supabase'

export async function getTopics(chapterId: number) {
  const { data, error } = await supabase
    .from('topics')
    .select('*')
    .eq('chapter_fk', chapterId)
    .order('order_in_chapter')

  if (error) {
    console.error('Supabase error:', error)
    return []
  }

  return data
}

---- File Content End ----


=== File: supabase.ts ===
Path: lib\api\supabase.ts
---- File Content Start ----
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';
import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';

const supabaseUrl = 'https://ntvfjkvlgkpcoroyoyss.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im50dmZqa3ZsZ2twY29yb3lveXNzIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0Nzc2OTM4MiwiZXhwIjoyMDYzMzQ1MzgyfQ.9zSJSMGcct8ZHSiwJIr6cSB9oJF8uVHLkQCWqLS_P8w';

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      storage: AsyncStorage,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false,
    },
  });

---- File Content End ----


=== File: BookListScreen.tsx ===
Path: screens\BookListScreen.tsx
---- File Content Start ----
import React from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RootStackParamList } from '../layouts/AppNavigator';
import { useFetch } from '@/hooks/useFetch';
import Loader from '@/components/Loader';
import { getBooks } from '@/lib/api/getBooks';
import {
  brandColors,
  typography,
  spacing,
  screenStyles,
  createShadow
} from '@/lib/designSystem';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Books'>;

export default function BookListScreen() {
  const navigation = useNavigation<NavigationProp>();

  const { data: books, loading, error, refetch } = useFetch(getBooks);

  return (
    <View style={styles.container}>
      <Loader loading={loading} error={error} onRetry={refetch} />

      {!loading && books && (
        <>
          <Text style={styles.heading}>📚 Select a Book</Text>
          <FlatList
            data={books}
            keyExtractor={(item) => item.book_pk.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.card}
                onPress={() => navigation.navigate('Chapters', {
                  bookId: item.book_pk,
                })}
                activeOpacity={0.7}
              >
                <Text style={styles.title}>{item.title}</Text>
              </TouchableOpacity>
            )}
            showsVerticalScrollIndicator={false}
          />
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    ...screenStyles.container,
  },
  heading: {
    ...screenStyles.screenHeader,
    color: brandColors.primary.main,
  },
  card: {
    ...screenStyles.listItem,
    backgroundColor: brandColors.primary.lightest,
    borderLeftColor: brandColors.primary.main,
  },
  title: {
    ...screenStyles.listItemText,
    color: brandColors.primary.dark,
  },
});

---- File Content End ----


=== File: ChapterListScreen.tsx ===
Path: screens\ChapterListScreen.tsx
---- File Content Start ----
import React from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { getChapters } from '@/lib/api/getChapters';
import { useFetch } from '@/hooks/useFetch';
import Loader from '@/components/Loader';
import {
  brandColors,
  typography,
  spacing,
  screenStyles,
  createShadow
} from '@/lib/designSystem';

export default function ChapterListScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const { bookId } = route.params;

  const fetcher = React.useCallback(() => getChapters(bookId), [bookId]);
  const { data: chapters, loading, error, refetch } = useFetch(fetcher);

  return (
    <View style={styles.container}>
      <Loader loading={loading} error={error} onRetry={refetch} />

      {!loading && chapters && (
        <>
          <Text style={styles.heading}>📘 Select a Chapter</Text>
          <FlatList
            data={chapters}
            keyExtractor={(item) => item.chapter_pk.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.card}
                onPress={() =>
                  navigation.navigate('Topics', {
                    chapterId: item.chapter_pk,
                    bookId: bookId, // Pass bookId forward
                  })
                }
                activeOpacity={0.7}
              >
                <Text style={styles.title}>
                  {item.chapter_number_display}: {item.title}
                </Text>
              </TouchableOpacity>
            )}
            showsVerticalScrollIndicator={false}
          />
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    ...screenStyles.container,
  },
  heading: {
    ...screenStyles.screenHeader,
    color: brandColors.secondary.main,
  },
  card: {
    ...screenStyles.listItem,
    backgroundColor: brandColors.secondary.lightest,
    borderLeftColor: brandColors.secondary.main,
  },
  title: {
    ...screenStyles.listItemText,
    color: brandColors.secondary.dark,
  },
});

---- File Content End ----


=== File: ContentScreen.tsx ===
Path: screens\ContentScreen.tsx
---- File Content Start ----
import React from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';
import { useRoute } from '@react-navigation/native';
import { getSectionsWithElements } from '@/lib/api/getSectionsWithElements';
import { useFetch } from '@/hooks/useFetch';
import Loader from '@/components/Loader';
import BottomNavigationBar from '@/components/BottomNavigationBar';
import { ChemistryAnimation, AnimationType } from '@/data/animations';
import AnimationDebugTool from '@/data/animations/AnimationDebugTool';
import {
  brandColors,
  typography,
  spacing,
  screenStyles,
  getSectionStyles,
  getContentBackground,
  enhancedComponentStyles,
} from '@/lib/designSystem';

// Configuration for which memory techniques to display
const MEMORY_TECHNIQUES_CONFIG = {
  enabledTechniques: [
    'VISUAL_MNEMONICS',
    'ACRONYMS_ACROSTICS',
    'STORY_METHOD'
  ],
  maxTechniquesPerType: 3, // Limit number of items per technique type
  showEffectivenessRanking: true,
  showPracticeInstructions: false, // Can be toggled based on user preference
};

// Enhanced content element renderer
const ContentElement = ({ element }: { element: any }) => {
  const renderTextWithAnimations = (text: string) => {
    if (!text) return null;

    // Split text by animation placeholders - now supports both implemented and placeholder animations
    const parts = text.split(/(\[ANIMATION(?:_PLACEHOLDER)?:[^:]+:[^:]+\])/g);

    return parts.map((part, index) => {
      // Check if this part is an implemented animation
      const animationMatch = part.match(/\[ANIMATION:([^:]+):([^:]+)\]/);
      const placeholderMatch = part.match(/\[ANIMATION_PLACEHOLDER:([^:]+):([^:]+)\]/);

      if (animationMatch) {
        const [, animationType, height] = animationMatch;
        return (
          <ChemistryAnimation
            key={index}
            type={animationType as AnimationType}
            height={parseInt(height)}
          />
        );
      }
  //     if (animationMatch) {
  // const [, animationType, height] = animationMatch;
  // return (
  //   <AnimationDebugTool key={index} />
  // );
// }
      if (placeholderMatch) {
        const [, animationRef, height] = placeholderMatch;
        return (
          <View key={index} style={[styles.animationPlaceholder, { height: parseInt(height) }]}>
            <Text style={styles.placeholderText}>
              🎬 Animation: "{animationRef}"
            </Text>
            <Text style={styles.placeholderSubtext}>
              (Coming Soon)
            </Text>
          </View>
        );
      }

      // Regular text - process formatting
      return (
        <Text key={index} style={enhancedComponentStyles.contentText}>
          {formatText(part)}
        </Text>
      );
    });
  };

  const formatText = (text: string) => {
    // Handle bold, italic, and formulas
    return text
      .replace(/\*\*(.*?)\*\*/g, (match, content) => content) // Remove markdown for now
      .replace(/\*(.*?)\*/g, (match, content) => content)
      .replace(/\[([^:]+):([^\]]+)\]/g, (match, type, content) => {
        if (type === 'chemical') return content;
        return content;
      });
  };

  const renderListItems = () => {
    if (!element.list_items || element.list_items.length === 0) return null;

    return element.list_items
      .sort((a: any, b: any) => a.order_in_list - b.order_in_list)
      .map((item: any) => (
        <View key={item.list_item_pk} style={enhancedComponentStyles.listItem}>
          <Text style={enhancedComponentStyles.listBullet}>•</Text>
          <Text style={enhancedComponentStyles.listText}>
            {formatText(item.item_text)}
          </Text>
        </View>
      ));
  };

  const renderMemoryTechniques = () => {
    const { element_type, text_content, title_attribute } = element;

    // Check if this memory technique type is enabled
    const techniqueType = element_type.replace('_CONTAINER', '').replace('_ITEM', '');
    if (element_type.includes('_CONTAINER') &&
        !MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes(techniqueType)) {
      return null; // Skip disabled technique types
    }

    switch (element_type) {
      case 'VISUAL_MNEMONICS_CONTAINER':
        return (
          <View style={[styles.memoryContainer, styles.visualMnemonicContainer]}>
            <Text style={styles.memoryTitle}>🧠 Visual Mnemonics</Text>
          </View>
        );

      case 'VISUAL_MNEMONIC_ITEM':
        return (
          <View style={[styles.memoryItem, styles.visualMnemonicItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        );

      case 'ACRONYMS_ACROSTICS_CONTAINER':
        return (
          <View style={[styles.memoryContainer, styles.acronymContainer]}>
            <Text style={styles.memoryTitle}>🔤 Acronyms & Acrostics</Text>
          </View>
        );

      case 'ACRONYMS_ACROSTICS_ITEM':
        return (
          <View style={[styles.memoryItem, styles.acronymItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        );

      case 'STORY_METHOD_CONTAINER':
        return (
          <View style={[styles.memoryContainer, styles.storyContainer]}>
            <Text style={styles.memoryTitle}>📚 Story Method</Text>
          </View>
        );

      case 'STORY_METHOD_ITEM':
        return (
          <View style={[styles.memoryItem, styles.storyItem]}>
            <Text style={styles.storyTitle}>{title_attribute}</Text>
            {renderTextWithAnimations(text_content)}
          </View>
        );

      case 'KEYWORD_ASSOCIATIONS_CONTAINER':
        return MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes('KEYWORD_ASSOCIATIONS') ? (
          <View style={[styles.memoryContainer, styles.keywordContainer]}>
            <Text style={styles.memoryTitle}>🔑 Keyword Associations</Text>
          </View>
        ) : null;

      case 'KEYWORD_ASSOCIATIONS_ITEM':
        return MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes('KEYWORD_ASSOCIATIONS') ? (
          <View style={[styles.memoryItem, styles.keywordItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        ) : null;

      case 'MEMORY_PALACE_CONTAINER':
        return MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes('MEMORY_PALACE') ? (
          <View style={[styles.memoryContainer, styles.memoryPalaceContainer]}>
            <Text style={styles.memoryTitle}>🏰 Memory Palace</Text>
          </View>
        ) : null;

      case 'MEMORY_PALACE_ITEM':
        return MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes('MEMORY_PALACE') ? (
          <View style={[styles.memoryItem, styles.memoryPalaceItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        ) : null;

      case 'PRACTICE_INSTRUCTIONS_CONTAINER':
        return MEMORY_TECHNIQUES_CONFIG.showPracticeInstructions ? (
          <View style={[styles.memoryContainer, styles.practiceContainer]}>
            <Text style={styles.memoryTitle}>🎯 Practice Instructions</Text>
          </View>
        ) : null;

      case 'PRACTICE_INSTRUCTIONS_ITEM':
        return MEMORY_TECHNIQUES_CONFIG.showPracticeInstructions ? (
          <View style={[styles.memoryItem, styles.practiceItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        ) : null;

      case 'EFFECTIVENESS_RANKING_CONTAINER':
        return MEMORY_TECHNIQUES_CONFIG.showEffectivenessRanking ? (
          <View style={[styles.memoryContainer, styles.effectivenessContainer]}>
            <Text style={styles.memoryTitle}>📊 Effectiveness Ranking</Text>
          </View>
        ) : null;

      case 'EFFECTIVENESS_RANKING_ITEM':
        return MEMORY_TECHNIQUES_CONFIG.showEffectivenessRanking ? (
          <View style={[styles.memoryItem, styles.effectivenessItem]}>
            {renderTextWithAnimations(text_content)}
          </View>
        ) : null;

      default:
        return null;
    }
  };

  // Check if this is a memory technique element
  if (element.element_type.includes('MEMORY') ||
      element.element_type.includes('VISUAL_MNEMONIC') ||
      element.element_type.includes('ACRONYM') ||
      element.element_type.includes('STORY_METHOD') ||
      element.element_type.includes('KEYWORD') ||
      element.element_type.includes('PALACE') ||
      element.element_type.includes('PRACTICE') ||
      element.element_type.includes('EFFECTIVENESS')) {
    return renderMemoryTechniques();
  }

  // Handle regular content elements
  switch (element.element_type) {
    case 'PARAGRAPH':
      return (
        <View style={styles.paragraphContainer}>
          {renderTextWithAnimations(element.text_content)}
        </View>
      );

    case 'ANALOGY':
    case 'EXAMPLE':
    case 'CONNECTION_ITEM':
    case 'FUN_FACT':
    case 'INTERACTIVE_PROMPT':
      return (
        <View style={styles.specialContentContainer}>
          {element.title_attribute && (
            <Text style={styles.specialContentTitle}>{element.title_attribute}</Text>
          )}
          {renderTextWithAnimations(element.text_content)}
          {renderListItems()}
        </View>
      );

    case 'KEY_POINTS_CONTAINER':
      return (
        <View style={styles.keyPointsContainer}>
          <Text style={styles.keyPointsTitle}>Key Points</Text>
          {renderListItems()}
        </View>
      );

    case 'EXERCISE_HEADER':
      return (
        <View style={styles.exerciseHeader}>
          <Text style={styles.exerciseTitle}>{element.title_attribute}</Text>
        </View>
      );

    case 'QUESTION':
      return (
        <View style={styles.questionContainer}>
          <Text style={styles.questionLabel}>Question:</Text>
          {renderTextWithAnimations(element.text_content)}
          {renderListItems()}
        </View>
      );

    case 'ANSWER':
      return (
        <View style={styles.answerContainer}>
          <Text style={styles.answerLabel}>Answer:</Text>
          {renderTextWithAnimations(element.text_content)}
        </View>
      );

    case 'ANSWER_FRAMEWORK':
      return (
        <View style={styles.answerFrameworkContainer}>
          <Text style={styles.answerFrameworkLabel}>Answer Framework:</Text>
          {renderTextWithAnimations(element.text_content)}
        </View>
      );

    case 'LIST_UNORDERED_CONTAINER':
    case 'LIST_ORDERED_CONTAINER':
    case 'LIST_ALPHA_ORDERED_CONTAINER':
      return (
        <View style={styles.listContainer}>
          {element.title_attribute && (
            <Text style={styles.listTitle}>{element.title_attribute}</Text>
          )}
          {renderListItems()}
        </View>
      );

    default:
      return (
        <View style={styles.defaultContainer}>
          {element.title_attribute && (
            <Text style={styles.defaultTitle}>{element.title_attribute}</Text>
          )}
          {renderTextWithAnimations(element.text_content)}
          {renderListItems()}
        </View>
      );
  }
};

// Filter memory technique elements based on configuration
const filterMemoryTechniqueElements = (elements: any[]) => {
  const filteredElements: any[] = [];
  const techniqueItemCounts: { [key: string]: number } = {};

  elements.forEach(element => {
    const elementType = element.element_type;

    // Always include container elements if technique is enabled
    if (elementType.includes('_CONTAINER')) {
      const techniqueType = elementType.replace('_CONTAINER', '');
      if (MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes(techniqueType) ||
          elementType === 'PRACTICE_INSTRUCTIONS_CONTAINER' && MEMORY_TECHNIQUES_CONFIG.showPracticeInstructions ||
          elementType === 'EFFECTIVENESS_RANKING_CONTAINER' && MEMORY_TECHNIQUES_CONFIG.showEffectivenessRanking) {
        filteredElements.push(element);
        techniqueItemCounts[techniqueType] = 0;
      }
      return;
    }

    // Filter item elements based on limits
    if (elementType.includes('_ITEM')) {
      const techniqueType = elementType.replace('_ITEM', '');

      // Check if technique is enabled
      if (!MEMORY_TECHNIQUES_CONFIG.enabledTechniques.includes(techniqueType) &&
          !(elementType === 'PRACTICE_INSTRUCTIONS_ITEM' && MEMORY_TECHNIQUES_CONFIG.showPracticeInstructions) &&
          !(elementType === 'EFFECTIVENESS_RANKING_ITEM' && MEMORY_TECHNIQUES_CONFIG.showEffectivenessRanking)) {
        return;
      }

      // Check item limit
      if (techniqueItemCounts[techniqueType] < MEMORY_TECHNIQUES_CONFIG.maxTechniquesPerType) {
        filteredElements.push(element);
        techniqueItemCounts[techniqueType]++;
      }
      return;
    }

    // Include non-memory technique elements
    filteredElements.push(element);
  });

  return filteredElements;
};

// Main section renderer
const SectionCard = ({ section }: { section: any }) => {
  const normalizedTitle = section.section_type_xml?.replace(/[^A-Z_]/g, '') || 'DEFAULT';
  const sectionStyles = getSectionStyles(normalizedTitle);
  const contentBgColor = getContentBackground(normalizedTitle);

  // Special styling for memory techniques section
  const isMemorySection = section.section_type_xml === 'MEMORY_TECHNIQUES';

  // Filter elements for memory techniques section
  const elementsToRender = isMemorySection
    ? filterMemoryTechniqueElements(section.content_elements || [])
    : section.content_elements || [];

  // Don't render empty memory sections
  if (isMemorySection && elementsToRender.length === 0) {
    return null;
  }

  return (
    <View style={[
      enhancedComponentStyles.sectionCard,
      isMemorySection && styles.memorySectionCard
    ]}>
      {/* Section Header */}
      <View style={[
        enhancedComponentStyles.sectionHeader,
        { backgroundColor: isMemorySection ? '#6366f1' : sectionStyles.headerBgColor }
      ]}>
        <Text style={styles.sectionEmoji}>
          {isMemorySection ? '🧠' : sectionStyles.iconEmoji}
        </Text>
        <Text style={[
          enhancedComponentStyles.sectionTitle,
          { color: sectionStyles.headerTextColor }
        ]}>
          {section.title}
        </Text>
      </View>

      {/* Section Content */}
      <View style={[
        enhancedComponentStyles.sectionContent,
        { backgroundColor: isMemorySection ? '#f8fafc' : contentBgColor }
      ]}>
        {elementsToRender
          .sort((a: any, b: any) => a.order_in_section - b.order_in_section)
          .map((element: any) => (
            <ContentElement key={element.element_pk} element={element} />
          ))}
      </View>
    </View>
  );
};

// Main ContentScreen component
export default function ContentScreen() {
  const route = useRoute<any>();
  const { topicId, chapterId, bookId, topics } = route.params;

  const fetcher = React.useCallback(() => getSectionsWithElements(topicId), [topicId]);
  const { data: sections, loading, error, refetch } = useFetch(fetcher);

  const currentTopic = topics?.find((t: any) => t.topic_pk === topicId);

  return (
    <View style={styles.container}>
      <Loader loading={loading} error={error} onRetry={refetch} />

      {!loading && sections && (
        <>
          <ScrollView
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
            contentContainerStyle={styles.scrollContent}
          >
            {/* Topic Header */}
            <Text style={styles.topicTitle}>{currentTopic?.title}</Text>

            {/* Sections */}
            {sections
              .sort((a: any, b: any) => a.order_in_topic - b.order_in_topic)
              .map((section: any) => (
                <SectionCard key={section.section_pk} section={section} />
              ))}
          </ScrollView>

          <BottomNavigationBar
            topicId={topicId}
            chapterId={chapterId}
            bookId={bookId}
            topics={topics}
          />
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: brandColors.background,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: spacing.md,
    paddingTop: spacing.lg,
    paddingBottom: spacing.xl,
  },
  topicTitle: {
    fontSize: typography.fontSize['3xl'],
    fontWeight: typography.fontWeight.bold,
    color: brandColors.neutral.dark,
    textAlign: 'center',
    marginBottom: spacing.xl,
  },
  sectionEmoji: {
    fontSize: 20,
    marginRight: spacing.sm,
  },

  // Animation Placeholder Styles
  animationPlaceholder: {
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
    marginVertical: spacing.md,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#d1d5db',
    borderStyle: 'dashed',
  },
  placeholderText: {
    fontSize: typography.fontSize.base,
    fontWeight: typography.fontWeight.semibold,
    color: '#6b7280',
    marginBottom: spacing.xs,
  },
  placeholderSubtext: {
    fontSize: typography.fontSize.sm,
    color: '#9ca3af',
    fontStyle: 'italic',
  },

  // Memory Techniques Styles
  memorySectionCard: {
    borderLeftWidth: 4,
    borderLeftColor: '#6366f1',
  },
  memoryContainer: {
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.sm,
    borderLeftWidth: 3,
  },
  memoryTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.bold,
    marginBottom: spacing.sm,
  },
  memoryItem: {
    backgroundColor: '#ffffff',
    borderRadius: 6,
    padding: spacing.sm,
    marginBottom: spacing.xs,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },

  // Specific Memory Technique Styles
  visualMnemonicContainer: {
    backgroundColor: '#faf5ff',
    borderLeftColor: '#8b5cf6',
  },
  visualMnemonicItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#8b5cf6',
  },
  acronymContainer: {
    backgroundColor: '#f0f9ff',
    borderLeftColor: '#0ea5e9',
  },
  acronymItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#0ea5e9',
  },
  storyContainer: {
    backgroundColor: '#fefce8',
    borderLeftColor: '#eab308',
  },
  storyItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#eab308',
  },
  storyTitle: {
    fontSize: typography.fontSize.base,
    fontWeight: typography.fontWeight.semibold,
    color: '#92400e',
    marginBottom: spacing.xs,
  },
  keywordContainer: {
    backgroundColor: '#f0fdf4',
    borderLeftColor: '#10b981',
  },
  keywordItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#10b981',
  },
  memoryPalaceContainer: {
    backgroundColor: '#fef7ff',
    borderLeftColor: '#a855f7',
  },
  memoryPalaceItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#a855f7',
  },
  practiceContainer: {
    backgroundColor: '#f0f9ff',
    borderLeftColor: '#0284c7',
  },
  practiceItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#0284c7',
  },
  effectivenessContainer: {
    backgroundColor: '#fef2f2',
    borderLeftColor: '#ef4444',
  },
  effectivenessItem: {
    borderLeftWidth: 2,
    borderLeftColor: '#ef4444',
  },

  // Content Element Styles
  paragraphContainer: {
    marginBottom: spacing.md,
  },
  specialContentContainer: {
    backgroundColor: '#f8fafc',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.md,
    borderLeftWidth: 3,
    borderLeftColor: brandColors.accent.main,
  },
  specialContentTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.semibold,
    color: brandColors.accent.dark,
    marginBottom: spacing.sm,
  },
  keyPointsContainer: {
    backgroundColor: '#fef3c7',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.md,
  },
  keyPointsTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.bold,
    color: '#92400e',
    marginBottom: spacing.sm,
  },
  exerciseHeader: {
    backgroundColor: '#fee2e2',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.sm,
  },
  exerciseTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.bold,
    color: '#991b1b',
  },
  questionContainer: {
    backgroundColor: '#ecfdf5',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.sm,
  },
  questionLabel: {
    fontSize: typography.fontSize.base,
    fontWeight: typography.fontWeight.semibold,
    color: '#065f46',
    marginBottom: spacing.xs,
  },
  answerContainer: {
    backgroundColor: '#f0f9ff',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.sm,
  },
  answerLabel: {
    fontSize: typography.fontSize.base,
    fontWeight: typography.fontWeight.semibold,
    color: '#0c4a6e',
    marginBottom: spacing.xs,
  },
  answerFrameworkContainer: {
    backgroundColor: '#fdf4ff',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.sm,
  },
  answerFrameworkLabel: {
    fontSize: typography.fontSize.base,
    fontWeight: typography.fontWeight.semibold,
    color: '#7c2d12',
    marginBottom: spacing.xs,
  },
  listContainer: {
    marginBottom: spacing.md,
  },
  listTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.semibold,
    color: brandColors.neutral.dark,
    marginBottom: spacing.sm,
  },
  defaultContainer: {
    marginBottom: spacing.md,
  },
  defaultTitle: {
    fontSize: typography.fontSize.lg,
    fontWeight: typography.fontWeight.semibold,
    color: brandColors.neutral.dark,
    marginBottom: spacing.sm,
  },
});

---- File Content End ----


=== File: TopicListScreen.tsx ===
Path: screens\TopicListScreen.tsx
---- File Content Start ----
import React from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { getTopics } from '@/lib/api/getTopics';
import { useFetch } from '@/hooks/useFetch';
import Loader from '@/components/Loader';
import {
  brandColors,
  typography,
  spacing,
  screenStyles,
  createShadow
} from '@/lib/designSystem';

export default function TopicListScreen() {
  const route = useRoute<any>();
  const navigation = useNavigation<any>();
  const { chapterId, bookId } = route.params;

  // Debug logging
  //console.log('TopicListScreen params:', route.params);

  const fetcher = React.useCallback(() => getTopics(chapterId), [chapterId]);
  const { data: topics, loading, error, refetch } = useFetch(fetcher);

  const handleTopicPress = (selectedTopic: any) => {
    console.log('Navigating to Content with:', {
      topicId: selectedTopic.topic_pk,
      chapterId,
      bookId,
      topics: topics?.length || 0
    });

    navigation.navigate('Content', {
      topicId: selectedTopic.topic_pk,
      chapterId: chapterId,
      bookId: bookId,
      topics: topics || []
    });
  };

  return (
    <View style={styles.container}>
      <Loader loading={loading} error={error} onRetry={refetch} />

      {!loading && topics && (
        <>
          <Text style={styles.heading}>🧪 Select a Topic</Text>
          <FlatList
            data={topics}
            keyExtractor={(item) => item.topic_pk.toString()}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.card}
                onPress={() => handleTopicPress(item)}
                activeOpacity={0.7}
              >
                <Text style={styles.title}>{item.title}</Text>
              </TouchableOpacity>
            )}
            showsVerticalScrollIndicator={false}
          />
        </>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    ...screenStyles.container,
  },
  heading: {
    ...screenStyles.screenHeader,
    color: brandColors.accent.main,
  },
  card: {
    ...screenStyles.listItem,
    backgroundColor: brandColors.accent.lightest,
    borderLeftColor: brandColors.accent.main,
  },
  title: {
    ...screenStyles.listItemText,
    color: brandColors.accent.dark,
  },
});

---- File Content End ----

